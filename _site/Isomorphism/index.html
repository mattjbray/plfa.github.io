<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Isomorphism: Isomorphism and Embedding | Programming Language Foundations in Agda
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Isomorphism: Isomorphism and Embedding" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Programming Language Foundations in Agda" />
<meta property="og:description" content="Programming Language Foundations in Agda" />
<link rel="canonical" href="https://plfa.github.io/Isomorphism/" />
<meta property="og:url" content="https://plfa.github.io/Isomorphism/" />
<meta property="og:site_name" content="Programming Language Foundations in Agda" />
<script type="application/ld+json">
{"description":"Programming Language Foundations in Agda","@type":"WebPage","url":"https://plfa.github.io/Isomorphism/","headline":"Isomorphism: Isomorphism and Embedding","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/">Programming Language Foundations in Agda
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/">The Book</a>
                <a class="page-link" href="/Announcements/">Announcements</a>
                <a class="page-link" href="/GettingStarted/">Getting Started</a>
                <a class="page-link" href="/Citing/">Citing</a>
                <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Isomorphism: Isomorphism and Embedding</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/Equality/">Prev</a>
    
    
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/Isomorphism.lagda.md">Source</a>
    
    
    &bullet;
    
    
    <a alt="Next chapter" href="/Connectives/">Next</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="159" class="Keyword">module</a> <a id="166" href="/Isomorphism/" class="Module">plfa.Isomorphism</a> <a id="183" class="Keyword">where</a>
</pre>
<p>This section introduces isomorphism as a way of asserting that two
types are equal, and embedding as a way of asserting that one type is
smaller than another.  We apply isomorphisms in the next chapter
to demonstrate that operations on types such as product and sum
satisfy properties akin to associativity, commutativity, and
distributivity.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="554" class="Keyword">import</a> <a id="561" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="599" class="Symbol">as</a> <a id="602" class="Module">Eq</a>
<a id="605" class="Keyword">open</a> <a id="610" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="613" class="Keyword">using</a> <a id="619" class="Symbol">(</a><a id="620" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="623" class="Symbol">;</a> <a id="625" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="629" class="Symbol">;</a> <a id="631" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a><a id="635" class="Symbol">;</a> <a id="637" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a><a id="645" class="Symbol">)</a>
<a id="647" class="Keyword">open</a> <a id="652" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2499" class="Module">Eq.≡-Reasoning</a>
<a id="667" class="Keyword">open</a> <a id="672" class="Keyword">import</a> <a id="679" href="https://agda.github.io/agda-stdlib/v1.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="688" class="Keyword">using</a> <a id="694" class="Symbol">(</a><a id="695" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="696" class="Symbol">;</a> <a id="698" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="702" class="Symbol">;</a> <a id="704" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="707" class="Symbol">;</a> <a id="709" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+_</a><a id="712" class="Symbol">)</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="https://agda.github.io/agda-stdlib/v1.1/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="746" class="Keyword">using</a> <a id="752" class="Symbol">(</a><a id="753" href="https://agda.github.io/agda-stdlib/v1.1/Data.Nat.Properties.html#11911" class="Function">+-comm</a><a id="759" class="Symbol">)</a>
</pre>

<h2 id="lambda-expressions">Lambda expressions</h2>

<p>The chapter begins with a few preliminaries that will be useful
here and elsewhere: lambda expressions, function composition, and
extensionality.</p>

<p><em>Lambda expressions</em> provide a compact way to define functions without
naming them.  A term of the form</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ{ P₁ → N₁; ⋯ ; Pₙ → Nₙ }
</code></pre></div></div>

<p>is equivalent to a function <code class="highlighter-rouge">f</code> defined by the equations</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f P₁ = N₁
⋯
f Pₙ = Nₙ
</code></pre></div></div>

<p>where the <code class="highlighter-rouge">Pₙ</code> are patterns (left-hand sides of an equation) and the
<code class="highlighter-rouge">Nₙ</code> are expressions (right-hand side of an equation).</p>

<p>In the case that there is one equation and the pattern is a variable,
we may also use the syntax</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ x → N
</code></pre></div></div>

<p>or</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ (x : A) → N
</code></pre></div></div>

<p>both of which are equivalent to <code class="highlighter-rouge">λ{x → N}</code>. The latter allows one to
specify the domain of the function.</p>

<p>Often using an anonymous lambda expression is more convenient than
using a named function: it avoids a lengthy type declaration; and the
definition appears exactly where the function is used, so there is no
need for the writer to remember to declare it in advance, or for the
reader to search for the definition in the code.</p>

<h2 id="function-composition">Function composition</h2>

<p>In what follows, we will make use of function composition:</p>
<pre class="Agda"><a id="_∘_"></a><a id="1946" href="/Isomorphism/#1946" class="Function Operator">_∘_</a> <a id="1950" class="Symbol">:</a> <a id="1952" class="Symbol">∀</a> <a id="1954" class="Symbol">{</a><a id="1955" href="plfa.Isomorphism.html#1955" class="Bound">A</a> <a id="1957" href="plfa.Isomorphism.html#1957" class="Bound">B</a> <a id="1959" href="plfa.Isomorphism.html#1959" class="Bound">C</a> <a id="1961" class="Symbol">:</a> <a id="1963" class="PrimitiveType">Set</a><a id="1966" class="Symbol">}</a> <a id="1968" class="Symbol">→</a> <a id="1970" class="Symbol">(</a><a id="1971" href="plfa.Isomorphism.html#1957" class="Bound">B</a> <a id="1973" class="Symbol">→</a> <a id="1975" href="plfa.Isomorphism.html#1959" class="Bound">C</a><a id="1976" class="Symbol">)</a> <a id="1978" class="Symbol">→</a> <a id="1980" class="Symbol">(</a><a id="1981" href="plfa.Isomorphism.html#1955" class="Bound">A</a> <a id="1983" class="Symbol">→</a> <a id="1985" href="plfa.Isomorphism.html#1957" class="Bound">B</a><a id="1986" class="Symbol">)</a> <a id="1988" class="Symbol">→</a> <a id="1990" class="Symbol">(</a><a id="1991" href="plfa.Isomorphism.html#1955" class="Bound">A</a> <a id="1993" class="Symbol">→</a> <a id="1995" href="plfa.Isomorphism.html#1959" class="Bound">C</a><a id="1996" class="Symbol">)</a>
<a id="1998" class="Symbol">(</a><a id="1999" href="/Isomorphism/#1999" class="Bound">g</a> <a id="2001" href="plfa.Isomorphism.html#1946" class="Function Operator">∘</a> <a id="2003" href="plfa.Isomorphism.html#2003" class="Bound">f</a><a id="2004" class="Symbol">)</a> <a id="2006" href="plfa.Isomorphism.html#2006" class="Bound">x</a>  <a id="2009" class="Symbol">=</a> <a id="2011" href="plfa.Isomorphism.html#1999" class="Bound">g</a> <a id="2013" class="Symbol">(</a><a id="2014" href="plfa.Isomorphism.html#2003" class="Bound">f</a> <a id="2016" href="plfa.Isomorphism.html#2006" class="Bound">x</a><a id="2017" class="Symbol">)</a>
</pre>
<p>Thus, <code class="highlighter-rouge">g ∘ f</code> is the function that first applies <code class="highlighter-rouge">f</code> and
then applies <code class="highlighter-rouge">g</code>.  An equivalent definition, exploiting lambda
expressions, is as follows:</p>
<pre class="Agda"><a id="_∘′_"></a><a id="2175" href="/Isomorphism/#2175" class="Function Operator">_∘′_</a> <a id="2180" class="Symbol">:</a> <a id="2182" class="Symbol">∀</a> <a id="2184" class="Symbol">{</a><a id="2185" href="plfa.Isomorphism.html#2185" class="Bound">A</a> <a id="2187" href="plfa.Isomorphism.html#2187" class="Bound">B</a> <a id="2189" href="plfa.Isomorphism.html#2189" class="Bound">C</a> <a id="2191" class="Symbol">:</a> <a id="2193" class="PrimitiveType">Set</a><a id="2196" class="Symbol">}</a> <a id="2198" class="Symbol">→</a> <a id="2200" class="Symbol">(</a><a id="2201" href="plfa.Isomorphism.html#2187" class="Bound">B</a> <a id="2203" class="Symbol">→</a> <a id="2205" href="plfa.Isomorphism.html#2189" class="Bound">C</a><a id="2206" class="Symbol">)</a> <a id="2208" class="Symbol">→</a> <a id="2210" class="Symbol">(</a><a id="2211" href="plfa.Isomorphism.html#2185" class="Bound">A</a> <a id="2213" class="Symbol">→</a> <a id="2215" href="plfa.Isomorphism.html#2187" class="Bound">B</a><a id="2216" class="Symbol">)</a> <a id="2218" class="Symbol">→</a> <a id="2220" class="Symbol">(</a><a id="2221" href="plfa.Isomorphism.html#2185" class="Bound">A</a> <a id="2223" class="Symbol">→</a> <a id="2225" href="plfa.Isomorphism.html#2189" class="Bound">C</a><a id="2226" class="Symbol">)</a>
<a id="2228" href="/Isomorphism/#2228" class="Bound">g</a> <a id="2230" href="plfa.Isomorphism.html#2175" class="Function Operator">∘′</a> <a id="2233" href="plfa.Isomorphism.html#2233" class="Bound">f</a>  <a id="2236" class="Symbol">=</a>  <a id="2239" class="Symbol">λ</a> <a id="2241" href="plfa.Isomorphism.html#2241" class="Bound">x</a> <a id="2243" class="Symbol">→</a> <a id="2245" href="plfa.Isomorphism.html#2228" class="Bound">g</a> <a id="2247" class="Symbol">(</a><a id="2248" href="plfa.Isomorphism.html#2233" class="Bound">f</a> <a id="2250" href="plfa.Isomorphism.html#2241" class="Bound">x</a><a id="2251" class="Symbol">)</a>
</pre>

<h2 id="extensionality">Extensionality</h2>

<p>Extensionality asserts that the only way to distinguish functions is
by applying them; if two functions applied to the same argument always
yield the same result, then they are the same function.  It is the
converse of <code class="highlighter-rouge">cong-app</code>, as introduced
<a href="/Equality/#cong">earlier</a>.</p>

<p>Agda does not presume extensionality, but we can postulate that it holds:</p>
<pre class="Agda"><a id="2666" class="Keyword">postulate</a>
  <a id="extensionality"></a><a id="2678" href="/Isomorphism/#2678" class="Postulate">extensionality</a> <a id="2693" class="Symbol">:</a> <a id="2695" class="Symbol">∀</a> <a id="2697" class="Symbol">{</a><a id="2698" href="plfa.Isomorphism.html#2698" class="Bound">A</a> <a id="2700" href="plfa.Isomorphism.html#2700" class="Bound">B</a> <a id="2702" class="Symbol">:</a> <a id="2704" class="PrimitiveType">Set</a><a id="2707" class="Symbol">}</a> <a id="2709" class="Symbol">{</a><a id="2710" href="plfa.Isomorphism.html#2710" class="Bound">f</a> <a id="2712" href="plfa.Isomorphism.html#2712" class="Bound">g</a> <a id="2714" class="Symbol">:</a> <a id="2716" href="plfa.Isomorphism.html#2698" class="Bound">A</a> <a id="2718" class="Symbol">→</a> <a id="2720" href="plfa.Isomorphism.html#2700" class="Bound">B</a><a id="2721" class="Symbol">}</a>
    <a id="2727" class="Symbol">→</a> <a id="2729" class="Symbol">(∀</a> <a id="2732" class="Symbol">(</a><a id="2733" href="/Isomorphism/#2733" class="Bound">x</a> <a id="2735" class="Symbol">:</a> <a id="2737" href="plfa.Isomorphism.html#2698" class="Bound">A</a><a id="2738" class="Symbol">)</a> <a id="2740" class="Symbol">→</a> <a id="2742" href="plfa.Isomorphism.html#2710" class="Bound">f</a> <a id="2744" href="plfa.Isomorphism.html#2733" class="Bound">x</a> <a id="2746" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="2748" href="plfa.Isomorphism.html#2712" class="Bound">g</a> <a id="2750" href="plfa.Isomorphism.html#2733" class="Bound">x</a><a id="2751" class="Symbol">)</a>
      <a id="2759" class="Comment">-----------------------</a>
    <a id="2787" class="Symbol">→</a> <a id="2789" href="/Isomorphism/#2710" class="Bound">f</a> <a id="2791" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="2793" href="plfa.Isomorphism.html#2712" class="Bound">g</a>
</pre>
<p>Postulating extensionality does not lead to difficulties, as it is
known to be consistent with the theory that underlies https://agda.github.io/agda-stdlib/v1.1/Agda.</p>

<p>As an example, consider that we need results from two libraries,
one where addition is defined, as in
Chapter <a href="/Naturals/">Naturals</a>,
and one where it is defined the other way around.</p>
<pre class="Agda"><a id="_+′_"></a><a id="3133" href="/Isomorphism/#3133" class="Function Operator">_+′_</a> <a id="3138" class="Symbol">:</a> <a id="3140" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="3142" class="Symbol">→</a> <a id="3144" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="3146" class="Symbol">→</a> <a id="3148" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="3150" href="/Isomorphism/#3150" class="Bound">m</a> <a id="3152" href="plfa.Isomorphism.html#3133" class="Function Operator">+′</a> <a id="3155" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>  <a id="3161" class="Symbol">=</a> <a id="3163" href="plfa.Isomorphism.html#3150" class="Bound">m</a>
<a id="3165" href="/Isomorphism/#3165" class="Bound">m</a> <a id="3167" href="plfa.Isomorphism.html#3133" class="Function Operator">+′</a> <a id="3170" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3174" href="plfa.Isomorphism.html#3174" class="Bound">n</a> <a id="3176" class="Symbol">=</a> <a id="3178" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3182" class="Symbol">(</a><a id="3183" href="plfa.Isomorphism.html#3165" class="Bound">m</a> <a id="3185" href="plfa.Isomorphism.html#3133" class="Function Operator">+′</a> <a id="3188" href="plfa.Isomorphism.html#3174" class="Bound">n</a><a id="3189" class="Symbol">)</a>
</pre>
<p>Applying commutativity, it is easy to show that both operators always
return the same result given the same arguments:</p>
<pre class="Agda"><a id="same-app"></a><a id="3318" href="/Isomorphism/#3318" class="Function">same-app</a> <a id="3327" class="Symbol">:</a> <a id="3329" class="Symbol">∀</a> <a id="3331" class="Symbol">(</a><a id="3332" href="plfa.Isomorphism.html#3332" class="Bound">m</a> <a id="3334" href="plfa.Isomorphism.html#3334" class="Bound">n</a> <a id="3336" class="Symbol">:</a> <a id="3338" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="3339" class="Symbol">)</a> <a id="3341" class="Symbol">→</a> <a id="3343" href="plfa.Isomorphism.html#3332" class="Bound">m</a> <a id="3345" href="plfa.Isomorphism.html#3133" class="Function Operator">+′</a> <a id="3348" href="plfa.Isomorphism.html#3334" class="Bound">n</a> <a id="3350" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3352" href="plfa.Isomorphism.html#3332" class="Bound">m</a> <a id="3354" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3356" href="plfa.Isomorphism.html#3334" class="Bound">n</a>
<a id="3358" href="/Isomorphism/#3318" class="Function">same-app</a> <a id="3367" href="plfa.Isomorphism.html#3367" class="Bound">m</a> <a id="3369" href="plfa.Isomorphism.html#3369" class="Bound">n</a> <a id="3371" class="Keyword">rewrite</a> <a id="3379" href="https://agda.github.io/agda-stdlib/v1.1/Data.Nat.Properties.html#11911" class="Function">+-comm</a> <a id="3386" href="plfa.Isomorphism.html#3367" class="Bound">m</a> <a id="3388" href="plfa.Isomorphism.html#3369" class="Bound">n</a> <a id="3390" class="Symbol">=</a> <a id="3392" href="plfa.Isomorphism.html#3413" class="Function">helper</a> <a id="3399" href="plfa.Isomorphism.html#3367" class="Bound">m</a> <a id="3401" href="plfa.Isomorphism.html#3369" class="Bound">n</a>
  <a id="3405" class="Keyword">where</a>
  <a id="3413" href="/Isomorphism/#3413" class="Function">helper</a> <a id="3420" class="Symbol">:</a> <a id="3422" class="Symbol">∀</a> <a id="3424" class="Symbol">(</a><a id="3425" href="plfa.Isomorphism.html#3425" class="Bound">m</a> <a id="3427" href="plfa.Isomorphism.html#3427" class="Bound">n</a> <a id="3429" class="Symbol">:</a> <a id="3431" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="3432" class="Symbol">)</a> <a id="3434" class="Symbol">→</a> <a id="3436" href="plfa.Isomorphism.html#3425" class="Bound">m</a> <a id="3438" href="plfa.Isomorphism.html#3133" class="Function Operator">+′</a> <a id="3441" href="plfa.Isomorphism.html#3427" class="Bound">n</a> <a id="3443" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3445" href="plfa.Isomorphism.html#3427" class="Bound">n</a> <a id="3447" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3449" href="plfa.Isomorphism.html#3425" class="Bound">m</a>
  <a id="3453" href="/Isomorphism/#3413" class="Function">helper</a> <a id="3460" href="plfa.Isomorphism.html#3460" class="Bound">m</a> <a id="3462" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="3470" class="Symbol">=</a> <a id="3472" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="3479" href="/Isomorphism/#3413" class="Function">helper</a> <a id="3486" href="plfa.Isomorphism.html#3486" class="Bound">m</a> <a id="3488" class="Symbol">(</a><a id="3489" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3493" href="plfa.Isomorphism.html#3493" class="Bound">n</a><a id="3494" class="Symbol">)</a> <a id="3496" class="Symbol">=</a> <a id="3498" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="3503" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3507" class="Symbol">(</a><a id="3508" href="plfa.Isomorphism.html#3413" class="Function">helper</a> <a id="3515" href="plfa.Isomorphism.html#3486" class="Bound">m</a> <a id="3517" href="plfa.Isomorphism.html#3493" class="Bound">n</a><a id="3518" class="Symbol">)</a>
</pre>
<p>However, it might be convenient to assert that the two operators are
actually indistinguishable. This we can do via two applications of
extensionality:</p>
<pre class="Agda"><a id="same"></a><a id="3680" href="/Isomorphism/#3680" class="Function">same</a> <a id="3685" class="Symbol">:</a> <a id="3687" href="plfa.Isomorphism.html#3133" class="Function Operator">_+′_</a> <a id="3692" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3694" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+_</a>
<a id="3698" href="/Isomorphism/#3680" class="Function">same</a> <a id="3703" class="Symbol">=</a> <a id="3705" href="plfa.Isomorphism.html#2678" class="Postulate">extensionality</a> <a id="3720" class="Symbol">(λ</a> <a id="3723" href="plfa.Isomorphism.html#3723" class="Bound">m</a> <a id="3725" class="Symbol">→</a> <a id="3727" href="plfa.Isomorphism.html#2678" class="Postulate">extensionality</a> <a id="3742" class="Symbol">(λ</a> <a id="3745" href="plfa.Isomorphism.html#3745" class="Bound">n</a> <a id="3747" class="Symbol">→</a> <a id="3749" href="plfa.Isomorphism.html#3318" class="Function">same-app</a> <a id="3758" href="plfa.Isomorphism.html#3723" class="Bound">m</a> <a id="3760" href="plfa.Isomorphism.html#3745" class="Bound">n</a><a id="3761" class="Symbol">))</a>
</pre>
<p>We occasionally need to postulate extensionality in what follows.</p>

<h2 id="isomorphism">Isomorphism</h2>

<p>Two sets are isomorphic if they are in one-to-one correspondence.
Here is a formal definition of isomorphism:</p>
<pre class="Agda"><a id="3966" class="Keyword">infix</a> <a id="3972" class="Number">0</a> <a id="3974" href="/Isomorphism/#3985" class="Record Operator">_≃_</a>
<a id="3978" class="Keyword">record</a> <a id="_≃_"></a><a id="3985" href="/Isomorphism/#3985" class="Record Operator">_≃_</a> <a id="3989" class="Symbol">(</a><a id="3990" href="plfa.Isomorphism.html#3990" class="Bound">A</a> <a id="3992" href="plfa.Isomorphism.html#3992" class="Bound">B</a> <a id="3994" class="Symbol">:</a> <a id="3996" class="PrimitiveType">Set</a><a id="3999" class="Symbol">)</a> <a id="4001" class="Symbol">:</a> <a id="4003" class="PrimitiveType">Set</a> <a id="4007" class="Keyword">where</a>
  <a id="4015" class="Keyword">field</a>
    <a id="_≃_.to"></a><a id="4025" href="/Isomorphism/#4025" class="Field">to</a>   <a id="4030" class="Symbol">:</a> <a id="4032" href="plfa.Isomorphism.html#3990" class="Bound">A</a> <a id="4034" class="Symbol">→</a> <a id="4036" href="plfa.Isomorphism.html#3992" class="Bound">B</a>
    <a id="_≃_.from"></a><a id="4042" href="/Isomorphism/#4042" class="Field">from</a> <a id="4047" class="Symbol">:</a> <a id="4049" href="plfa.Isomorphism.html#3992" class="Bound">B</a> <a id="4051" class="Symbol">→</a> <a id="4053" href="plfa.Isomorphism.html#3990" class="Bound">A</a>
    <a id="_≃_.from∘to"></a><a id="4059" href="/Isomorphism/#4059" class="Field">from∘to</a> <a id="4067" class="Symbol">:</a> <a id="4069" class="Symbol">∀</a> <a id="4071" class="Symbol">(</a><a id="4072" href="plfa.Isomorphism.html#4072" class="Bound">x</a> <a id="4074" class="Symbol">:</a> <a id="4076" href="plfa.Isomorphism.html#3990" class="Bound">A</a><a id="4077" class="Symbol">)</a> <a id="4079" class="Symbol">→</a> <a id="4081" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="4086" class="Symbol">(</a><a id="4087" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="4090" href="plfa.Isomorphism.html#4072" class="Bound">x</a><a id="4091" class="Symbol">)</a> <a id="4093" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4095" href="plfa.Isomorphism.html#4072" class="Bound">x</a>
    <a id="_≃_.to∘from"></a><a id="4101" href="/Isomorphism/#4101" class="Field">to∘from</a> <a id="4109" class="Symbol">:</a> <a id="4111" class="Symbol">∀</a> <a id="4113" class="Symbol">(</a><a id="4114" href="plfa.Isomorphism.html#4114" class="Bound">y</a> <a id="4116" class="Symbol">:</a> <a id="4118" href="plfa.Isomorphism.html#3992" class="Bound">B</a><a id="4119" class="Symbol">)</a> <a id="4121" class="Symbol">→</a> <a id="4123" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="4126" class="Symbol">(</a><a id="4127" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="4132" href="plfa.Isomorphism.html#4114" class="Bound">y</a><a id="4133" class="Symbol">)</a> <a id="4135" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4137" href="plfa.Isomorphism.html#4114" class="Bound">y</a>
<a id="4139" class="Keyword">open</a> <a id="4144" href="/Isomorphism/#3985" class="Module Operator">_≃_</a>
</pre>
<p>Let’s unpack the definition. An isomorphism between sets <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> consists
of four things:</p>
<ul>
  <li>A function <code class="highlighter-rouge">to</code> from <code class="highlighter-rouge">A</code> to <code class="highlighter-rouge">B</code>,</li>
  <li>A function <code class="highlighter-rouge">from</code> from <code class="highlighter-rouge">B</code> back to <code class="highlighter-rouge">A</code>,</li>
  <li>Evidence <code class="highlighter-rouge">from∘to</code> asserting that <code class="highlighter-rouge">from</code> is a <em>left-inverse</em> for <code class="highlighter-rouge">to</code>,</li>
  <li>Evidence <code class="highlighter-rouge">to∘from</code> asserting that <code class="highlighter-rouge">from</code> is a <em>right-inverse</em> for <code class="highlighter-rouge">to</code>.</li>
</ul>

<p>In particular, the third asserts that <code class="highlighter-rouge">from ∘ to</code> is the identity, and
the fourth that <code class="highlighter-rouge">to ∘ from</code> is the identity, hence the names.
The declaration <code class="highlighter-rouge">open _≃_</code> makes available the names <code class="highlighter-rouge">to</code>, <code class="highlighter-rouge">from</code>,
<code class="highlighter-rouge">from∘to</code>, and <code class="highlighter-rouge">to∘from</code>, otherwise we would need to write <code class="highlighter-rouge">_≃_.to</code> and so on.</p>

<p>The above is our first use of records. A record declaration is equivalent
to a corresponding inductive data declaration:</p>
<pre class="Agda"><a id="4876" class="Keyword">data</a> <a id="_≃′_"></a><a id="4881" href="/Isomorphism/#4881" class="Datatype Operator">_≃′_</a> <a id="4886" class="Symbol">(</a><a id="4887" href="plfa.Isomorphism.html#4887" class="Bound">A</a> <a id="4889" href="plfa.Isomorphism.html#4889" class="Bound">B</a> <a id="4891" class="Symbol">:</a> <a id="4893" class="PrimitiveType">Set</a><a id="4896" class="Symbol">):</a> <a id="4899" class="PrimitiveType">Set</a> <a id="4903" class="Keyword">where</a>
  <a id="_≃′_.mk-≃′"></a><a id="4911" href="/Isomorphism/#4911" class="InductiveConstructor">mk-≃′</a> <a id="4917" class="Symbol">:</a> <a id="4919" class="Symbol">∀</a> <a id="4921" class="Symbol">(</a><a id="4922" href="plfa.Isomorphism.html#4922" class="Bound">to</a> <a id="4925" class="Symbol">:</a> <a id="4927" href="plfa.Isomorphism.html#4887" class="Bound">A</a> <a id="4929" class="Symbol">→</a> <a id="4931" href="plfa.Isomorphism.html#4889" class="Bound">B</a><a id="4932" class="Symbol">)</a> <a id="4934" class="Symbol">→</a>
          <a id="4946" class="Symbol">∀</a> <a id="4948" class="Symbol">(</a><a id="4949" href="/Isomorphism/#4949" class="Bound">from</a> <a id="4954" class="Symbol">:</a> <a id="4956" href="plfa.Isomorphism.html#4889" class="Bound">B</a> <a id="4958" class="Symbol">→</a> <a id="4960" href="plfa.Isomorphism.html#4887" class="Bound">A</a><a id="4961" class="Symbol">)</a> <a id="4963" class="Symbol">→</a>
          <a id="4975" class="Symbol">∀</a> <a id="4977" class="Symbol">(</a><a id="4978" href="/Isomorphism/#4978" class="Bound">from∘to</a> <a id="4986" class="Symbol">:</a> <a id="4988" class="Symbol">(∀</a> <a id="4991" class="Symbol">(</a><a id="4992" href="plfa.Isomorphism.html#4992" class="Bound">x</a> <a id="4994" class="Symbol">:</a> <a id="4996" href="plfa.Isomorphism.html#4887" class="Bound">A</a><a id="4997" class="Symbol">)</a> <a id="4999" class="Symbol">→</a> <a id="5001" href="plfa.Isomorphism.html#4949" class="Bound">from</a> <a id="5006" class="Symbol">(</a><a id="5007" href="plfa.Isomorphism.html#4922" class="Bound">to</a> <a id="5010" href="plfa.Isomorphism.html#4992" class="Bound">x</a><a id="5011" class="Symbol">)</a> <a id="5013" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="5015" href="plfa.Isomorphism.html#4992" class="Bound">x</a><a id="5016" class="Symbol">))</a> <a id="5019" class="Symbol">→</a>
          <a id="5031" class="Symbol">∀</a> <a id="5033" class="Symbol">(</a><a id="5034" href="/Isomorphism/#5034" class="Bound">to∘from</a> <a id="5042" class="Symbol">:</a> <a id="5044" class="Symbol">(∀</a> <a id="5047" class="Symbol">(</a><a id="5048" href="plfa.Isomorphism.html#5048" class="Bound">y</a> <a id="5050" class="Symbol">:</a> <a id="5052" href="plfa.Isomorphism.html#4889" class="Bound">B</a><a id="5053" class="Symbol">)</a> <a id="5055" class="Symbol">→</a> <a id="5057" href="plfa.Isomorphism.html#4922" class="Bound">to</a> <a id="5060" class="Symbol">(</a><a id="5061" href="plfa.Isomorphism.html#4949" class="Bound">from</a> <a id="5066" href="plfa.Isomorphism.html#5048" class="Bound">y</a><a id="5067" class="Symbol">)</a> <a id="5069" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="5071" href="plfa.Isomorphism.html#5048" class="Bound">y</a><a id="5072" class="Symbol">))</a> <a id="5075" class="Symbol">→</a>
          <a id="5087" href="/Isomorphism/#4887" class="Bound">A</a> <a id="5089" href="plfa.Isomorphism.html#4881" class="Datatype Operator">≃′</a> <a id="5092" href="plfa.Isomorphism.html#4889" class="Bound">B</a>

<a id="to′"></a><a id="5095" href="/Isomorphism/#5095" class="Function">to′</a> <a id="5099" class="Symbol">:</a> <a id="5101" class="Symbol">∀</a> <a id="5103" class="Symbol">{</a><a id="5104" href="plfa.Isomorphism.html#5104" class="Bound">A</a> <a id="5106" href="plfa.Isomorphism.html#5106" class="Bound">B</a> <a id="5108" class="Symbol">:</a> <a id="5110" class="PrimitiveType">Set</a><a id="5113" class="Symbol">}</a> <a id="5115" class="Symbol">→</a> <a id="5117" class="Symbol">(</a><a id="5118" href="plfa.Isomorphism.html#5104" class="Bound">A</a> <a id="5120" href="plfa.Isomorphism.html#4881" class="Datatype Operator">≃′</a> <a id="5123" href="plfa.Isomorphism.html#5106" class="Bound">B</a><a id="5124" class="Symbol">)</a> <a id="5126" class="Symbol">→</a> <a id="5128" class="Symbol">(</a><a id="5129" href="plfa.Isomorphism.html#5104" class="Bound">A</a> <a id="5131" class="Symbol">→</a> <a id="5133" href="plfa.Isomorphism.html#5106" class="Bound">B</a><a id="5134" class="Symbol">)</a>
<a id="5136" href="/Isomorphism/#5095" class="Function">to′</a> <a id="5140" class="Symbol">(</a><a id="5141" href="plfa.Isomorphism.html#4911" class="InductiveConstructor">mk-≃′</a> <a id="5147" href="plfa.Isomorphism.html#5147" class="Bound">f</a> <a id="5149" href="plfa.Isomorphism.html#5149" class="Bound">g</a> <a id="5151" href="plfa.Isomorphism.html#5151" class="Bound">g∘f</a> <a id="5155" href="plfa.Isomorphism.html#5155" class="Bound">f∘g</a><a id="5158" class="Symbol">)</a> <a id="5160" class="Symbol">=</a> <a id="5162" href="plfa.Isomorphism.html#5147" class="Bound">f</a>

<a id="from′"></a><a id="5165" href="/Isomorphism/#5165" class="Function">from′</a> <a id="5171" class="Symbol">:</a> <a id="5173" class="Symbol">∀</a> <a id="5175" class="Symbol">{</a><a id="5176" href="plfa.Isomorphism.html#5176" class="Bound">A</a> <a id="5178" href="plfa.Isomorphism.html#5178" class="Bound">B</a> <a id="5180" class="Symbol">:</a> <a id="5182" class="PrimitiveType">Set</a><a id="5185" class="Symbol">}</a> <a id="5187" class="Symbol">→</a> <a id="5189" class="Symbol">(</a><a id="5190" href="plfa.Isomorphism.html#5176" class="Bound">A</a> <a id="5192" href="plfa.Isomorphism.html#4881" class="Datatype Operator">≃′</a> <a id="5195" href="plfa.Isomorphism.html#5178" class="Bound">B</a><a id="5196" class="Symbol">)</a> <a id="5198" class="Symbol">→</a> <a id="5200" class="Symbol">(</a><a id="5201" href="plfa.Isomorphism.html#5178" class="Bound">B</a> <a id="5203" class="Symbol">→</a> <a id="5205" href="plfa.Isomorphism.html#5176" class="Bound">A</a><a id="5206" class="Symbol">)</a>
<a id="5208" href="/Isomorphism/#5165" class="Function">from′</a> <a id="5214" class="Symbol">(</a><a id="5215" href="plfa.Isomorphism.html#4911" class="InductiveConstructor">mk-≃′</a> <a id="5221" href="plfa.Isomorphism.html#5221" class="Bound">f</a> <a id="5223" href="plfa.Isomorphism.html#5223" class="Bound">g</a> <a id="5225" href="plfa.Isomorphism.html#5225" class="Bound">g∘f</a> <a id="5229" href="plfa.Isomorphism.html#5229" class="Bound">f∘g</a><a id="5232" class="Symbol">)</a> <a id="5234" class="Symbol">=</a> <a id="5236" href="plfa.Isomorphism.html#5223" class="Bound">g</a>

<a id="from∘to′"></a><a id="5239" href="/Isomorphism/#5239" class="Function">from∘to′</a> <a id="5248" class="Symbol">:</a> <a id="5250" class="Symbol">∀</a> <a id="5252" class="Symbol">{</a><a id="5253" href="plfa.Isomorphism.html#5253" class="Bound">A</a> <a id="5255" href="plfa.Isomorphism.html#5255" class="Bound">B</a> <a id="5257" class="Symbol">:</a> <a id="5259" class="PrimitiveType">Set</a><a id="5262" class="Symbol">}</a> <a id="5264" class="Symbol">→</a> <a id="5266" class="Symbol">(</a><a id="5267" href="plfa.Isomorphism.html#5267" class="Bound">A≃B</a> <a id="5271" class="Symbol">:</a> <a id="5273" href="plfa.Isomorphism.html#5253" class="Bound">A</a> <a id="5275" href="plfa.Isomorphism.html#4881" class="Datatype Operator">≃′</a> <a id="5278" href="plfa.Isomorphism.html#5255" class="Bound">B</a><a id="5279" class="Symbol">)</a> <a id="5281" class="Symbol">→</a> <a id="5283" class="Symbol">(∀</a> <a id="5286" class="Symbol">(</a><a id="5287" href="plfa.Isomorphism.html#5287" class="Bound">x</a> <a id="5289" class="Symbol">:</a> <a id="5291" href="plfa.Isomorphism.html#5253" class="Bound">A</a><a id="5292" class="Symbol">)</a> <a id="5294" class="Symbol">→</a> <a id="5296" href="plfa.Isomorphism.html#5165" class="Function">from′</a> <a id="5302" href="plfa.Isomorphism.html#5267" class="Bound">A≃B</a> <a id="5306" class="Symbol">(</a><a id="5307" href="plfa.Isomorphism.html#5095" class="Function">to′</a> <a id="5311" href="plfa.Isomorphism.html#5267" class="Bound">A≃B</a> <a id="5315" href="plfa.Isomorphism.html#5287" class="Bound">x</a><a id="5316" class="Symbol">)</a> <a id="5318" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="5320" href="plfa.Isomorphism.html#5287" class="Bound">x</a><a id="5321" class="Symbol">)</a>
<a id="5323" href="/Isomorphism/#5239" class="Function">from∘to′</a> <a id="5332" class="Symbol">(</a><a id="5333" href="plfa.Isomorphism.html#4911" class="InductiveConstructor">mk-≃′</a> <a id="5339" href="plfa.Isomorphism.html#5339" class="Bound">f</a> <a id="5341" href="plfa.Isomorphism.html#5341" class="Bound">g</a> <a id="5343" href="plfa.Isomorphism.html#5343" class="Bound">g∘f</a> <a id="5347" href="plfa.Isomorphism.html#5347" class="Bound">f∘g</a><a id="5350" class="Symbol">)</a> <a id="5352" class="Symbol">=</a> <a id="5354" href="plfa.Isomorphism.html#5343" class="Bound">g∘f</a>

<a id="to∘from′"></a><a id="5359" href="/Isomorphism/#5359" class="Function">to∘from′</a> <a id="5368" class="Symbol">:</a> <a id="5370" class="Symbol">∀</a> <a id="5372" class="Symbol">{</a><a id="5373" href="plfa.Isomorphism.html#5373" class="Bound">A</a> <a id="5375" href="plfa.Isomorphism.html#5375" class="Bound">B</a> <a id="5377" class="Symbol">:</a> <a id="5379" class="PrimitiveType">Set</a><a id="5382" class="Symbol">}</a> <a id="5384" class="Symbol">→</a> <a id="5386" class="Symbol">(</a><a id="5387" href="plfa.Isomorphism.html#5387" class="Bound">A≃B</a> <a id="5391" class="Symbol">:</a> <a id="5393" href="plfa.Isomorphism.html#5373" class="Bound">A</a> <a id="5395" href="plfa.Isomorphism.html#4881" class="Datatype Operator">≃′</a> <a id="5398" href="plfa.Isomorphism.html#5375" class="Bound">B</a><a id="5399" class="Symbol">)</a> <a id="5401" class="Symbol">→</a> <a id="5403" class="Symbol">(∀</a> <a id="5406" class="Symbol">(</a><a id="5407" href="plfa.Isomorphism.html#5407" class="Bound">y</a> <a id="5409" class="Symbol">:</a> <a id="5411" href="plfa.Isomorphism.html#5375" class="Bound">B</a><a id="5412" class="Symbol">)</a> <a id="5414" class="Symbol">→</a> <a id="5416" href="plfa.Isomorphism.html#5095" class="Function">to′</a> <a id="5420" href="plfa.Isomorphism.html#5387" class="Bound">A≃B</a> <a id="5424" class="Symbol">(</a><a id="5425" href="plfa.Isomorphism.html#5165" class="Function">from′</a> <a id="5431" href="plfa.Isomorphism.html#5387" class="Bound">A≃B</a> <a id="5435" href="plfa.Isomorphism.html#5407" class="Bound">y</a><a id="5436" class="Symbol">)</a> <a id="5438" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="5440" href="plfa.Isomorphism.html#5407" class="Bound">y</a><a id="5441" class="Symbol">)</a>
<a id="5443" href="/Isomorphism/#5359" class="Function">to∘from′</a> <a id="5452" class="Symbol">(</a><a id="5453" href="plfa.Isomorphism.html#4911" class="InductiveConstructor">mk-≃′</a> <a id="5459" href="plfa.Isomorphism.html#5459" class="Bound">f</a> <a id="5461" href="plfa.Isomorphism.html#5461" class="Bound">g</a> <a id="5463" href="plfa.Isomorphism.html#5463" class="Bound">g∘f</a> <a id="5467" href="plfa.Isomorphism.html#5467" class="Bound">f∘g</a><a id="5470" class="Symbol">)</a> <a id="5472" class="Symbol">=</a> <a id="5474" href="plfa.Isomorphism.html#5467" class="Bound">f∘g</a>
</pre>
<p>We construct values of the record type with the syntax</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>record
  { to    = f
  ; from  = g
  ; from∘to = g∘f
  ; to∘from = f∘g
  }
</code></pre></div></div>

<p>which corresponds to using the constructor of the corresponding
inductive type</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mk-≃′ f g g∘f f∘g
</code></pre></div></div>

<p>where <code class="highlighter-rouge">f</code>, <code class="highlighter-rouge">g</code>, <code class="highlighter-rouge">g∘f</code>, and <code class="highlighter-rouge">f∘g</code> are values of suitable types.</p>

<h2 id="isomorphism-is-an-equivalence">Isomorphism is an equivalence</h2>

<p>Isomorphism is an equivalence, meaning that it is reflexive, symmetric,
and transitive.  To show isomorphism is reflexive, we take both <code class="highlighter-rouge">to</code>
and <code class="highlighter-rouge">from</code> to be the identity function:</p>
<pre class="Agda"><a id="≃-refl"></a><a id="6026" href="/Isomorphism/#6026" class="Function">≃-refl</a> <a id="6033" class="Symbol">:</a> <a id="6035" class="Symbol">∀</a> <a id="6037" class="Symbol">{</a><a id="6038" href="plfa.Isomorphism.html#6038" class="Bound">A</a> <a id="6040" class="Symbol">:</a> <a id="6042" class="PrimitiveType">Set</a><a id="6045" class="Symbol">}</a>
    <a id="6051" class="Comment">-----</a>
  <a id="6059" class="Symbol">→</a> <a id="6061" href="/Isomorphism/#6038" class="Bound">A</a> <a id="6063" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="6065" href="plfa.Isomorphism.html#6038" class="Bound">A</a>
<a id="6067" href="/Isomorphism/#6026" class="Function">≃-refl</a> <a id="6074" class="Symbol">=</a>
  <a id="6078" class="Keyword">record</a>
    <a id="6089" class="Symbol">{</a> <a id="6091" href="/Isomorphism/#4025" class="Field">to</a>      <a id="6099" class="Symbol">=</a> <a id="6101" class="Symbol">λ{</a><a id="6103" href="plfa.Isomorphism.html#6103" class="Bound">x</a> <a id="6105" class="Symbol">→</a> <a id="6107" href="plfa.Isomorphism.html#6103" class="Bound">x</a><a id="6108" class="Symbol">}</a>
    <a id="6114" class="Symbol">;</a> <a id="6116" href="/Isomorphism/#4042" class="Field">from</a>    <a id="6124" class="Symbol">=</a> <a id="6126" class="Symbol">λ{</a><a id="6128" href="plfa.Isomorphism.html#6128" class="Bound">y</a> <a id="6130" class="Symbol">→</a> <a id="6132" href="plfa.Isomorphism.html#6128" class="Bound">y</a><a id="6133" class="Symbol">}</a>
    <a id="6139" class="Symbol">;</a> <a id="6141" href="/Isomorphism/#4059" class="Field">from∘to</a> <a id="6149" class="Symbol">=</a> <a id="6151" class="Symbol">λ{</a><a id="6153" href="plfa.Isomorphism.html#6153" class="Bound">x</a> <a id="6155" class="Symbol">→</a> <a id="6157" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="6161" class="Symbol">}</a>
    <a id="6167" class="Symbol">;</a> <a id="6169" href="/Isomorphism/#4101" class="Field">to∘from</a> <a id="6177" class="Symbol">=</a> <a id="6179" class="Symbol">λ{</a><a id="6181" href="plfa.Isomorphism.html#6181" class="Bound">y</a> <a id="6183" class="Symbol">→</a> <a id="6185" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="6189" class="Symbol">}</a>
    <a id="6195" class="Symbol">}</a>
</pre>
<p>In the above, <code class="highlighter-rouge">to</code> and <code class="highlighter-rouge">from</code> are both bound to identity functions,
and <code class="highlighter-rouge">from∘to</code> and <code class="highlighter-rouge">to∘from</code> are both bound to functions that discard
their argument and return <code class="highlighter-rouge">refl</code>.  In this case, <code class="highlighter-rouge">refl</code> alone is an
adequate proof since for the left inverse, <code class="highlighter-rouge">from (to x)</code>
simplifies to <code class="highlighter-rouge">x</code>, and similarly for the right inverse.</p>

<p>To show isomorphism is symmetric, we simply swap the roles of <code class="highlighter-rouge">to</code>
and <code class="highlighter-rouge">from</code>, and <code class="highlighter-rouge">from∘to</code> and <code class="highlighter-rouge">to∘from</code>:</p>
<pre class="Agda"><a id="≃-sym"></a><a id="6632" href="/Isomorphism/#6632" class="Function">≃-sym</a> <a id="6638" class="Symbol">:</a> <a id="6640" class="Symbol">∀</a> <a id="6642" class="Symbol">{</a><a id="6643" href="plfa.Isomorphism.html#6643" class="Bound">A</a> <a id="6645" href="plfa.Isomorphism.html#6645" class="Bound">B</a> <a id="6647" class="Symbol">:</a> <a id="6649" class="PrimitiveType">Set</a><a id="6652" class="Symbol">}</a>
  <a id="6656" class="Symbol">→</a> <a id="6658" href="/Isomorphism/#6643" class="Bound">A</a> <a id="6660" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="6662" href="plfa.Isomorphism.html#6645" class="Bound">B</a>
    <a id="6668" class="Comment">-----</a>
  <a id="6676" class="Symbol">→</a> <a id="6678" href="/Isomorphism/#6645" class="Bound">B</a> <a id="6680" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="6682" href="plfa.Isomorphism.html#6643" class="Bound">A</a>
<a id="6684" href="/Isomorphism/#6632" class="Function">≃-sym</a> <a id="6690" href="plfa.Isomorphism.html#6690" class="Bound">A≃B</a> <a id="6694" class="Symbol">=</a>
  <a id="6698" class="Keyword">record</a>
    <a id="6709" class="Symbol">{</a> <a id="6711" href="/Isomorphism/#4025" class="Field">to</a>      <a id="6719" class="Symbol">=</a> <a id="6721" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="6726" href="plfa.Isomorphism.html#6690" class="Bound">A≃B</a>
    <a id="6734" class="Symbol">;</a> <a id="6736" href="/Isomorphism/#4042" class="Field">from</a>    <a id="6744" class="Symbol">=</a> <a id="6746" href="plfa.Isomorphism.html#4025" class="Field">to</a>   <a id="6751" href="plfa.Isomorphism.html#6690" class="Bound">A≃B</a>
    <a id="6759" class="Symbol">;</a> <a id="6761" href="/Isomorphism/#4059" class="Field">from∘to</a> <a id="6769" class="Symbol">=</a> <a id="6771" href="plfa.Isomorphism.html#4101" class="Field">to∘from</a> <a id="6779" href="plfa.Isomorphism.html#6690" class="Bound">A≃B</a>
    <a id="6787" class="Symbol">;</a> <a id="6789" href="/Isomorphism/#4101" class="Field">to∘from</a> <a id="6797" class="Symbol">=</a> <a id="6799" href="plfa.Isomorphism.html#4059" class="Field">from∘to</a> <a id="6807" href="plfa.Isomorphism.html#6690" class="Bound">A≃B</a>
    <a id="6815" class="Symbol">}</a>
</pre>
<p>To show isomorphism is transitive, we compose the <code class="highlighter-rouge">to</code> and <code class="highlighter-rouge">from</code>
functions, and use equational reasoning to combine the inverses:</p>
<pre class="Agda"><a id="≃-trans"></a><a id="6957" href="/Isomorphism/#6957" class="Function">≃-trans</a> <a id="6965" class="Symbol">:</a> <a id="6967" class="Symbol">∀</a> <a id="6969" class="Symbol">{</a><a id="6970" href="plfa.Isomorphism.html#6970" class="Bound">A</a> <a id="6972" href="plfa.Isomorphism.html#6972" class="Bound">B</a> <a id="6974" href="plfa.Isomorphism.html#6974" class="Bound">C</a> <a id="6976" class="Symbol">:</a> <a id="6978" class="PrimitiveType">Set</a><a id="6981" class="Symbol">}</a>
  <a id="6985" class="Symbol">→</a> <a id="6987" href="/Isomorphism/#6970" class="Bound">A</a> <a id="6989" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="6991" href="plfa.Isomorphism.html#6972" class="Bound">B</a>
  <a id="6995" class="Symbol">→</a> <a id="6997" href="/Isomorphism/#6972" class="Bound">B</a> <a id="6999" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="7001" href="plfa.Isomorphism.html#6974" class="Bound">C</a>
    <a id="7007" class="Comment">-----</a>
  <a id="7015" class="Symbol">→</a> <a id="7017" href="/Isomorphism/#6970" class="Bound">A</a> <a id="7019" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="7021" href="plfa.Isomorphism.html#6974" class="Bound">C</a>
<a id="7023" href="/Isomorphism/#6957" class="Function">≃-trans</a> <a id="7031" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7035" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7039" class="Symbol">=</a>
  <a id="7043" class="Keyword">record</a>
    <a id="7054" class="Symbol">{</a> <a id="7056" href="/Isomorphism/#4025" class="Field">to</a>       <a id="7065" class="Symbol">=</a> <a id="7067" href="plfa.Isomorphism.html#4025" class="Field">to</a>   <a id="7072" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7076" href="plfa.Isomorphism.html#1946" class="Function Operator">∘</a> <a id="7078" href="plfa.Isomorphism.html#4025" class="Field">to</a>   <a id="7083" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a>
    <a id="7091" class="Symbol">;</a> <a id="7093" href="/Isomorphism/#4042" class="Field">from</a>     <a id="7102" class="Symbol">=</a> <a id="7104" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7109" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7113" href="plfa.Isomorphism.html#1946" class="Function Operator">∘</a> <a id="7115" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7120" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a>
    <a id="7128" class="Symbol">;</a> <a id="7130" href="/Isomorphism/#4059" class="Field">from∘to</a>  <a id="7139" class="Symbol">=</a> <a id="7141" class="Symbol">λ{</a><a id="7143" href="plfa.Isomorphism.html#7143" class="Bound">x</a> <a id="7145" class="Symbol">→</a>
        <a id="7155" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
          <a id="7171" class="Symbol">(</a><a id="7172" href="/Isomorphism/#4042" class="Field">from</a> <a id="7177" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7181" href="plfa.Isomorphism.html#1946" class="Function Operator">∘</a> <a id="7183" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7188" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a><a id="7191" class="Symbol">)</a> <a id="7193" class="Symbol">((</a><a id="7195" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="7198" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7202" href="plfa.Isomorphism.html#1946" class="Function Operator">∘</a> <a id="7204" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="7207" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a><a id="7210" class="Symbol">)</a> <a id="7212" href="plfa.Isomorphism.html#7143" class="Bound">x</a><a id="7213" class="Symbol">)</a>
        <a id="7223" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
          <a id="7237" href="/Isomorphism/#4042" class="Field">from</a> <a id="7242" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7246" class="Symbol">(</a><a id="7247" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7252" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7256" class="Symbol">(</a><a id="7257" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="7260" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7264" class="Symbol">(</a><a id="7265" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="7268" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7272" href="plfa.Isomorphism.html#7143" class="Bound">x</a><a id="7273" class="Symbol">)))</a>
        <a id="7285" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="7288" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="7293" class="Symbol">(</a><a id="7294" href="/Isomorphism/#4042" class="Field">from</a> <a id="7299" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a><a id="7302" class="Symbol">)</a> <a id="7304" class="Symbol">(</a><a id="7305" href="plfa.Isomorphism.html#4059" class="Field">from∘to</a> <a id="7313" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7317" class="Symbol">(</a><a id="7318" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="7321" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7325" href="plfa.Isomorphism.html#7143" class="Bound">x</a><a id="7326" class="Symbol">))</a> <a id="7329" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="7341" href="/Isomorphism/#4042" class="Field">from</a> <a id="7346" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7350" class="Symbol">(</a><a id="7351" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="7354" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7358" href="plfa.Isomorphism.html#7143" class="Bound">x</a><a id="7359" class="Symbol">)</a>
        <a id="7369" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="7372" href="/Isomorphism/#4059" class="Field">from∘to</a> <a id="7380" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7384" href="plfa.Isomorphism.html#7143" class="Bound">x</a> <a id="7386" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="7398" href="/Isomorphism/#7143" class="Bound">x</a>
        <a id="7408" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a><a id="7409" class="Symbol">}</a>
    <a id="7415" class="Symbol">;</a> <a id="7417" href="/Isomorphism/#4101" class="Field">to∘from</a> <a id="7425" class="Symbol">=</a> <a id="7427" class="Symbol">λ{</a><a id="7429" href="plfa.Isomorphism.html#7429" class="Bound">y</a> <a id="7431" class="Symbol">→</a>
        <a id="7441" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
          <a id="7457" class="Symbol">(</a><a id="7458" href="/Isomorphism/#4025" class="Field">to</a> <a id="7461" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7465" href="plfa.Isomorphism.html#1946" class="Function Operator">∘</a> <a id="7467" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="7470" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a><a id="7473" class="Symbol">)</a> <a id="7475" class="Symbol">((</a><a id="7477" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7482" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7486" href="plfa.Isomorphism.html#1946" class="Function Operator">∘</a> <a id="7488" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7493" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a><a id="7496" class="Symbol">)</a> <a id="7498" href="plfa.Isomorphism.html#7429" class="Bound">y</a><a id="7499" class="Symbol">)</a>
        <a id="7509" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
          <a id="7523" href="/Isomorphism/#4025" class="Field">to</a> <a id="7526" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7530" class="Symbol">(</a><a id="7531" href="plfa.Isomorphism.html#4025" class="Field">to</a> <a id="7534" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7538" class="Symbol">(</a><a id="7539" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7544" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7548" class="Symbol">(</a><a id="7549" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7554" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7558" href="plfa.Isomorphism.html#7429" class="Bound">y</a><a id="7559" class="Symbol">)))</a>
        <a id="7571" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="7574" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="7579" class="Symbol">(</a><a id="7580" href="/Isomorphism/#4025" class="Field">to</a> <a id="7583" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a><a id="7586" class="Symbol">)</a> <a id="7588" class="Symbol">(</a><a id="7589" href="plfa.Isomorphism.html#4101" class="Field">to∘from</a> <a id="7597" href="plfa.Isomorphism.html#7031" class="Bound">A≃B</a> <a id="7601" class="Symbol">(</a><a id="7602" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7607" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7611" href="plfa.Isomorphism.html#7429" class="Bound">y</a><a id="7612" class="Symbol">))</a> <a id="7615" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="7627" href="/Isomorphism/#4025" class="Field">to</a> <a id="7630" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7634" class="Symbol">(</a><a id="7635" href="plfa.Isomorphism.html#4042" class="Field">from</a> <a id="7640" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7644" href="plfa.Isomorphism.html#7429" class="Bound">y</a><a id="7645" class="Symbol">)</a>
        <a id="7655" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="7658" href="/Isomorphism/#4101" class="Field">to∘from</a> <a id="7666" href="plfa.Isomorphism.html#7035" class="Bound">B≃C</a> <a id="7670" href="plfa.Isomorphism.html#7429" class="Bound">y</a> <a id="7672" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="7684" href="/Isomorphism/#7429" class="Bound">y</a>
        <a id="7694" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a><a id="7695" class="Symbol">}</a>
     <a id="7702" class="Symbol">}</a>
</pre>

<h2 id="equational-reasoning-for-isomorphism">Equational reasoning for isomorphism</h2>

<p>It is straightforward to support a variant of equational reasoning for
isomorphism.  We essentially copy the previous definition
of equality for isomorphism.  We omit the form that corresponds to <code class="highlighter-rouge">_≡⟨⟩_</code>, since
trivial isomorphisms arise far less often than trivial equalities:</p>

<pre class="Agda"><a id="8034" class="Keyword">module</a> <a id="≃-Reasoning"></a><a id="8041" href="/Isomorphism/#8041" class="Module">≃-Reasoning</a> <a id="8053" class="Keyword">where</a>

  <a id="8062" class="Keyword">infix</a>  <a id="8069" class="Number">1</a> <a id="8071" href="/Isomorphism/#8117" class="Function Operator">≃-begin_</a>
  <a id="8082" class="Keyword">infixr</a> <a id="8089" class="Number">2</a> <a id="8091" href="/Isomorphism/#8201" class="Function Operator">_≃⟨_⟩_</a>
  <a id="8100" class="Keyword">infix</a>  <a id="8107" class="Number">3</a> <a id="8109" href="/Isomorphism/#8320" class="Function Operator">_≃-∎</a>

  <a id="≃-Reasoning.≃-begin_"></a><a id="8117" href="/Isomorphism/#8117" class="Function Operator">≃-begin_</a> <a id="8126" class="Symbol">:</a> <a id="8128" class="Symbol">∀</a> <a id="8130" class="Symbol">{</a><a id="8131" href="plfa.Isomorphism.html#8131" class="Bound">A</a> <a id="8133" href="plfa.Isomorphism.html#8133" class="Bound">B</a> <a id="8135" class="Symbol">:</a> <a id="8137" class="PrimitiveType">Set</a><a id="8140" class="Symbol">}</a>
    <a id="8146" class="Symbol">→</a> <a id="8148" href="/Isomorphism/#8131" class="Bound">A</a> <a id="8150" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="8152" href="plfa.Isomorphism.html#8133" class="Bound">B</a>
      <a id="8160" class="Comment">-----</a>
    <a id="8170" class="Symbol">→</a> <a id="8172" href="/Isomorphism/#8131" class="Bound">A</a> <a id="8174" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="8176" href="plfa.Isomorphism.html#8133" class="Bound">B</a>
  <a id="8180" href="/Isomorphism/#8117" class="Function Operator">≃-begin</a> <a id="8188" href="plfa.Isomorphism.html#8188" class="Bound">A≃B</a> <a id="8192" class="Symbol">=</a> <a id="8194" href="plfa.Isomorphism.html#8188" class="Bound">A≃B</a>

  <a id="≃-Reasoning._≃⟨_⟩_"></a><a id="8201" href="/Isomorphism/#8201" class="Function Operator">_≃⟨_⟩_</a> <a id="8208" class="Symbol">:</a> <a id="8210" class="Symbol">∀</a> <a id="8212" class="Symbol">(</a><a id="8213" href="plfa.Isomorphism.html#8213" class="Bound">A</a> <a id="8215" class="Symbol">:</a> <a id="8217" class="PrimitiveType">Set</a><a id="8220" class="Symbol">)</a> <a id="8222" class="Symbol">{</a><a id="8223" href="plfa.Isomorphism.html#8223" class="Bound">B</a> <a id="8225" href="plfa.Isomorphism.html#8225" class="Bound">C</a> <a id="8227" class="Symbol">:</a> <a id="8229" class="PrimitiveType">Set</a><a id="8232" class="Symbol">}</a>
    <a id="8238" class="Symbol">→</a> <a id="8240" href="/Isomorphism/#8213" class="Bound">A</a> <a id="8242" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="8244" href="plfa.Isomorphism.html#8223" class="Bound">B</a>
    <a id="8250" class="Symbol">→</a> <a id="8252" href="/Isomorphism/#8223" class="Bound">B</a> <a id="8254" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="8256" href="plfa.Isomorphism.html#8225" class="Bound">C</a>
      <a id="8264" class="Comment">-----</a>
    <a id="8274" class="Symbol">→</a> <a id="8276" href="/Isomorphism/#8213" class="Bound">A</a> <a id="8278" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="8280" href="plfa.Isomorphism.html#8225" class="Bound">C</a>
  <a id="8284" href="/Isomorphism/#8284" class="Bound">A</a> <a id="8286" href="plfa.Isomorphism.html#8201" class="Function Operator">≃⟨</a> <a id="8289" href="plfa.Isomorphism.html#8289" class="Bound">A≃B</a> <a id="8293" href="plfa.Isomorphism.html#8201" class="Function Operator">⟩</a> <a id="8295" href="plfa.Isomorphism.html#8295" class="Bound">B≃C</a> <a id="8299" class="Symbol">=</a> <a id="8301" href="plfa.Isomorphism.html#6957" class="Function">≃-trans</a> <a id="8309" href="plfa.Isomorphism.html#8289" class="Bound">A≃B</a> <a id="8313" href="plfa.Isomorphism.html#8295" class="Bound">B≃C</a>

  <a id="≃-Reasoning._≃-∎"></a><a id="8320" href="/Isomorphism/#8320" class="Function Operator">_≃-∎</a> <a id="8325" class="Symbol">:</a> <a id="8327" class="Symbol">∀</a> <a id="8329" class="Symbol">(</a><a id="8330" href="plfa.Isomorphism.html#8330" class="Bound">A</a> <a id="8332" class="Symbol">:</a> <a id="8334" class="PrimitiveType">Set</a><a id="8337" class="Symbol">)</a>
      <a id="8345" class="Comment">-----</a>
    <a id="8355" class="Symbol">→</a> <a id="8357" href="/Isomorphism/#8330" class="Bound">A</a> <a id="8359" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="8361" href="plfa.Isomorphism.html#8330" class="Bound">A</a>
  <a id="8365" href="/Isomorphism/#8365" class="Bound">A</a> <a id="8367" href="plfa.Isomorphism.html#8320" class="Function Operator">≃-∎</a> <a id="8371" class="Symbol">=</a> <a id="8373" href="plfa.Isomorphism.html#6026" class="Function">≃-refl</a>

<a id="8381" class="Keyword">open</a> <a id="8386" href="/Isomorphism/#8041" class="Module">≃-Reasoning</a>
</pre>

<h2 id="embedding">Embedding</h2>

<p>We also need the notion of <em>embedding</em>, which is a weakening of
isomorphism.  While an isomorphism shows that two types are in
one-to-one correspondence, an embedding shows that the first type is
included in the second; or, equivalently, that there is a many-to-one
correspondence between the second type and the first.</p>

<p>Here is the formal definition of embedding:</p>
<pre class="Agda"><a id="8787" class="Keyword">infix</a> <a id="8793" class="Number">0</a> <a id="8795" href="/Isomorphism/#8806" class="Record Operator">_≲_</a>
<a id="8799" class="Keyword">record</a> <a id="_≲_"></a><a id="8806" href="/Isomorphism/#8806" class="Record Operator">_≲_</a> <a id="8810" class="Symbol">(</a><a id="8811" href="plfa.Isomorphism.html#8811" class="Bound">A</a> <a id="8813" href="plfa.Isomorphism.html#8813" class="Bound">B</a> <a id="8815" class="Symbol">:</a> <a id="8817" class="PrimitiveType">Set</a><a id="8820" class="Symbol">)</a> <a id="8822" class="Symbol">:</a> <a id="8824" class="PrimitiveType">Set</a> <a id="8828" class="Keyword">where</a>
  <a id="8836" class="Keyword">field</a>
    <a id="_≲_.to"></a><a id="8846" href="/Isomorphism/#8846" class="Field">to</a>      <a id="8854" class="Symbol">:</a> <a id="8856" href="plfa.Isomorphism.html#8811" class="Bound">A</a> <a id="8858" class="Symbol">→</a> <a id="8860" href="plfa.Isomorphism.html#8813" class="Bound">B</a>
    <a id="_≲_.from"></a><a id="8866" href="/Isomorphism/#8866" class="Field">from</a>    <a id="8874" class="Symbol">:</a> <a id="8876" href="plfa.Isomorphism.html#8813" class="Bound">B</a> <a id="8878" class="Symbol">→</a> <a id="8880" href="plfa.Isomorphism.html#8811" class="Bound">A</a>
    <a id="_≲_.from∘to"></a><a id="8886" href="/Isomorphism/#8886" class="Field">from∘to</a> <a id="8894" class="Symbol">:</a> <a id="8896" class="Symbol">∀</a> <a id="8898" class="Symbol">(</a><a id="8899" href="plfa.Isomorphism.html#8899" class="Bound">x</a> <a id="8901" class="Symbol">:</a> <a id="8903" href="plfa.Isomorphism.html#8811" class="Bound">A</a><a id="8904" class="Symbol">)</a> <a id="8906" class="Symbol">→</a> <a id="8908" class="Field">from</a> <a id="8913" class="Symbol">(</a><a id="8914" class="Field">to</a> <a id="8917" href="plfa.Isomorphism.html#8899" class="Bound">x</a><a id="8918" class="Symbol">)</a> <a id="8920" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8922" href="plfa.Isomorphism.html#8899" class="Bound">x</a>
<a id="8924" class="Keyword">open</a> <a id="8929" href="/Isomorphism/#8806" class="Module Operator">_≲_</a>
</pre>
<p>It is the same as an isomorphism, save that it lacks the <code class="highlighter-rouge">to∘from</code> field.
Hence, we know that <code class="highlighter-rouge">from</code> is left-inverse to <code class="highlighter-rouge">to</code>, but not that <code class="highlighter-rouge">from</code>
is right-inverse to <code class="highlighter-rouge">to</code>.</p>

<p>Embedding is reflexive and transitive, but not symmetric.  The proofs
are cut down versions of the similar proofs for isomorphism:</p>
<pre class="Agda"><a id="≲-refl"></a><a id="9245" href="/Isomorphism/#9245" class="Function">≲-refl</a> <a id="9252" class="Symbol">:</a> <a id="9254" class="Symbol">∀</a> <a id="9256" class="Symbol">{</a><a id="9257" href="plfa.Isomorphism.html#9257" class="Bound">A</a> <a id="9259" class="Symbol">:</a> <a id="9261" class="PrimitiveType">Set</a><a id="9264" class="Symbol">}</a> <a id="9266" class="Symbol">→</a> <a id="9268" href="plfa.Isomorphism.html#9257" class="Bound">A</a> <a id="9270" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="9272" href="plfa.Isomorphism.html#9257" class="Bound">A</a>
<a id="9274" href="/Isomorphism/#9245" class="Function">≲-refl</a> <a id="9281" class="Symbol">=</a>
  <a id="9285" class="Keyword">record</a>
    <a id="9296" class="Symbol">{</a> <a id="9298" href="/Isomorphism/#8846" class="Field">to</a>      <a id="9306" class="Symbol">=</a> <a id="9308" class="Symbol">λ{</a><a id="9310" href="plfa.Isomorphism.html#9310" class="Bound">x</a> <a id="9312" class="Symbol">→</a> <a id="9314" href="plfa.Isomorphism.html#9310" class="Bound">x</a><a id="9315" class="Symbol">}</a>
    <a id="9321" class="Symbol">;</a> <a id="9323" href="/Isomorphism/#8866" class="Field">from</a>    <a id="9331" class="Symbol">=</a> <a id="9333" class="Symbol">λ{</a><a id="9335" href="plfa.Isomorphism.html#9335" class="Bound">y</a> <a id="9337" class="Symbol">→</a> <a id="9339" href="plfa.Isomorphism.html#9335" class="Bound">y</a><a id="9340" class="Symbol">}</a>
    <a id="9346" class="Symbol">;</a> <a id="9348" href="/Isomorphism/#8886" class="Field">from∘to</a> <a id="9356" class="Symbol">=</a> <a id="9358" class="Symbol">λ{</a><a id="9360" href="plfa.Isomorphism.html#9360" class="Bound">x</a> <a id="9362" class="Symbol">→</a> <a id="9364" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="9368" class="Symbol">}</a>
    <a id="9374" class="Symbol">}</a>

<a id="≲-trans"></a><a id="9377" href="/Isomorphism/#9377" class="Function">≲-trans</a> <a id="9385" class="Symbol">:</a> <a id="9387" class="Symbol">∀</a> <a id="9389" class="Symbol">{</a><a id="9390" href="plfa.Isomorphism.html#9390" class="Bound">A</a> <a id="9392" href="plfa.Isomorphism.html#9392" class="Bound">B</a> <a id="9394" href="plfa.Isomorphism.html#9394" class="Bound">C</a> <a id="9396" class="Symbol">:</a> <a id="9398" class="PrimitiveType">Set</a><a id="9401" class="Symbol">}</a> <a id="9403" class="Symbol">→</a> <a id="9405" href="plfa.Isomorphism.html#9390" class="Bound">A</a> <a id="9407" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="9409" href="plfa.Isomorphism.html#9392" class="Bound">B</a> <a id="9411" class="Symbol">→</a> <a id="9413" href="plfa.Isomorphism.html#9392" class="Bound">B</a> <a id="9415" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="9417" href="plfa.Isomorphism.html#9394" class="Bound">C</a> <a id="9419" class="Symbol">→</a> <a id="9421" href="plfa.Isomorphism.html#9390" class="Bound">A</a> <a id="9423" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="9425" href="plfa.Isomorphism.html#9394" class="Bound">C</a>
<a id="9427" href="/Isomorphism/#9377" class="Function">≲-trans</a> <a id="9435" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9439" href="plfa.Isomorphism.html#9439" class="Bound">B≲C</a> <a id="9443" class="Symbol">=</a>
  <a id="9447" class="Keyword">record</a>
    <a id="9458" class="Symbol">{</a> <a id="9460" href="/Isomorphism/#8846" class="Field">to</a>      <a id="9468" class="Symbol">=</a> <a id="9470" class="Symbol">λ{</a><a id="9472" href="plfa.Isomorphism.html#9472" class="Bound">x</a> <a id="9474" class="Symbol">→</a> <a id="9476" href="plfa.Isomorphism.html#8846" class="Field">to</a>   <a id="9481" href="plfa.Isomorphism.html#9439" class="Bound">B≲C</a> <a id="9485" class="Symbol">(</a><a id="9486" href="plfa.Isomorphism.html#8846" class="Field">to</a>   <a id="9491" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9495" href="plfa.Isomorphism.html#9472" class="Bound">x</a><a id="9496" class="Symbol">)}</a>
    <a id="9503" class="Symbol">;</a> <a id="9505" href="/Isomorphism/#8866" class="Field">from</a>    <a id="9513" class="Symbol">=</a> <a id="9515" class="Symbol">λ{</a><a id="9517" href="plfa.Isomorphism.html#9517" class="Bound">y</a> <a id="9519" class="Symbol">→</a> <a id="9521" href="plfa.Isomorphism.html#8866" class="Field">from</a> <a id="9526" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9530" class="Symbol">(</a><a id="9531" href="plfa.Isomorphism.html#8866" class="Field">from</a> <a id="9536" href="plfa.Isomorphism.html#9439" class="Bound">B≲C</a> <a id="9540" href="plfa.Isomorphism.html#9517" class="Bound">y</a><a id="9541" class="Symbol">)}</a>
    <a id="9548" class="Symbol">;</a> <a id="9550" href="/Isomorphism/#8886" class="Field">from∘to</a> <a id="9558" class="Symbol">=</a> <a id="9560" class="Symbol">λ{</a><a id="9562" href="plfa.Isomorphism.html#9562" class="Bound">x</a> <a id="9564" class="Symbol">→</a>
        <a id="9574" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
          <a id="9590" href="/Isomorphism/#8866" class="Field">from</a> <a id="9595" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9599" class="Symbol">(</a><a id="9600" href="plfa.Isomorphism.html#8866" class="Field">from</a> <a id="9605" href="plfa.Isomorphism.html#9439" class="Bound">B≲C</a> <a id="9609" class="Symbol">(</a><a id="9610" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="9613" href="plfa.Isomorphism.html#9439" class="Bound">B≲C</a> <a id="9617" class="Symbol">(</a><a id="9618" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="9621" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9625" href="plfa.Isomorphism.html#9562" class="Bound">x</a><a id="9626" class="Symbol">)))</a>
        <a id="9638" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="9641" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="9646" class="Symbol">(</a><a id="9647" href="/Isomorphism/#8866" class="Field">from</a> <a id="9652" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a><a id="9655" class="Symbol">)</a> <a id="9657" class="Symbol">(</a><a id="9658" href="plfa.Isomorphism.html#8886" class="Field">from∘to</a> <a id="9666" href="plfa.Isomorphism.html#9439" class="Bound">B≲C</a> <a id="9670" class="Symbol">(</a><a id="9671" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="9674" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9678" href="plfa.Isomorphism.html#9562" class="Bound">x</a><a id="9679" class="Symbol">))</a> <a id="9682" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="9694" href="/Isomorphism/#8866" class="Field">from</a> <a id="9699" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9703" class="Symbol">(</a><a id="9704" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="9707" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9711" href="plfa.Isomorphism.html#9562" class="Bound">x</a><a id="9712" class="Symbol">)</a>
        <a id="9722" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="9725" href="/Isomorphism/#8886" class="Field">from∘to</a> <a id="9733" href="plfa.Isomorphism.html#9435" class="Bound">A≲B</a> <a id="9737" href="plfa.Isomorphism.html#9562" class="Bound">x</a> <a id="9739" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="9751" href="/Isomorphism/#9562" class="Bound">x</a>
        <a id="9761" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a><a id="9762" class="Symbol">}</a>
     <a id="9769" class="Symbol">}</a>
</pre>
<p>It is also easy to see that if two types embed in each other, and the
embedding functions correspond, then they are isomorphic.  This is a
weak form of anti-symmetry:</p>
<pre class="Agda"><a id="≲-antisym"></a><a id="9947" href="/Isomorphism/#9947" class="Function">≲-antisym</a> <a id="9957" class="Symbol">:</a> <a id="9959" class="Symbol">∀</a> <a id="9961" class="Symbol">{</a><a id="9962" href="plfa.Isomorphism.html#9962" class="Bound">A</a> <a id="9964" href="plfa.Isomorphism.html#9964" class="Bound">B</a> <a id="9966" class="Symbol">:</a> <a id="9968" class="PrimitiveType">Set</a><a id="9971" class="Symbol">}</a>
  <a id="9975" class="Symbol">→</a> <a id="9977" class="Symbol">(</a><a id="9978" href="/Isomorphism/#9978" class="Bound">A≲B</a> <a id="9982" class="Symbol">:</a> <a id="9984" href="plfa.Isomorphism.html#9962" class="Bound">A</a> <a id="9986" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="9988" href="plfa.Isomorphism.html#9964" class="Bound">B</a><a id="9989" class="Symbol">)</a>
  <a id="9993" class="Symbol">→</a> <a id="9995" class="Symbol">(</a><a id="9996" href="/Isomorphism/#9996" class="Bound">B≲A</a> <a id="10000" class="Symbol">:</a> <a id="10002" href="plfa.Isomorphism.html#9964" class="Bound">B</a> <a id="10004" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="10006" href="plfa.Isomorphism.html#9962" class="Bound">A</a><a id="10007" class="Symbol">)</a>
  <a id="10011" class="Symbol">→</a> <a id="10013" class="Symbol">(</a><a id="10014" href="/Isomorphism/#8846" class="Field">to</a> <a id="10017" href="plfa.Isomorphism.html#9978" class="Bound">A≲B</a> <a id="10021" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10023" href="plfa.Isomorphism.html#8866" class="Field">from</a> <a id="10028" href="plfa.Isomorphism.html#9996" class="Bound">B≲A</a><a id="10031" class="Symbol">)</a>
  <a id="10035" class="Symbol">→</a> <a id="10037" class="Symbol">(</a><a id="10038" href="/Isomorphism/#8866" class="Field">from</a> <a id="10043" href="plfa.Isomorphism.html#9978" class="Bound">A≲B</a> <a id="10047" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10049" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="10052" href="plfa.Isomorphism.html#9996" class="Bound">B≲A</a><a id="10055" class="Symbol">)</a>
    <a id="10061" class="Comment">-------------------</a>
  <a id="10083" class="Symbol">→</a> <a id="10085" href="/Isomorphism/#9962" class="Bound">A</a> <a id="10087" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="10089" href="plfa.Isomorphism.html#9964" class="Bound">B</a>
<a id="10091" href="/Isomorphism/#9947" class="Function">≲-antisym</a> <a id="10101" href="plfa.Isomorphism.html#10101" class="Bound">A≲B</a> <a id="10105" href="plfa.Isomorphism.html#10105" class="Bound">B≲A</a> <a id="10109" href="plfa.Isomorphism.html#10109" class="Bound">to≡from</a> <a id="10117" href="plfa.Isomorphism.html#10117" class="Bound">from≡to</a> <a id="10125" class="Symbol">=</a>
  <a id="10129" class="Keyword">record</a>
    <a id="10140" class="Symbol">{</a> <a id="10142" href="/Isomorphism/#4025" class="Field">to</a>      <a id="10150" class="Symbol">=</a> <a id="10152" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="10155" href="plfa.Isomorphism.html#10101" class="Bound">A≲B</a>
    <a id="10163" class="Symbol">;</a> <a id="10165" href="/Isomorphism/#4042" class="Field">from</a>    <a id="10173" class="Symbol">=</a> <a id="10175" href="plfa.Isomorphism.html#8866" class="Field">from</a> <a id="10180" href="plfa.Isomorphism.html#10101" class="Bound">A≲B</a>
    <a id="10188" class="Symbol">;</a> <a id="10190" href="/Isomorphism/#4059" class="Field">from∘to</a> <a id="10198" class="Symbol">=</a> <a id="10200" href="plfa.Isomorphism.html#8886" class="Field">from∘to</a> <a id="10208" href="plfa.Isomorphism.html#10101" class="Bound">A≲B</a>
    <a id="10216" class="Symbol">;</a> <a id="10218" href="/Isomorphism/#4101" class="Field">to∘from</a> <a id="10226" class="Symbol">=</a> <a id="10228" class="Symbol">λ{</a><a id="10230" href="plfa.Isomorphism.html#10230" class="Bound">y</a> <a id="10232" class="Symbol">→</a>
        <a id="10242" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
          <a id="10258" href="/Isomorphism/#8846" class="Field">to</a> <a id="10261" href="plfa.Isomorphism.html#10101" class="Bound">A≲B</a> <a id="10265" class="Symbol">(</a><a id="10266" href="plfa.Isomorphism.html#8866" class="Field">from</a> <a id="10271" href="plfa.Isomorphism.html#10101" class="Bound">A≲B</a> <a id="10275" href="plfa.Isomorphism.html#10230" class="Bound">y</a><a id="10276" class="Symbol">)</a>
        <a id="10286" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="10289" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="10294" class="Symbol">(</a><a id="10295" href="/Isomorphism/#8846" class="Field">to</a> <a id="10298" href="plfa.Isomorphism.html#10101" class="Bound">A≲B</a><a id="10301" class="Symbol">)</a> <a id="10303" class="Symbol">(</a><a id="10304" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="10313" href="plfa.Isomorphism.html#10117" class="Bound">from≡to</a> <a id="10321" href="plfa.Isomorphism.html#10230" class="Bound">y</a><a id="10322" class="Symbol">)</a> <a id="10324" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="10336" href="/Isomorphism/#8846" class="Field">to</a> <a id="10339" href="plfa.Isomorphism.html#10101" class="Bound">A≲B</a> <a id="10343" class="Symbol">(</a><a id="10344" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="10347" href="plfa.Isomorphism.html#10105" class="Bound">B≲A</a> <a id="10351" href="plfa.Isomorphism.html#10230" class="Bound">y</a><a id="10352" class="Symbol">)</a>
        <a id="10362" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="10365" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="10374" href="/Isomorphism/#10109" class="Bound">to≡from</a> <a id="10382" class="Symbol">(</a><a id="10383" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="10386" href="plfa.Isomorphism.html#10105" class="Bound">B≲A</a> <a id="10390" href="plfa.Isomorphism.html#10230" class="Bound">y</a><a id="10391" class="Symbol">)</a> <a id="10393" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="10405" href="/Isomorphism/#8866" class="Field">from</a> <a id="10410" href="plfa.Isomorphism.html#10105" class="Bound">B≲A</a> <a id="10414" class="Symbol">(</a><a id="10415" href="plfa.Isomorphism.html#8846" class="Field">to</a> <a id="10418" href="plfa.Isomorphism.html#10105" class="Bound">B≲A</a> <a id="10422" href="plfa.Isomorphism.html#10230" class="Bound">y</a><a id="10423" class="Symbol">)</a>
        <a id="10433" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="10436" href="/Isomorphism/#8886" class="Field">from∘to</a> <a id="10444" href="plfa.Isomorphism.html#10105" class="Bound">B≲A</a> <a id="10448" href="plfa.Isomorphism.html#10230" class="Bound">y</a> <a id="10450" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
          <a id="10462" href="/Isomorphism/#10230" class="Bound">y</a>
        <a id="10472" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a><a id="10473" class="Symbol">}</a>
    <a id="10479" class="Symbol">}</a>
</pre>
<p>The first three components are copied from the embedding, while the
last combines the left inverse of <code class="highlighter-rouge">B ≲ A</code> with the equivalences of
the <code class="highlighter-rouge">to</code> and <code class="highlighter-rouge">from</code> components from the two embeddings to obtain
the right inverse of the isomorphism.</p>

<h2 id="equational-reasoning-for-embedding">Equational reasoning for embedding</h2>

<p>We can also support tabular reasoning for embedding,
analogous to that used for isomorphism:</p>

<pre class="Agda"><a id="10861" class="Keyword">module</a> <a id="≲-Reasoning"></a><a id="10868" href="/Isomorphism/#10868" class="Module">≲-Reasoning</a> <a id="10880" class="Keyword">where</a>

  <a id="10889" class="Keyword">infix</a>  <a id="10896" class="Number">1</a> <a id="10898" href="/Isomorphism/#10944" class="Function Operator">≲-begin_</a>
  <a id="10909" class="Keyword">infixr</a> <a id="10916" class="Number">2</a> <a id="10918" href="/Isomorphism/#11028" class="Function Operator">_≲⟨_⟩_</a>
  <a id="10927" class="Keyword">infix</a>  <a id="10934" class="Number">3</a> <a id="10936" href="/Isomorphism/#11147" class="Function Operator">_≲-∎</a>

  <a id="≲-Reasoning.≲-begin_"></a><a id="10944" href="/Isomorphism/#10944" class="Function Operator">≲-begin_</a> <a id="10953" class="Symbol">:</a> <a id="10955" class="Symbol">∀</a> <a id="10957" class="Symbol">{</a><a id="10958" href="plfa.Isomorphism.html#10958" class="Bound">A</a> <a id="10960" href="plfa.Isomorphism.html#10960" class="Bound">B</a> <a id="10962" class="Symbol">:</a> <a id="10964" class="PrimitiveType">Set</a><a id="10967" class="Symbol">}</a>
    <a id="10973" class="Symbol">→</a> <a id="10975" href="/Isomorphism/#10958" class="Bound">A</a> <a id="10977" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="10979" href="plfa.Isomorphism.html#10960" class="Bound">B</a>
      <a id="10987" class="Comment">-----</a>
    <a id="10997" class="Symbol">→</a> <a id="10999" href="/Isomorphism/#10958" class="Bound">A</a> <a id="11001" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="11003" href="plfa.Isomorphism.html#10960" class="Bound">B</a>
  <a id="11007" href="/Isomorphism/#10944" class="Function Operator">≲-begin</a> <a id="11015" href="plfa.Isomorphism.html#11015" class="Bound">A≲B</a> <a id="11019" class="Symbol">=</a> <a id="11021" href="plfa.Isomorphism.html#11015" class="Bound">A≲B</a>

  <a id="≲-Reasoning._≲⟨_⟩_"></a><a id="11028" href="/Isomorphism/#11028" class="Function Operator">_≲⟨_⟩_</a> <a id="11035" class="Symbol">:</a> <a id="11037" class="Symbol">∀</a> <a id="11039" class="Symbol">(</a><a id="11040" href="plfa.Isomorphism.html#11040" class="Bound">A</a> <a id="11042" class="Symbol">:</a> <a id="11044" class="PrimitiveType">Set</a><a id="11047" class="Symbol">)</a> <a id="11049" class="Symbol">{</a><a id="11050" href="plfa.Isomorphism.html#11050" class="Bound">B</a> <a id="11052" href="plfa.Isomorphism.html#11052" class="Bound">C</a> <a id="11054" class="Symbol">:</a> <a id="11056" class="PrimitiveType">Set</a><a id="11059" class="Symbol">}</a>
    <a id="11065" class="Symbol">→</a> <a id="11067" href="/Isomorphism/#11040" class="Bound">A</a> <a id="11069" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="11071" href="plfa.Isomorphism.html#11050" class="Bound">B</a>
    <a id="11077" class="Symbol">→</a> <a id="11079" href="/Isomorphism/#11050" class="Bound">B</a> <a id="11081" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="11083" href="plfa.Isomorphism.html#11052" class="Bound">C</a>
      <a id="11091" class="Comment">-----</a>
    <a id="11101" class="Symbol">→</a> <a id="11103" href="/Isomorphism/#11040" class="Bound">A</a> <a id="11105" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="11107" href="plfa.Isomorphism.html#11052" class="Bound">C</a>
  <a id="11111" href="/Isomorphism/#11111" class="Bound">A</a> <a id="11113" href="plfa.Isomorphism.html#11028" class="Function Operator">≲⟨</a> <a id="11116" href="plfa.Isomorphism.html#11116" class="Bound">A≲B</a> <a id="11120" href="plfa.Isomorphism.html#11028" class="Function Operator">⟩</a> <a id="11122" href="plfa.Isomorphism.html#11122" class="Bound">B≲C</a> <a id="11126" class="Symbol">=</a> <a id="11128" href="plfa.Isomorphism.html#9377" class="Function">≲-trans</a> <a id="11136" href="plfa.Isomorphism.html#11116" class="Bound">A≲B</a> <a id="11140" href="plfa.Isomorphism.html#11122" class="Bound">B≲C</a>

  <a id="≲-Reasoning._≲-∎"></a><a id="11147" href="/Isomorphism/#11147" class="Function Operator">_≲-∎</a> <a id="11152" class="Symbol">:</a> <a id="11154" class="Symbol">∀</a> <a id="11156" class="Symbol">(</a><a id="11157" href="plfa.Isomorphism.html#11157" class="Bound">A</a> <a id="11159" class="Symbol">:</a> <a id="11161" class="PrimitiveType">Set</a><a id="11164" class="Symbol">)</a>
      <a id="11172" class="Comment">-----</a>
    <a id="11182" class="Symbol">→</a> <a id="11184" href="/Isomorphism/#11157" class="Bound">A</a> <a id="11186" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="11188" href="plfa.Isomorphism.html#11157" class="Bound">A</a>
  <a id="11192" href="/Isomorphism/#11192" class="Bound">A</a> <a id="11194" href="plfa.Isomorphism.html#11147" class="Function Operator">≲-∎</a> <a id="11198" class="Symbol">=</a> <a id="11200" href="plfa.Isomorphism.html#9245" class="Function">≲-refl</a>

<a id="11208" class="Keyword">open</a> <a id="11213" href="/Isomorphism/#10868" class="Module">≲-Reasoning</a>
</pre>
<h4 id="exercise--implies-">Exercise <code class="highlighter-rouge">≃-implies-≲</code></h4>

<p>Show that every isomorphism implies an embedding.</p>
<pre class="Agda"><a id="11313" class="Keyword">postulate</a>
  <a id="≃-implies-≲"></a><a id="11325" href="/Isomorphism/#11325" class="Postulate">≃-implies-≲</a> <a id="11337" class="Symbol">:</a> <a id="11339" class="Symbol">∀</a> <a id="11341" class="Symbol">{</a><a id="11342" href="plfa.Isomorphism.html#11342" class="Bound">A</a> <a id="11344" href="plfa.Isomorphism.html#11344" class="Bound">B</a> <a id="11346" class="Symbol">:</a> <a id="11348" class="PrimitiveType">Set</a><a id="11351" class="Symbol">}</a>
    <a id="11357" class="Symbol">→</a> <a id="11359" href="/Isomorphism/#11342" class="Bound">A</a> <a id="11361" href="plfa.Isomorphism.html#3985" class="Record Operator">≃</a> <a id="11363" href="plfa.Isomorphism.html#11344" class="Bound">B</a>
      <a id="11371" class="Comment">-----</a>
    <a id="11381" class="Symbol">→</a> <a id="11383" href="/Isomorphism/#11342" class="Bound">A</a> <a id="11385" href="plfa.Isomorphism.html#8806" class="Record Operator">≲</a> <a id="11387" href="plfa.Isomorphism.html#11344" class="Bound">B</a>
</pre>
<pre class="Agda"><a id="11398" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="iff">Exercise <code class="highlighter-rouge">_⇔_</code></h4>

<p>Define equivalence of propositions (also known as “if and only if”) as follows:</p>
<pre class="Agda"><a id="11538" class="Keyword">record</a> <a id="_⇔_"></a><a id="11545" href="/Isomorphism/#11545" class="Record Operator">_⇔_</a> <a id="11549" class="Symbol">(</a><a id="11550" href="plfa.Isomorphism.html#11550" class="Bound">A</a> <a id="11552" href="plfa.Isomorphism.html#11552" class="Bound">B</a> <a id="11554" class="Symbol">:</a> <a id="11556" class="PrimitiveType">Set</a><a id="11559" class="Symbol">)</a> <a id="11561" class="Symbol">:</a> <a id="11563" class="PrimitiveType">Set</a> <a id="11567" class="Keyword">where</a>
  <a id="11575" class="Keyword">field</a>
    <a id="_⇔_.to"></a><a id="11585" href="/Isomorphism/#11585" class="Field">to</a>   <a id="11590" class="Symbol">:</a> <a id="11592" href="plfa.Isomorphism.html#11550" class="Bound">A</a> <a id="11594" class="Symbol">→</a> <a id="11596" href="plfa.Isomorphism.html#11552" class="Bound">B</a>
    <a id="_⇔_.from"></a><a id="11602" href="/Isomorphism/#11602" class="Field">from</a> <a id="11607" class="Symbol">:</a> <a id="11609" href="plfa.Isomorphism.html#11552" class="Bound">B</a> <a id="11611" class="Symbol">→</a> <a id="11613" href="plfa.Isomorphism.html#11550" class="Bound">A</a>
</pre>
<p>Show that equivalence is reflexive, symmetric, and transitive.</p>

<pre class="Agda"><a id="11687" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="Bin-embedding">Exercise <code class="highlighter-rouge">Bin-embedding</code> (stretch)</h4>

<p>Recall that Exercises
<a href="/Naturals/#Bin">Bin</a> and
<a href="/Induction/#Bin-laws">Bin-laws</a>
define a datatype of bitstrings representing natural numbers:</p>
<pre class="Agda"><a id="11956" class="Keyword">data</a> <a id="Bin"></a><a id="11961" href="/Isomorphism/#11961" class="Datatype">Bin</a> <a id="11965" class="Symbol">:</a> <a id="11967" class="PrimitiveType">Set</a> <a id="11971" class="Keyword">where</a>
  <a id="Bin.nil"></a><a id="11979" href="/Isomorphism/#11979" class="InductiveConstructor">nil</a> <a id="11983" class="Symbol">:</a> <a id="11985" href="plfa.Isomorphism.html#11961" class="Datatype">Bin</a>
  <a id="Bin.x0_"></a><a id="11991" href="/Isomorphism/#11991" class="InductiveConstructor Operator">x0_</a> <a id="11995" class="Symbol">:</a> <a id="11997" href="plfa.Isomorphism.html#11961" class="Datatype">Bin</a> <a id="12001" class="Symbol">→</a> <a id="12003" href="plfa.Isomorphism.html#11961" class="Datatype">Bin</a>
  <a id="Bin.x1_"></a><a id="12009" href="/Isomorphism/#12009" class="InductiveConstructor Operator">x1_</a> <a id="12013" class="Symbol">:</a> <a id="12015" href="plfa.Isomorphism.html#11961" class="Datatype">Bin</a> <a id="12019" class="Symbol">→</a> <a id="12021" href="plfa.Isomorphism.html#11961" class="Datatype">Bin</a>
</pre>
<p>And ask you to define the following functions</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>to : ℕ → Bin
from : Bin → ℕ
</code></pre></div></div>

<p>which satisfy the following property:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from (to n) ≡ n
</code></pre></div></div>

<p>Using the above, establish that there is an embedding of <code class="highlighter-rouge">ℕ</code> into <code class="highlighter-rouge">Bin</code>.</p>
<pre class="Agda"><a id="12250" class="Comment">-- Your code goes here</a>
</pre>
<p>Why do <code class="highlighter-rouge">to</code> and <code class="highlighter-rouge">from</code> not form an isomorphism?</p>

<h2 id="standard-library">Standard library</h2>

<p>Definitions similar to those in this chapter can be found in the standard library:</p>
<pre class="Agda"><a id="12435" class="Keyword">import</a> <a id="12442" href="https://agda.github.io/agda-stdlib/v1.1/Function.html" class="Module">Function</a> <a id="12451" class="Keyword">using</a> <a id="12457" class="Symbol">(</a><a id="12458" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">_∘_</a><a id="12461" class="Symbol">)</a>
<a id="12463" class="Keyword">import</a> <a id="12470" href="https://agda.github.io/agda-stdlib/v1.1/Function.Inverse.html" class="Module">Function.Inverse</a> <a id="12487" class="Keyword">using</a> <a id="12493" class="Symbol">(</a><a id="12494" href="https://agda.github.io/agda-stdlib/v1.1/Function.Inverse.html#2229" class="Function Operator">_↔_</a><a id="12497" class="Symbol">)</a>
<a id="12499" class="Keyword">import</a> <a id="12506" href="https://agda.github.io/agda-stdlib/v1.1/Function.LeftInverse.html" class="Module">Function.LeftInverse</a> <a id="12527" class="Keyword">using</a> <a id="12533" class="Symbol">(</a><a id="12534" href="https://agda.github.io/agda-stdlib/v1.1/Function.LeftInverse.html#2682" class="Function Operator">_↞_</a><a id="12537" class="Symbol">)</a>
</pre>
<p>The standard library <code class="highlighter-rouge">_↔_</code> and <code class="highlighter-rouge">_↞_</code> correspond to our <code class="highlighter-rouge">_≃_</code> and
<code class="highlighter-rouge">_≲_</code>, respectively, but those in the standard library are less
convenient, since they depend on a nested record structure and are
parameterised with regard to an arbitrary notion of equivalence.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∘  U+2218  RING OPERATOR (\o, \circ, \comp)
λ  U+03BB  GREEK SMALL LETTER LAMBDA (\lambda, \Gl)
≃  U+2243  ASYMPTOTICALLY EQUAL TO (\~-)
≲  U+2272  LESS-THAN OR EQUIVALENT TO (\&lt;~)
⇔  U+21D4  LEFT RIGHT DOUBLE ARROW (\&lt;=&gt;)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/Equality/">Prev</a>
    
    
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/Isomorphism.lagda.md">Source</a>
    
    
    &bullet;
    
    
    <a alt="Next chapter" href="/Connectives/">Next</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programming Language Foundations in Agda
</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/assets/jquery.js"></script>

<script type="text/javascript">

 // Makes sandwhich menu works
 $('.menu-icon').click(function(){
   $('.trigger').toggle();
 });

 // Script which allows for foldable code blocks
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
