<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Substitution in the untyped lambda calculus | Programming Language Foundations in Agda
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Substitution in the untyped lambda calculus" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Programming Language Foundations in Agda" />
<meta property="og:description" content="Programming Language Foundations in Agda" />
<link rel="canonical" href="https://plfa.github.io/Substitution/" />
<meta property="og:url" content="https://plfa.github.io/Substitution/" />
<meta property="og:site_name" content="Programming Language Foundations in Agda" />
<script type="application/ld+json">
{"description":"Programming Language Foundations in Agda","@type":"WebPage","url":"https://plfa.github.io/Substitution/","headline":"Substitution in the untyped lambda calculus","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/">Programming Language Foundations in Agda
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/">The Book</a>
                <a class="page-link" href="/Announcements/">Announcements</a>
                <a class="page-link" href="/GettingStarted/">Getting Started</a>
                <a class="page-link" href="/Citing/">Citing</a>
                <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Substitution in the untyped lambda calculus</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/Untyped/">Prev</a>
    
    
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/Substitution.lagda.md">Source</a>
    
    
    &bullet;
    
    
    <a alt="Next chapter" href="/LambdaReduction/">Next</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="169" class="Keyword">module</a> <a id="176" href="/Substitution/" class="Module">plfa.Substitution</a> <a id="194" class="Keyword">where</a>
</pre>
<h2 id="introduction">Introduction</h2>

<p>The primary purpose of this chapter is to prove that substitution
commutes with itself. Barendgredt (1984) refers to this
as the substitution lemma:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M [x:=N] [y:=L] = M [y:=L] [x:= N[y:=L] ]
</code></pre></div></div>

<p>In our setting, with de Bruijn indices for variables, the statement of
the lemma becomes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M [ N ] [ L ] ≡  M〔 L 〕[ N [ L ] ]                     (substitution)
</code></pre></div></div>

<p>where the notation <code class="highlighter-rouge">M 〔 L 〕</code> is for substituting L for index 1 inside
M.  In addition, because we define substitution in terms of parallel
substitution, we have the following generalization, replacing the
substitution of L with an arbitrary parallel substitution σ.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subst σ (M [ N ]) ≡ (subst (exts σ) M) [ subst σ N ]    (subst-commute)
</code></pre></div></div>

<p>The special case for renamings is also useful.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rename ρ (M [ N ]) ≡ (rename (ext ρ) M) [ rename ρ N ]
                                                 (rename-subst-commute)
</code></pre></div></div>

<p>The secondary purpose of this chapter is to define the σ algebra of
parallel substitution due to Abadi, Cardelli, Curien, and Levy
(1991). The equations of this algebra not only help us prove the
substitution lemma, but they are generally useful. Furthermore, when
the equations are applied from left to right, they form a rewrite
system that <em>decides</em> whether any two substitutions are equal.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="1524" class="Keyword">open</a> <a id="1529" class="Keyword">import</a> <a id="1536" href="/Untyped/" class="Module">plfa.Untyped</a>
  <a id="1551" class="Keyword">using</a> <a id="1557" class="Symbol">(</a><a id="1558" href="/Untyped/#2633" class="Datatype">Type</a><a id="1562" class="Symbol">;</a> <a id="1564" href="plfa.Untyped.html#2906" class="Datatype">Context</a><a id="1571" class="Symbol">;</a> <a id="1573" href="plfa.Untyped.html#4028" class="Datatype Operator">_⊢_</a><a id="1576" class="Symbol">;</a> <a id="1578" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="1579" class="Symbol">;</a> <a id="1581" href="plfa.Untyped.html#3259" class="Datatype Operator">_∋_</a><a id="1584" class="Symbol">;</a> <a id="1586" href="plfa.Untyped.html#2928" class="InductiveConstructor">∅</a><a id="1587" class="Symbol">;</a> <a id="1589" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">_,_</a><a id="1592" class="Symbol">;</a> <a id="1594" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="1595" class="Symbol">;</a> <a id="1597" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a><a id="1599" class="Symbol">;</a> <a id="1601" href="plfa.Untyped.html#4064" class="InductiveConstructor Operator">`_</a><a id="1603" class="Symbol">;</a> <a id="1605" href="plfa.Untyped.html#4116" class="InductiveConstructor Operator">ƛ_</a><a id="1607" class="Symbol">;</a> <a id="1609" href="plfa.Untyped.html#4176" class="InductiveConstructor Operator">_·_</a><a id="1612" class="Symbol">;</a>
         <a id="1623" href="/Untyped/#5969" class="Function">rename</a><a id="1629" class="Symbol">;</a> <a id="1631" href="plfa.Untyped.html#6697" class="Function">subst</a><a id="1636" class="Symbol">;</a> <a id="1638" href="plfa.Untyped.html#5659" class="Function">ext</a><a id="1641" class="Symbol">;</a> <a id="1643" href="plfa.Untyped.html#6405" class="Function">exts</a><a id="1647" class="Symbol">;</a> <a id="1649" href="plfa.Untyped.html#7225" class="Function Operator">_[_]</a><a id="1653" class="Symbol">;</a> <a id="1655" href="plfa.Untyped.html#7109" class="Function">subst-zero</a><a id="1665" class="Symbol">)</a>
<a id="1667" class="Keyword">import</a> <a id="1674" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1712" class="Symbol">as</a> <a id="1715" class="Module">Eq</a>
<a id="1718" class="Keyword">open</a> <a id="1723" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="1726" class="Keyword">using</a> <a id="1732" class="Symbol">(</a><a id="1733" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="1736" class="Symbol">;</a> <a id="1738" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1742" class="Symbol">;</a> <a id="1744" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a><a id="1747" class="Symbol">;</a> <a id="1749" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a><a id="1753" class="Symbol">;</a> <a id="1755" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1436" class="Function">cong₂</a><a id="1760" class="Symbol">;</a> <a id="1762" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a><a id="1770" class="Symbol">)</a>
<a id="1772" class="Keyword">open</a> <a id="1777" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2499" class="Module">Eq.≡-Reasoning</a> <a id="1792" class="Keyword">using</a> <a id="1798" class="Symbol">(</a><a id="1799" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin_</a><a id="1805" class="Symbol">;</a> <a id="1807" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">_≡⟨⟩_</a><a id="1812" class="Symbol">;</a> <a id="1814" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">_≡⟨_⟩_</a><a id="1820" class="Symbol">;</a> <a id="1822" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">_∎</a><a id="1824" class="Symbol">)</a>
<a id="1826" class="Keyword">open</a> <a id="1831" class="Keyword">import</a> <a id="1838" href="https://agda.github.io/agda-stdlib/v1.1/Function.html" class="Module">Function</a> <a id="1847" class="Keyword">using</a> <a id="1853" class="Symbol">(</a><a id="1854" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">_∘_</a><a id="1857" class="Symbol">)</a>
<a id="1859" class="Comment">-- open import plfa.Isomorphism using (extensionality)  -- causes a bug!</a>
</pre>
<pre class="Agda"><a id="1941" class="Keyword">postulate</a>
  <a id="extensionality"></a><a id="1953" href="/Substitution/#1953" class="Postulate">extensionality</a> <a id="1968" class="Symbol">:</a> <a id="1970" class="Symbol">∀</a> <a id="1972" class="Symbol">{</a><a id="1973" href="plfa.Substitution.html#1973" class="Bound">A</a> <a id="1975" href="plfa.Substitution.html#1975" class="Bound">B</a> <a id="1977" class="Symbol">:</a> <a id="1979" class="PrimitiveType">Set</a><a id="1982" class="Symbol">}</a> <a id="1984" class="Symbol">{</a><a id="1985" href="plfa.Substitution.html#1985" class="Bound">f</a> <a id="1987" href="plfa.Substitution.html#1987" class="Bound">g</a> <a id="1989" class="Symbol">:</a> <a id="1991" href="plfa.Substitution.html#1973" class="Bound">A</a> <a id="1993" class="Symbol">→</a> <a id="1995" href="plfa.Substitution.html#1975" class="Bound">B</a><a id="1996" class="Symbol">}</a>
    <a id="2002" class="Symbol">→</a> <a id="2004" class="Symbol">(∀</a> <a id="2007" class="Symbol">(</a><a id="2008" href="/Substitution/#2008" class="Bound">x</a> <a id="2010" class="Symbol">:</a> <a id="2012" href="plfa.Substitution.html#1973" class="Bound">A</a><a id="2013" class="Symbol">)</a> <a id="2015" class="Symbol">→</a> <a id="2017" href="plfa.Substitution.html#1985" class="Bound">f</a> <a id="2019" href="plfa.Substitution.html#2008" class="Bound">x</a> <a id="2021" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="2023" href="plfa.Substitution.html#1987" class="Bound">g</a> <a id="2025" href="plfa.Substitution.html#2008" class="Bound">x</a><a id="2026" class="Symbol">)</a>
      <a id="2034" class="Comment">-----------------------</a>
    <a id="2062" class="Symbol">→</a> <a id="2064" href="/Substitution/#1985" class="Bound">f</a> <a id="2066" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="2068" href="plfa.Substitution.html#1987" class="Bound">g</a>
</pre>
<h2 id="notation">Notation</h2>

<p>We introduce the following shorthand for the type of a <em>renaming</em> from
variables in context <code class="highlighter-rouge">Γ</code> to variables in context <code class="highlighter-rouge">Δ</code>.</p>

<pre class="Agda"><a id="Rename"></a><a id="2218" href="/Substitution/#2218" class="Function">Rename</a> <a id="2225" class="Symbol">:</a> <a id="2227" href="/Untyped/#2906" class="Datatype">Context</a> <a id="2235" class="Symbol">→</a> <a id="2237" href="plfa.Untyped.html#2906" class="Datatype">Context</a> <a id="2245" class="Symbol">→</a> <a id="2247" class="PrimitiveType">Set</a>
<a id="2251" href="/Substitution/#2218" class="Function">Rename</a> <a id="2258" href="plfa.Substitution.html#2258" class="Bound">Γ</a> <a id="2260" href="plfa.Substitution.html#2260" class="Bound">Δ</a> <a id="2262" class="Symbol">=</a> <a id="2264" class="Symbol">∀{</a><a id="2266" href="plfa.Substitution.html#2266" class="Bound">A</a><a id="2267" class="Symbol">}</a> <a id="2269" class="Symbol">→</a> <a id="2271" href="plfa.Substitution.html#2258" class="Bound">Γ</a> <a id="2273" href="/Untyped/#3259" class="Datatype Operator">∋</a> <a id="2275" href="plfa.Substitution.html#2266" class="Bound">A</a> <a id="2277" class="Symbol">→</a> <a id="2279" href="plfa.Substitution.html#2260" class="Bound">Δ</a> <a id="2281" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="2283" href="plfa.Substitution.html#2266" class="Bound">A</a>
</pre>
<p>Similarly, we introduce the following shorthand for the type of a
<em>substitution</em> from variables in context <code class="highlighter-rouge">Γ</code> to terms in context <code class="highlighter-rouge">Δ</code>.</p>

<pre class="Agda"><a id="Subst"></a><a id="2431" href="/Substitution/#2431" class="Function">Subst</a> <a id="2437" class="Symbol">:</a> <a id="2439" href="/Untyped/#2906" class="Datatype">Context</a> <a id="2447" class="Symbol">→</a> <a id="2449" href="plfa.Untyped.html#2906" class="Datatype">Context</a> <a id="2457" class="Symbol">→</a> <a id="2459" class="PrimitiveType">Set</a>
<a id="2463" href="/Substitution/#2431" class="Function">Subst</a> <a id="2469" href="plfa.Substitution.html#2469" class="Bound">Γ</a> <a id="2471" href="plfa.Substitution.html#2471" class="Bound">Δ</a> <a id="2473" class="Symbol">=</a> <a id="2475" class="Symbol">∀{</a><a id="2477" href="plfa.Substitution.html#2477" class="Bound">A</a><a id="2478" class="Symbol">}</a> <a id="2480" class="Symbol">→</a> <a id="2482" href="plfa.Substitution.html#2469" class="Bound">Γ</a> <a id="2484" href="/Untyped/#3259" class="Datatype Operator">∋</a> <a id="2486" href="plfa.Substitution.html#2477" class="Bound">A</a> <a id="2488" class="Symbol">→</a> <a id="2490" href="plfa.Substitution.html#2471" class="Bound">Δ</a> <a id="2492" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="2494" href="plfa.Substitution.html#2477" class="Bound">A</a>
</pre>
<p>We use the following more succinct notation the <code class="highlighter-rouge">subst</code> function.</p>

<pre class="Agda"><a id="⟪_⟫"></a><a id="2572" href="/Substitution/#2572" class="Function Operator">⟪_⟫</a> <a id="2576" class="Symbol">:</a> <a id="2578" class="Symbol">∀{</a><a id="2580" href="plfa.Substitution.html#2580" class="Bound">Γ</a> <a id="2582" href="plfa.Substitution.html#2582" class="Bound">Δ</a> <a id="2584" href="plfa.Substitution.html#2584" class="Bound">A</a><a id="2585" class="Symbol">}</a> <a id="2587" class="Symbol">→</a> <a id="2589" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="2595" href="plfa.Substitution.html#2580" class="Bound">Γ</a> <a id="2597" href="plfa.Substitution.html#2582" class="Bound">Δ</a> <a id="2599" class="Symbol">→</a> <a id="2601" href="plfa.Substitution.html#2580" class="Bound">Γ</a> <a id="2603" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="2605" href="plfa.Substitution.html#2584" class="Bound">A</a> <a id="2607" class="Symbol">→</a> <a id="2609" href="plfa.Substitution.html#2582" class="Bound">Δ</a> <a id="2611" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="2613" href="plfa.Substitution.html#2584" class="Bound">A</a>
<a id="2615" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="2617" href="plfa.Substitution.html#2617" class="Bound">σ</a> <a id="2619" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="2621" class="Symbol">=</a> <a id="2623" class="Symbol">λ</a> <a id="2625" href="plfa.Substitution.html#2625" class="Bound">M</a> <a id="2627" class="Symbol">→</a> <a id="2629" href="/Untyped/#6697" class="Function">subst</a> <a id="2635" href="plfa.Substitution.html#2617" class="Bound">σ</a> <a id="2637" href="plfa.Substitution.html#2625" class="Bound">M</a>
</pre>

<h2 id="the-σ-algebra-of-substitution">The σ algebra of substitution</h2>

<p>Substitutions map de Bruijn indices (natural numbers) to terms, so we
can view a substitution simply as a sequence of terms, or more
precisely, as an infinite sequence of terms. The σ algebra consists of
four operations for building such sequences: identity <code class="highlighter-rouge">ids</code>, shift
<code class="highlighter-rouge">↑</code>, cons <code class="highlighter-rouge">M • σ</code>, and sequencing <code class="highlighter-rouge">σ ⨟ τ</code>.  The sequence <code class="highlighter-rouge">0, 1, 2, ...</code>
is constructed by the identity substitution.</p>

<pre class="Agda"><a id="ids"></a><a id="3072" href="/Substitution/#3072" class="Function">ids</a> <a id="3076" class="Symbol">:</a> <a id="3078" class="Symbol">∀{</a><a id="3080" href="plfa.Substitution.html#3080" class="Bound">Γ</a><a id="3081" class="Symbol">}</a> <a id="3083" class="Symbol">→</a> <a id="3085" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="3091" href="plfa.Substitution.html#3080" class="Bound">Γ</a> <a id="3093" href="plfa.Substitution.html#3080" class="Bound">Γ</a>
<a id="3095" href="/Substitution/#3072" class="Function">ids</a> <a id="3099" href="plfa.Substitution.html#3099" class="Bound">x</a> <a id="3101" class="Symbol">=</a> <a id="3103" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="3105" href="plfa.Substitution.html#3099" class="Bound">x</a>
</pre>
<p>The shift operation <code class="highlighter-rouge">↑</code> constructs the sequence</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1, 2, 3, ...
</code></pre></div></div>

<p>and is defined as follows.</p>

<pre class="Agda"><a id="↑"></a><a id="3211" href="/Substitution/#3211" class="Function">↑</a> <a id="3213" class="Symbol">:</a> <a id="3215" class="Symbol">∀{</a><a id="3217" href="plfa.Substitution.html#3217" class="Bound">Γ</a> <a id="3219" href="plfa.Substitution.html#3219" class="Bound">A</a><a id="3220" class="Symbol">}</a> <a id="3222" class="Symbol">→</a> <a id="3224" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="3230" href="plfa.Substitution.html#3217" class="Bound">Γ</a> <a id="3232" class="Symbol">(</a><a id="3233" href="plfa.Substitution.html#3217" class="Bound">Γ</a> <a id="3235" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="3237" href="plfa.Substitution.html#3219" class="Bound">A</a><a id="3238" class="Symbol">)</a>
<a id="3240" href="/Substitution/#3211" class="Function">↑</a> <a id="3242" href="plfa.Substitution.html#3242" class="Bound">x</a> <a id="3244" class="Symbol">=</a> <a id="3246" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="3248" class="Symbol">(</a><a id="3249" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S</a> <a id="3251" href="plfa.Substitution.html#3242" class="Bound">x</a><a id="3252" class="Symbol">)</a>
</pre>
<p>Given a term <code class="highlighter-rouge">M</code> and substitution <code class="highlighter-rouge">σ</code>, the operation
<code class="highlighter-rouge">M • σ</code> constructs the sequence</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M , σ 0, σ 1, σ 2, ...
</code></pre></div></div>

<p>This operation is analogous to the <code class="highlighter-rouge">cons</code> operation of Lisp.</p>

<pre class="Agda"><a id="3439" class="Keyword">infixr</a> <a id="3446" class="Number">6</a> <a id="3448" href="/Substitution/#3453" class="Function Operator">_•_</a>

<a id="_•_"></a><a id="3453" href="/Substitution/#3453" class="Function Operator">_•_</a> <a id="3457" class="Symbol">:</a> <a id="3459" class="Symbol">∀{</a><a id="3461" href="plfa.Substitution.html#3461" class="Bound">Γ</a> <a id="3463" href="plfa.Substitution.html#3463" class="Bound">Δ</a> <a id="3465" href="plfa.Substitution.html#3465" class="Bound">A</a><a id="3466" class="Symbol">}</a> <a id="3468" class="Symbol">→</a> <a id="3470" class="Symbol">(</a><a id="3471" href="plfa.Substitution.html#3463" class="Bound">Δ</a> <a id="3473" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="3475" href="plfa.Substitution.html#3465" class="Bound">A</a><a id="3476" class="Symbol">)</a> <a id="3478" class="Symbol">→</a> <a id="3480" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="3486" href="plfa.Substitution.html#3461" class="Bound">Γ</a> <a id="3488" href="plfa.Substitution.html#3463" class="Bound">Δ</a> <a id="3490" class="Symbol">→</a> <a id="3492" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="3498" class="Symbol">(</a><a id="3499" href="plfa.Substitution.html#3461" class="Bound">Γ</a> <a id="3501" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="3503" href="plfa.Substitution.html#3465" class="Bound">A</a><a id="3504" class="Symbol">)</a> <a id="3506" href="plfa.Substitution.html#3463" class="Bound">Δ</a>
<a id="3508" class="Symbol">(</a><a id="3509" href="/Substitution/#3509" class="Bound">M</a> <a id="3511" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="3513" href="plfa.Substitution.html#3513" class="Bound">σ</a><a id="3514" class="Symbol">)</a> <a id="3516" href="/Untyped/#3295" class="InductiveConstructor">Z</a> <a id="3518" class="Symbol">=</a> <a id="3520" href="plfa.Substitution.html#3509" class="Bound">M</a>
<a id="3522" class="Symbol">(</a><a id="3523" href="/Substitution/#3523" class="Bound">M</a> <a id="3525" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="3527" href="plfa.Substitution.html#3527" class="Bound">σ</a><a id="3528" class="Symbol">)</a> <a id="3530" class="Symbol">(</a><a id="3531" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="3533" href="plfa.Substitution.html#3533" class="Bound">x</a><a id="3534" class="Symbol">)</a> <a id="3536" class="Symbol">=</a> <a id="3538" href="plfa.Substitution.html#3527" class="Bound">σ</a> <a id="3540" href="plfa.Substitution.html#3533" class="Bound">x</a>
</pre>
<p>Given two substitutions <code class="highlighter-rouge">σ</code> and <code class="highlighter-rouge">τ</code>, the sequencing operation <code class="highlighter-rouge">σ ⨟ τ</code>
produces the sequence</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟪τ⟫(σ 0), ⟪τ⟫(σ 1), ⟪τ⟫(σ 2), ...
</code></pre></div></div>

<p>That is, it composes the two substitutions by first applying
<code class="highlighter-rouge">σ</code> and then applying <code class="highlighter-rouge">τ</code>.</p>

<pre class="Agda"><a id="3772" class="Keyword">infixr</a> <a id="3779" class="Number">5</a> <a id="3781" href="/Substitution/#3786" class="Function Operator">_⨟_</a>

<a id="_⨟_"></a><a id="3786" href="/Substitution/#3786" class="Function Operator">_⨟_</a> <a id="3790" class="Symbol">:</a> <a id="3792" class="Symbol">∀{</a><a id="3794" href="plfa.Substitution.html#3794" class="Bound">Γ</a> <a id="3796" href="plfa.Substitution.html#3796" class="Bound">Δ</a> <a id="3798" href="plfa.Substitution.html#3798" class="Bound">Σ</a><a id="3799" class="Symbol">}</a> <a id="3801" class="Symbol">→</a> <a id="3803" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="3809" href="plfa.Substitution.html#3794" class="Bound">Γ</a> <a id="3811" href="plfa.Substitution.html#3796" class="Bound">Δ</a> <a id="3813" class="Symbol">→</a> <a id="3815" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="3821" href="plfa.Substitution.html#3796" class="Bound">Δ</a> <a id="3823" href="plfa.Substitution.html#3798" class="Bound">Σ</a> <a id="3825" class="Symbol">→</a> <a id="3827" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="3833" href="plfa.Substitution.html#3794" class="Bound">Γ</a> <a id="3835" href="plfa.Substitution.html#3798" class="Bound">Σ</a>
<a id="3837" href="/Substitution/#3837" class="Bound">σ</a> <a id="3839" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="3841" href="plfa.Substitution.html#3841" class="Bound">τ</a> <a id="3843" class="Symbol">=</a> <a id="3845" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="3847" href="plfa.Substitution.html#3841" class="Bound">τ</a> <a id="3849" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="3851" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="3853" href="plfa.Substitution.html#3837" class="Bound">σ</a>
</pre>
<p>For the sequencing operation, Abadi et al. use the notation of
function composition, writing <code class="highlighter-rouge">σ ∘ τ</code>, but still with <code class="highlighter-rouge">σ</code> applied
before <code class="highlighter-rouge">τ</code>, which is the opposite of standard mathematical
practice. We instead write <code class="highlighter-rouge">σ ⨟ τ</code>, because semicolon is
the standard notation for forward function composition.</p>

<h2 id="the-σ-algebra-equations">The σ algebra equations</h2>

<p>The σ algebra includes the following equations.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(sub-head)  ⟪ M • σ ⟫ (` Z) ≡ M
(sub-tail)  ↑ ⨟ (M • σ)    ≡ σ
(sub-η)     (⟪ σ ⟫ (` Z)) • (↑ ⨟ σ) ≡ σ
(Z-shift)   (` Z) • ↑      ≡ ids

(sub-id)    ⟪ ids ⟫ M      ≡ M
(sub-app)   ⟪ σ ⟫ (L · M)  ≡ (⟪ σ ⟫ L) · (⟪ σ ⟫ M)
(sub-abs)   ⟪ σ ⟫ (ƛ N)    ≡ ƛ ⟪ σ ⟫ N
(sub-sub)   ⟪ τ ⟫ ⟪ σ ⟫ M  ≡ ⟪ σ ⨟ τ ⟫ M

(sub-idL)   ids ⨟ σ        ≡ σ
(sub-idR)   σ ⨟ ids        ≡ σ
(sub-assoc) (σ ⨟ τ) ⨟ θ    ≡ σ ⨟ (τ ⨟ θ)
(sub-dist)  (M • σ) ⨟ τ    ≡ (⟪ τ ⟫ M) • (σ ⨟ τ)
</code></pre></div></div>

<p>The first group of equations describe how the <code class="highlighter-rouge">•</code> operator acts like cons.
The equation <code class="highlighter-rouge">sub-head</code> says that the variable zero <code class="highlighter-rouge">Z</code> returns the
head of the sequence (it acts like the <code class="highlighter-rouge">car</code> of Lisp).  Similarly,
<code class="highlighter-rouge">sub-tail</code> says that sequencing with shift <code class="highlighter-rouge">↑</code> returns the tail of the
sequence (it acts like <code class="highlighter-rouge">cdr</code> of Lisp).  The <code class="highlighter-rouge">sub-η</code> equation is the
η-expansion rule for sequences, saying that taking the head and tail
of a sequence, and then cons’ing them together yields the original
sequence. The <code class="highlighter-rouge">Z-shift</code> equation says that cons’ing zero onto the
shifted sequence produces the identity sequence.</p>

<p>The next four equations involve applying substitutions to terms.  The
equation <code class="highlighter-rouge">sub-id</code> says that the identity substitution returns the term
unchanged. The equations <code class="highlighter-rouge">sub-app</code> and <code class="highlighter-rouge">sub-abs</code> says that
substitution is a congruence for the lambda calculus. The <code class="highlighter-rouge">sub-sub</code>
equation says that the sequence operator <code class="highlighter-rouge">⨟</code> behaves as intended.</p>

<p>The last four equations concern the sequencing of substitutions.
The first two equations, <code class="highlighter-rouge">sub-idL</code> and <code class="highlighter-rouge">sub-idR</code>, say that
<code class="highlighter-rouge">ids</code> is the left and right unit of the sequencing operator.
The <code class="highlighter-rouge">sub-assoc</code> equation says that sequencing is associative.
Finally, <code class="highlighter-rouge">sub-dist</code> says that post-sequencing distributes through cons.</p>

<h2 id="relating-the-σ-algebra-and-substitution-functions">Relating the σ algebra and substitution functions</h2>

<p>The definitions of substitution <code class="highlighter-rouge">N [ M ]</code> and parallel substitution
<code class="highlighter-rouge">subst σ N</code> depend on several auxiliary functions: <code class="highlighter-rouge">rename</code>, <code class="highlighter-rouge">exts</code>,
<code class="highlighter-rouge">ext</code>, and <code class="highlighter-rouge">subst-zero</code>. We shall relate those functions to terms in
the σ algebra.</p>

<p>To begin with, renaming can be expressed in terms of substitution.
We have</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rename ρ M ≡ ⟪ ren ρ ⟫ M               (rename-subst-ren)
</code></pre></div></div>

<p>where <code class="highlighter-rouge">ren</code> turns a renaming <code class="highlighter-rouge">ρ</code> into a substitution by post-composing
<code class="highlighter-rouge">ρ</code> with the identity substitution.</p>

<pre class="Agda"><a id="ren"></a><a id="6524" href="/Substitution/#6524" class="Function">ren</a> <a id="6528" class="Symbol">:</a> <a id="6530" class="Symbol">∀{</a><a id="6532" href="plfa.Substitution.html#6532" class="Bound">Γ</a> <a id="6534" href="plfa.Substitution.html#6534" class="Bound">Δ</a><a id="6535" class="Symbol">}</a> <a id="6537" class="Symbol">→</a> <a id="6539" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="6546" href="plfa.Substitution.html#6532" class="Bound">Γ</a> <a id="6548" href="plfa.Substitution.html#6534" class="Bound">Δ</a> <a id="6550" class="Symbol">→</a> <a id="6552" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="6558" href="plfa.Substitution.html#6532" class="Bound">Γ</a> <a id="6560" href="plfa.Substitution.html#6534" class="Bound">Δ</a>
<a id="6562" href="/Substitution/#6524" class="Function">ren</a> <a id="6566" href="plfa.Substitution.html#6566" class="Bound">ρ</a> <a id="6568" class="Symbol">=</a> <a id="6570" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="6574" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="6576" href="plfa.Substitution.html#6566" class="Bound">ρ</a>
</pre>
<p>When the renaming is the increment function, then it is equivalent to
shift.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ren S_ ≡ ↑                             (ren-shift)

rename S_ M ≡ ⟪ ↑ ⟫ M                  (rename-shift)
</code></pre></div></div>

<p>Renaming with the identity renaming leaves the term unchanged.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rename (λ {A} x → x) M ≡ M             (rename-id)
</code></pre></div></div>

<p>Next we relate the <code class="highlighter-rouge">exts</code> function to the σ algebra.  Recall that the
<code class="highlighter-rouge">exts</code> function extends a substitution as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exts σ = ` Z, rename S_ (σ 0), rename S_ (σ 1), rename S_ (σ 2), ...
</code></pre></div></div>

<p>So <code class="highlighter-rouge">exts</code> is equivalent to cons’ing Z onto the sequence formed
by applying <code class="highlighter-rouge">σ</code> and then shifting.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exts σ ≡ ` Z • (σ ⨟ ↑)                (exts-cons-shift)
</code></pre></div></div>

<p>The <code class="highlighter-rouge">ext</code> function does the same job as <code class="highlighter-rouge">exts</code> but for renamings
instead of substitutions. So composing <code class="highlighter-rouge">ext</code> with <code class="highlighter-rouge">ren</code> is the same as
composing <code class="highlighter-rouge">ren</code> with <code class="highlighter-rouge">exts</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ren (ext ρ) ≡ exts (ren ρ)            (ren-ext)
</code></pre></div></div>

<p>Thus, we can recast the <code class="highlighter-rouge">exts-cons-shift</code> equation in terms of
renamings.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ren (ext ρ) ≡ ` Z • (ren ρ ⨟ ↑)       (ext-cons-Z-shift)
</code></pre></div></div>

<p>It is also useful to specialize the <code class="highlighter-rouge">sub-sub</code> equation of the σ
algebra to the situation where the first substitution is a renaming.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟪ σ ⟫ (rename ρ M) ≡ ⟪ σ ∘ ρ ⟫ M       (rename-subst)
</code></pre></div></div>

<p>The <code class="highlighter-rouge">subst-zero M</code> substitution is equivalent to cons’ing
<code class="highlighter-rouge">M</code> onto the identity substitution.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subst-zero M ≡ M • ids                (subst-Z-cons-ids)
</code></pre></div></div>

<p>Finally, sequencing <code class="highlighter-rouge">exts σ</code> with <code class="highlighter-rouge">subst-zero M</code> is equivalent to
cons’ing <code class="highlighter-rouge">M</code> onto <code class="highlighter-rouge">σ</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exts σ ⨟ subst-zero M ≡ (M • σ)       (subst-zero-exts-cons)
</code></pre></div></div>

<h2 id="proofs-of-sub-head-sub-tail-sub-η-z-shift-sub-idl-sub-dist-and-sub-app">Proofs of sub-head, sub-tail, sub-η, Z-shift, sub-idL, sub-dist, and sub-app</h2>

<p>We start with the proofs that are immediate from the definitions of
the operators.</p>

<pre class="Agda"><a id="sub-head"></a><a id="8285" href="/Substitution/#8285" class="Function">sub-head</a> <a id="8294" class="Symbol">:</a> <a id="8296" class="Symbol">∀</a> <a id="8298" class="Symbol">{</a><a id="8299" href="plfa.Substitution.html#8299" class="Bound">Γ</a> <a id="8301" href="plfa.Substitution.html#8301" class="Bound">Δ</a><a id="8302" class="Symbol">}</a> <a id="8304" class="Symbol">{</a><a id="8305" href="plfa.Substitution.html#8305" class="Bound">A</a><a id="8306" class="Symbol">}</a> <a id="8308" class="Symbol">{</a><a id="8309" href="plfa.Substitution.html#8309" class="Bound">M</a> <a id="8311" class="Symbol">:</a> <a id="8313" href="plfa.Substitution.html#8301" class="Bound">Δ</a> <a id="8315" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="8317" href="plfa.Substitution.html#8305" class="Bound">A</a><a id="8318" class="Symbol">}{</a><a id="8320" href="plfa.Substitution.html#8320" class="Bound">σ</a> <a id="8322" class="Symbol">:</a> <a id="8324" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="8330" href="plfa.Substitution.html#8299" class="Bound">Γ</a> <a id="8332" href="plfa.Substitution.html#8301" class="Bound">Δ</a><a id="8333" class="Symbol">}</a>
         <a id="8344" class="Symbol">→</a> <a id="8346" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="8348" href="plfa.Substitution.html#8309" class="Bound">M</a> <a id="8350" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="8352" href="plfa.Substitution.html#8320" class="Bound">σ</a> <a id="8354" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="8356" class="Symbol">(</a><a id="8357" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="8359" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="8360" class="Symbol">)</a> <a id="8362" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8364" href="plfa.Substitution.html#8309" class="Bound">M</a>
<a id="8366" href="/Substitution/#8285" class="Function">sub-head</a> <a id="8375" class="Symbol">=</a> <a id="8377" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="sub-tail"></a><a id="8391" href="/Substitution/#8391" class="Function">sub-tail</a> <a id="8400" class="Symbol">:</a> <a id="8402" class="Symbol">∀{</a><a id="8404" href="plfa.Substitution.html#8404" class="Bound">Γ</a> <a id="8406" href="plfa.Substitution.html#8406" class="Bound">Δ</a><a id="8407" class="Symbol">}</a> <a id="8409" class="Symbol">{</a><a id="8410" href="plfa.Substitution.html#8410" class="Bound">A</a> <a id="8412" href="plfa.Substitution.html#8412" class="Bound">B</a><a id="8413" class="Symbol">}</a> <a id="8415" class="Symbol">{</a><a id="8416" href="plfa.Substitution.html#8416" class="Bound">M</a> <a id="8418" class="Symbol">:</a> <a id="8420" href="plfa.Substitution.html#8406" class="Bound">Δ</a> <a id="8422" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="8424" href="plfa.Substitution.html#8410" class="Bound">A</a><a id="8425" class="Symbol">}</a> <a id="8427" class="Symbol">{</a><a id="8428" href="plfa.Substitution.html#8428" class="Bound">σ</a> <a id="8430" class="Symbol">:</a> <a id="8432" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="8438" href="plfa.Substitution.html#8404" class="Bound">Γ</a> <a id="8440" href="plfa.Substitution.html#8406" class="Bound">Δ</a><a id="8441" class="Symbol">}</a>
         <a id="8452" class="Symbol">→</a> <a id="8454" class="Symbol">(</a><a id="8455" href="/Substitution/#3211" class="Function">↑</a> <a id="8457" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="8459" href="plfa.Substitution.html#8416" class="Bound">M</a> <a id="8461" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="8463" href="plfa.Substitution.html#8428" class="Bound">σ</a><a id="8464" class="Symbol">)</a> <a id="8466" class="Symbol">{</a><a id="8467" class="Argument">A</a> <a id="8469" class="Symbol">=</a> <a id="8471" href="plfa.Substitution.html#8412" class="Bound">B</a><a id="8472" class="Symbol">}</a> <a id="8474" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8476" href="plfa.Substitution.html#8428" class="Bound">σ</a>
<a id="8478" href="/Substitution/#8391" class="Function">sub-tail</a> <a id="8487" class="Symbol">=</a> <a id="8489" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="8504" class="Symbol">λ</a> <a id="8506" href="plfa.Substitution.html#8506" class="Bound">x</a> <a id="8508" class="Symbol">→</a> <a id="8510" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="sub-η"></a><a id="8524" href="/Substitution/#8524" class="Function">sub-η</a> <a id="8530" class="Symbol">:</a> <a id="8532" class="Symbol">∀{</a><a id="8534" href="plfa.Substitution.html#8534" class="Bound">Γ</a> <a id="8536" href="plfa.Substitution.html#8536" class="Bound">Δ</a><a id="8537" class="Symbol">}</a> <a id="8539" class="Symbol">{</a><a id="8540" href="plfa.Substitution.html#8540" class="Bound">A</a> <a id="8542" href="plfa.Substitution.html#8542" class="Bound">B</a><a id="8543" class="Symbol">}</a> <a id="8545" class="Symbol">{</a><a id="8546" href="plfa.Substitution.html#8546" class="Bound">σ</a> <a id="8548" class="Symbol">:</a> <a id="8550" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="8556" class="Symbol">(</a><a id="8557" href="plfa.Substitution.html#8534" class="Bound">Γ</a> <a id="8559" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="8561" href="plfa.Substitution.html#8540" class="Bound">A</a><a id="8562" class="Symbol">)</a> <a id="8564" href="plfa.Substitution.html#8536" class="Bound">Δ</a><a id="8565" class="Symbol">}</a>
      <a id="8573" class="Symbol">→</a> <a id="8575" class="Symbol">(</a><a id="8576" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="8578" href="plfa.Substitution.html#8546" class="Bound">σ</a> <a id="8580" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="8582" class="Symbol">(</a><a id="8583" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="8585" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="8586" class="Symbol">)</a> <a id="8588" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="8590" class="Symbol">(</a><a id="8591" href="plfa.Substitution.html#3211" class="Function">↑</a> <a id="8593" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="8595" href="plfa.Substitution.html#8546" class="Bound">σ</a><a id="8596" class="Symbol">))</a> <a id="8599" class="Symbol">{</a><a id="8600" class="Argument">A</a> <a id="8602" class="Symbol">=</a> <a id="8604" href="plfa.Substitution.html#8542" class="Bound">B</a><a id="8605" class="Symbol">}</a> <a id="8607" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8609" href="plfa.Substitution.html#8546" class="Bound">σ</a>
<a id="8611" href="/Substitution/#8524" class="Function">sub-η</a> <a id="8617" class="Symbol">{</a><a id="8618" href="plfa.Substitution.html#8618" class="Bound">Γ</a><a id="8619" class="Symbol">}{</a><a id="8621" href="plfa.Substitution.html#8621" class="Bound">Δ</a><a id="8622" class="Symbol">}{</a><a id="8624" href="plfa.Substitution.html#8624" class="Bound">A</a><a id="8625" class="Symbol">}{</a><a id="8627" href="plfa.Substitution.html#8627" class="Bound">B</a><a id="8628" class="Symbol">}{</a><a id="8630" href="plfa.Substitution.html#8630" class="Bound">σ</a><a id="8631" class="Symbol">}</a> <a id="8633" class="Symbol">=</a> <a id="8635" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="8650" class="Symbol">λ</a> <a id="8652" href="plfa.Substitution.html#8652" class="Bound">x</a> <a id="8654" class="Symbol">→</a> <a id="8656" href="plfa.Substitution.html#8674" class="Function">lemma</a>
   <a id="8665" class="Keyword">where</a>
   <a id="8674" href="/Substitution/#8674" class="Function">lemma</a> <a id="8680" class="Symbol">:</a> <a id="8682" class="Symbol">∀</a> <a id="8684" class="Symbol">{</a><a id="8685" href="plfa.Substitution.html#8685" class="Bound">x</a><a id="8686" class="Symbol">}</a> <a id="8688" class="Symbol">→</a> <a id="8690" class="Symbol">((</a><a id="8692" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="8694" href="plfa.Substitution.html#8630" class="Bound">σ</a> <a id="8696" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="8698" class="Symbol">(</a><a id="8699" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="8701" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="8702" class="Symbol">))</a> <a id="8705" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="8707" class="Symbol">(</a><a id="8708" href="plfa.Substitution.html#3211" class="Function">↑</a> <a id="8710" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="8712" href="plfa.Substitution.html#8630" class="Bound">σ</a><a id="8713" class="Symbol">))</a> <a id="8716" href="plfa.Substitution.html#8685" class="Bound">x</a> <a id="8718" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8720" href="plfa.Substitution.html#8630" class="Bound">σ</a> <a id="8722" href="plfa.Substitution.html#8685" class="Bound">x</a>
   <a id="8727" href="/Substitution/#8674" class="Function">lemma</a> <a id="8733" class="Symbol">{</a><a id="8734" class="Argument">x</a> <a id="8736" class="Symbol">=</a> <a id="8738" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="8739" class="Symbol">}</a> <a id="8741" class="Symbol">=</a> <a id="8743" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
   <a id="8751" href="/Substitution/#8674" class="Function">lemma</a> <a id="8757" class="Symbol">{</a><a id="8758" class="Argument">x</a> <a id="8760" class="Symbol">=</a> <a id="8762" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="8764" href="plfa.Substitution.html#8764" class="Bound">x</a><a id="8765" class="Symbol">}</a> <a id="8767" class="Symbol">=</a> <a id="8769" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="Z-shift"></a><a id="8783" href="/Substitution/#8783" class="Function">Z-shift</a> <a id="8791" class="Symbol">:</a> <a id="8793" class="Symbol">∀{</a><a id="8795" href="plfa.Substitution.html#8795" class="Bound">Γ</a><a id="8796" class="Symbol">}{</a><a id="8798" href="plfa.Substitution.html#8798" class="Bound">A</a> <a id="8800" href="plfa.Substitution.html#8800" class="Bound">B</a><a id="8801" class="Symbol">}</a>
        <a id="8811" class="Symbol">→</a> <a id="8813" class="Symbol">((</a><a id="8815" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="8817" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="8818" class="Symbol">)</a> <a id="8820" href="/Substitution/#3453" class="Function Operator">•</a> <a id="8822" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="8823" class="Symbol">)</a> <a id="8825" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8827" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="8831" class="Symbol">{</a><a id="8832" href="plfa.Substitution.html#8795" class="Bound">Γ</a> <a id="8834" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="8836" href="plfa.Substitution.html#8798" class="Bound">A</a><a id="8837" class="Symbol">}</a> <a id="8839" class="Symbol">{</a><a id="8840" href="plfa.Substitution.html#8800" class="Bound">B</a><a id="8841" class="Symbol">}</a>
<a id="8843" href="/Substitution/#8783" class="Function">Z-shift</a> <a id="8851" class="Symbol">{</a><a id="8852" href="plfa.Substitution.html#8852" class="Bound">Γ</a><a id="8853" class="Symbol">}{</a><a id="8855" href="plfa.Substitution.html#8855" class="Bound">A</a><a id="8856" class="Symbol">}{</a><a id="8858" href="plfa.Substitution.html#8858" class="Bound">B</a><a id="8859" class="Symbol">}</a> <a id="8861" class="Symbol">=</a> <a id="8863" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="8878" href="plfa.Substitution.html#8896" class="Function">lemma</a>
   <a id="8887" class="Keyword">where</a>
   <a id="8896" href="/Substitution/#8896" class="Function">lemma</a> <a id="8902" class="Symbol">:</a> <a id="8904" class="Symbol">(</a><a id="8905" href="plfa.Substitution.html#8905" class="Bound">x</a> <a id="8907" class="Symbol">:</a> <a id="8909" href="plfa.Substitution.html#8852" class="Bound">Γ</a> <a id="8911" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="8913" href="plfa.Substitution.html#8855" class="Bound">A</a> <a id="8915" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="8917" href="plfa.Substitution.html#8858" class="Bound">B</a><a id="8918" class="Symbol">)</a> <a id="8920" class="Symbol">→</a> <a id="8922" class="Symbol">((</a><a id="8924" href="plfa.Untyped.html#4064" class="InductiveConstructor Operator">`</a> <a id="8926" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="8927" class="Symbol">)</a> <a id="8929" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="8931" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="8932" class="Symbol">)</a> <a id="8934" href="plfa.Substitution.html#8905" class="Bound">x</a> <a id="8936" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8938" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="8942" href="plfa.Substitution.html#8905" class="Bound">x</a>
   <a id="8947" href="/Substitution/#8896" class="Function">lemma</a> <a id="8953" href="/Untyped/#3295" class="InductiveConstructor">Z</a> <a id="8955" class="Symbol">=</a> <a id="8957" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
   <a id="8965" href="/Substitution/#8896" class="Function">lemma</a> <a id="8971" class="Symbol">(</a><a id="8972" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="8974" href="plfa.Substitution.html#8974" class="Bound">y</a><a id="8975" class="Symbol">)</a> <a id="8977" class="Symbol">=</a> <a id="8979" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="sub-idL"></a><a id="8993" href="/Substitution/#8993" class="Function">sub-idL</a> <a id="9001" class="Symbol">:</a> <a id="9003" class="Symbol">∀{</a><a id="9005" href="plfa.Substitution.html#9005" class="Bound">Γ</a> <a id="9007" href="plfa.Substitution.html#9007" class="Bound">Δ</a><a id="9008" class="Symbol">}</a> <a id="9010" class="Symbol">{</a><a id="9011" href="plfa.Substitution.html#9011" class="Bound">σ</a> <a id="9013" class="Symbol">:</a> <a id="9015" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="9021" href="plfa.Substitution.html#9005" class="Bound">Γ</a> <a id="9023" href="plfa.Substitution.html#9007" class="Bound">Δ</a><a id="9024" class="Symbol">}</a> <a id="9026" class="Symbol">{</a><a id="9027" href="plfa.Substitution.html#9027" class="Bound">A</a><a id="9028" class="Symbol">}</a>
       <a id="9037" class="Symbol">→</a> <a id="9039" href="/Substitution/#3072" class="Function">ids</a> <a id="9043" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="9045" href="plfa.Substitution.html#9011" class="Bound">σ</a> <a id="9047" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="9049" href="plfa.Substitution.html#9011" class="Bound">σ</a> <a id="9051" class="Symbol">{</a><a id="9052" href="plfa.Substitution.html#9027" class="Bound">A</a><a id="9053" class="Symbol">}</a>
<a id="9055" href="/Substitution/#8993" class="Function">sub-idL</a> <a id="9063" class="Symbol">=</a> <a id="9065" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="9080" class="Symbol">λ</a> <a id="9082" href="plfa.Substitution.html#9082" class="Bound">x</a> <a id="9084" class="Symbol">→</a> <a id="9086" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="sub-dist"></a><a id="9100" href="/Substitution/#9100" class="Function">sub-dist</a> <a id="9109" class="Symbol">:</a>  <a id="9112" class="Symbol">∀{</a><a id="9114" href="plfa.Substitution.html#9114" class="Bound">Γ</a> <a id="9116" href="plfa.Substitution.html#9116" class="Bound">Δ</a> <a id="9118" href="plfa.Substitution.html#9118" class="Bound">Σ</a> <a id="9120" class="Symbol">:</a> <a id="9122" href="/Untyped/#2906" class="Datatype">Context</a><a id="9129" class="Symbol">}</a> <a id="9131" class="Symbol">{</a><a id="9132" href="plfa.Substitution.html#9132" class="Bound">A</a> <a id="9134" href="plfa.Substitution.html#9134" class="Bound">B</a><a id="9135" class="Symbol">}</a> <a id="9137" class="Symbol">{</a><a id="9138" href="plfa.Substitution.html#9138" class="Bound">σ</a> <a id="9140" class="Symbol">:</a> <a id="9142" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="9148" href="plfa.Substitution.html#9114" class="Bound">Γ</a> <a id="9150" href="plfa.Substitution.html#9116" class="Bound">Δ</a><a id="9151" class="Symbol">}</a> <a id="9153" class="Symbol">{</a><a id="9154" href="plfa.Substitution.html#9154" class="Bound">τ</a> <a id="9156" class="Symbol">:</a> <a id="9158" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="9164" href="plfa.Substitution.html#9116" class="Bound">Δ</a> <a id="9166" href="plfa.Substitution.html#9118" class="Bound">Σ</a><a id="9167" class="Symbol">}</a>
              <a id="9183" class="Symbol">{</a><a id="9184" href="/Substitution/#9184" class="Bound">M</a> <a id="9186" class="Symbol">:</a> <a id="9188" href="plfa.Substitution.html#9116" class="Bound">Δ</a> <a id="9190" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="9192" href="plfa.Substitution.html#9132" class="Bound">A</a><a id="9193" class="Symbol">}</a>
         <a id="9204" class="Symbol">→</a> <a id="9206" class="Symbol">((</a><a id="9208" href="/Substitution/#9184" class="Bound">M</a> <a id="9210" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="9212" href="plfa.Substitution.html#9138" class="Bound">σ</a><a id="9213" class="Symbol">)</a> <a id="9215" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="9217" href="plfa.Substitution.html#9154" class="Bound">τ</a><a id="9218" class="Symbol">)</a> <a id="9220" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="9222" class="Symbol">((</a><a id="9224" href="/Untyped/#6697" class="Function">subst</a> <a id="9230" href="plfa.Substitution.html#9154" class="Bound">τ</a> <a id="9232" href="plfa.Substitution.html#9184" class="Bound">M</a><a id="9233" class="Symbol">)</a> <a id="9235" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="9237" class="Symbol">(</a><a id="9238" href="plfa.Substitution.html#9138" class="Bound">σ</a> <a id="9240" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="9242" href="plfa.Substitution.html#9154" class="Bound">τ</a><a id="9243" class="Symbol">))</a> <a id="9246" class="Symbol">{</a><a id="9247" href="plfa.Substitution.html#9134" class="Bound">B</a><a id="9248" class="Symbol">}</a>
<a id="9250" href="/Substitution/#9100" class="Function">sub-dist</a> <a id="9259" class="Symbol">{</a><a id="9260" href="plfa.Substitution.html#9260" class="Bound">Γ</a><a id="9261" class="Symbol">}{</a><a id="9263" href="plfa.Substitution.html#9263" class="Bound">Δ</a><a id="9264" class="Symbol">}{</a><a id="9266" href="plfa.Substitution.html#9266" class="Bound">Σ</a><a id="9267" class="Symbol">}{</a><a id="9269" href="plfa.Substitution.html#9269" class="Bound">A</a><a id="9270" class="Symbol">}{</a><a id="9272" href="plfa.Substitution.html#9272" class="Bound">B</a><a id="9273" class="Symbol">}{</a><a id="9275" href="plfa.Substitution.html#9275" class="Bound">σ</a><a id="9276" class="Symbol">}{</a><a id="9278" href="plfa.Substitution.html#9278" class="Bound">τ</a><a id="9279" class="Symbol">}{</a><a id="9281" href="plfa.Substitution.html#9281" class="Bound">M</a><a id="9282" class="Symbol">}</a> <a id="9284" class="Symbol">=</a> <a id="9286" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="9301" class="Symbol">λ</a> <a id="9303" href="plfa.Substitution.html#9303" class="Bound">x</a> <a id="9305" class="Symbol">→</a> <a id="9307" href="plfa.Substitution.html#9331" class="Function">lemma</a> <a id="9313" class="Symbol">{</a><a id="9314" class="Argument">x</a> <a id="9316" class="Symbol">=</a> <a id="9318" href="plfa.Substitution.html#9303" class="Bound">x</a><a id="9319" class="Symbol">}</a>
  <a id="9323" class="Keyword">where</a>
  <a id="9331" href="/Substitution/#9331" class="Function">lemma</a> <a id="9337" class="Symbol">:</a> <a id="9339" class="Symbol">∀</a> <a id="9341" class="Symbol">{</a><a id="9342" href="plfa.Substitution.html#9342" class="Bound">x</a> <a id="9344" class="Symbol">:</a> <a id="9346" href="plfa.Substitution.html#9260" class="Bound">Γ</a> <a id="9348" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="9350" href="plfa.Substitution.html#9269" class="Bound">A</a> <a id="9352" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="9354" href="plfa.Substitution.html#9272" class="Bound">B</a><a id="9355" class="Symbol">}</a> <a id="9357" class="Symbol">→</a> <a id="9359" class="Symbol">((</a><a id="9361" href="plfa.Substitution.html#9281" class="Bound">M</a> <a id="9363" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="9365" href="plfa.Substitution.html#9275" class="Bound">σ</a><a id="9366" class="Symbol">)</a> <a id="9368" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="9370" href="plfa.Substitution.html#9278" class="Bound">τ</a><a id="9371" class="Symbol">)</a> <a id="9373" href="plfa.Substitution.html#9342" class="Bound">x</a> <a id="9375" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="9377" class="Symbol">((</a><a id="9379" href="plfa.Untyped.html#6697" class="Function">subst</a> <a id="9385" href="plfa.Substitution.html#9278" class="Bound">τ</a> <a id="9387" href="plfa.Substitution.html#9281" class="Bound">M</a><a id="9388" class="Symbol">)</a> <a id="9390" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="9392" class="Symbol">(</a><a id="9393" href="plfa.Substitution.html#9275" class="Bound">σ</a> <a id="9395" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="9397" href="plfa.Substitution.html#9278" class="Bound">τ</a><a id="9398" class="Symbol">))</a> <a id="9401" href="plfa.Substitution.html#9342" class="Bound">x</a>
  <a id="9405" href="/Substitution/#9331" class="Function">lemma</a> <a id="9411" class="Symbol">{</a><a id="9412" class="Argument">x</a> <a id="9414" class="Symbol">=</a> <a id="9416" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="9417" class="Symbol">}</a> <a id="9419" class="Symbol">=</a> <a id="9421" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="9428" href="/Substitution/#9331" class="Function">lemma</a> <a id="9434" class="Symbol">{</a><a id="9435" class="Argument">x</a> <a id="9437" class="Symbol">=</a> <a id="9439" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="9441" href="plfa.Substitution.html#9441" class="Bound">x</a><a id="9442" class="Symbol">}</a> <a id="9444" class="Symbol">=</a> <a id="9446" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<pre class="Agda"><a id="sub-app"></a><a id="9460" href="/Substitution/#9460" class="Function">sub-app</a> <a id="9468" class="Symbol">:</a> <a id="9470" class="Symbol">∀{</a><a id="9472" href="plfa.Substitution.html#9472" class="Bound">Γ</a> <a id="9474" href="plfa.Substitution.html#9474" class="Bound">Δ</a><a id="9475" class="Symbol">}</a> <a id="9477" class="Symbol">{</a><a id="9478" href="plfa.Substitution.html#9478" class="Bound">σ</a> <a id="9480" class="Symbol">:</a> <a id="9482" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="9488" href="plfa.Substitution.html#9472" class="Bound">Γ</a> <a id="9490" href="plfa.Substitution.html#9474" class="Bound">Δ</a><a id="9491" class="Symbol">}</a> <a id="9493" class="Symbol">{</a><a id="9494" href="plfa.Substitution.html#9494" class="Bound">L</a> <a id="9496" class="Symbol">:</a> <a id="9498" href="plfa.Substitution.html#9472" class="Bound">Γ</a> <a id="9500" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="9502" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="9503" class="Symbol">}{</a><a id="9505" href="plfa.Substitution.html#9505" class="Bound">M</a> <a id="9507" class="Symbol">:</a> <a id="9509" href="plfa.Substitution.html#9472" class="Bound">Γ</a> <a id="9511" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="9513" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="9514" class="Symbol">}</a>
        <a id="9524" class="Symbol">→</a> <a id="9526" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="9528" href="plfa.Substitution.html#9478" class="Bound">σ</a> <a id="9530" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="9532" class="Symbol">(</a><a id="9533" href="plfa.Substitution.html#9494" class="Bound">L</a> <a id="9535" href="/Untyped/#4176" class="InductiveConstructor Operator">·</a> <a id="9537" href="plfa.Substitution.html#9505" class="Bound">M</a><a id="9538" class="Symbol">)</a>  <a id="9541" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="9543" class="Symbol">(</a><a id="9544" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="9546" href="plfa.Substitution.html#9478" class="Bound">σ</a> <a id="9548" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="9550" href="plfa.Substitution.html#9494" class="Bound">L</a><a id="9551" class="Symbol">)</a> <a id="9553" href="plfa.Untyped.html#4176" class="InductiveConstructor Operator">·</a> <a id="9555" class="Symbol">(</a><a id="9556" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="9558" href="plfa.Substitution.html#9478" class="Bound">σ</a> <a id="9560" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="9562" href="plfa.Substitution.html#9505" class="Bound">M</a><a id="9563" class="Symbol">)</a>
<a id="9565" href="/Substitution/#9460" class="Function">sub-app</a> <a id="9573" class="Symbol">=</a> <a id="9575" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>

<h2 id="interlude-congruences">Interlude: congruences</h2>

<p>In this section we establish congruence rules for the σ algebra
operators <code class="highlighter-rouge">•</code> and <code class="highlighter-rouge">⨟</code> and for <code class="highlighter-rouge">subst</code> and its helper functions <code class="highlighter-rouge">ext</code>,
<code class="highlighter-rouge">rename</code>, <code class="highlighter-rouge">exts</code>, and <code class="highlighter-rouge">subst-zero</code>. These congruence rules help with
the equational reasoning in the later sections of this chapter.</p>

<p>[JGS: I would have liked to prove all of these via cong and cong₂,
 but I have not yet found a way to make that work. It seems that
 various implicit parameters get in the way.]</p>

<pre class="Agda"><a id="cong-ext"></a><a id="10064" href="/Substitution/#10064" class="Function">cong-ext</a> <a id="10073" class="Symbol">:</a> <a id="10075" class="Symbol">∀{</a><a id="10077" href="plfa.Substitution.html#10077" class="Bound">Γ</a> <a id="10079" href="plfa.Substitution.html#10079" class="Bound">Δ</a><a id="10080" class="Symbol">}{</a><a id="10082" href="plfa.Substitution.html#10082" class="Bound">ρ</a> <a id="10084" href="plfa.Substitution.html#10084" class="Bound">ρ′</a> <a id="10087" class="Symbol">:</a> <a id="10089" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="10096" href="plfa.Substitution.html#10077" class="Bound">Γ</a> <a id="10098" href="plfa.Substitution.html#10079" class="Bound">Δ</a><a id="10099" class="Symbol">}{</a><a id="10101" href="plfa.Substitution.html#10101" class="Bound">B</a><a id="10102" class="Symbol">}</a>
   <a id="10107" class="Symbol">→</a> <a id="10109" class="Symbol">(∀{</a><a id="10112" href="/Substitution/#10112" class="Bound">A</a><a id="10113" class="Symbol">}</a> <a id="10115" class="Symbol">→</a> <a id="10117" href="plfa.Substitution.html#10082" class="Bound">ρ</a> <a id="10119" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10121" href="plfa.Substitution.html#10084" class="Bound">ρ′</a> <a id="10124" class="Symbol">{</a><a id="10125" href="plfa.Substitution.html#10112" class="Bound">A</a><a id="10126" class="Symbol">})</a>
     <a id="10134" class="Comment">---------------------------------</a>
   <a id="10171" class="Symbol">→</a> <a id="10173" class="Symbol">∀{</a><a id="10175" href="/Substitution/#10175" class="Bound">A</a><a id="10176" class="Symbol">}</a> <a id="10178" class="Symbol">→</a> <a id="10180" href="/Untyped/#5659" class="Function">ext</a> <a id="10184" href="plfa.Substitution.html#10082" class="Bound">ρ</a> <a id="10186" class="Symbol">{</a><a id="10187" class="Argument">B</a> <a id="10189" class="Symbol">=</a> <a id="10191" href="plfa.Substitution.html#10101" class="Bound">B</a><a id="10192" class="Symbol">}</a> <a id="10194" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10196" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="10200" href="plfa.Substitution.html#10084" class="Bound">ρ′</a> <a id="10203" class="Symbol">{</a><a id="10204" href="plfa.Substitution.html#10175" class="Bound">A</a><a id="10205" class="Symbol">}</a>
<a id="10207" href="/Substitution/#10064" class="Function">cong-ext</a><a id="10215" class="Symbol">{</a><a id="10216" href="plfa.Substitution.html#10216" class="Bound">Γ</a><a id="10217" class="Symbol">}{</a><a id="10219" href="plfa.Substitution.html#10219" class="Bound">Δ</a><a id="10220" class="Symbol">}{</a><a id="10222" href="plfa.Substitution.html#10222" class="Bound">ρ</a><a id="10223" class="Symbol">}{</a><a id="10225" href="plfa.Substitution.html#10225" class="Bound">ρ′</a><a id="10227" class="Symbol">}{</a><a id="10229" href="plfa.Substitution.html#10229" class="Bound">B</a><a id="10230" class="Symbol">}</a> <a id="10232" href="plfa.Substitution.html#10232" class="Bound">rr</a> <a id="10235" class="Symbol">{</a><a id="10236" href="plfa.Substitution.html#10236" class="Bound">A</a><a id="10237" class="Symbol">}</a> <a id="10239" class="Symbol">=</a> <a id="10241" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="10256" class="Symbol">λ</a> <a id="10258" href="plfa.Substitution.html#10258" class="Bound">x</a> <a id="10260" class="Symbol">→</a> <a id="10262" href="plfa.Substitution.html#10282" class="Function">lemma</a> <a id="10268" class="Symbol">{</a><a id="10269" href="plfa.Substitution.html#10258" class="Bound">x</a><a id="10270" class="Symbol">}</a>
  <a id="10274" class="Keyword">where</a>
  <a id="10282" href="/Substitution/#10282" class="Function">lemma</a> <a id="10288" class="Symbol">:</a> <a id="10290" class="Symbol">∀{</a><a id="10292" href="plfa.Substitution.html#10292" class="Bound">x</a> <a id="10294" class="Symbol">:</a> <a id="10296" href="plfa.Substitution.html#10216" class="Bound">Γ</a> <a id="10298" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="10300" href="plfa.Substitution.html#10229" class="Bound">B</a> <a id="10302" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="10304" href="plfa.Substitution.html#10236" class="Bound">A</a><a id="10305" class="Symbol">}</a> <a id="10307" class="Symbol">→</a> <a id="10309" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="10313" href="plfa.Substitution.html#10222" class="Bound">ρ</a> <a id="10315" href="plfa.Substitution.html#10292" class="Bound">x</a> <a id="10317" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10319" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="10323" href="plfa.Substitution.html#10225" class="Bound">ρ′</a> <a id="10326" href="plfa.Substitution.html#10292" class="Bound">x</a>
  <a id="10330" href="/Substitution/#10282" class="Function">lemma</a> <a id="10336" class="Symbol">{</a><a id="10337" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="10338" class="Symbol">}</a> <a id="10340" class="Symbol">=</a> <a id="10342" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="10349" href="/Substitution/#10282" class="Function">lemma</a> <a id="10355" class="Symbol">{</a><a id="10356" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="10358" href="plfa.Substitution.html#10358" class="Bound">y</a><a id="10359" class="Symbol">}</a> <a id="10361" class="Symbol">=</a> <a id="10363" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="10368" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="10371" class="Symbol">(</a><a id="10372" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="10381" href="plfa.Substitution.html#10232" class="Bound">rr</a> <a id="10384" href="plfa.Substitution.html#10358" class="Bound">y</a><a id="10385" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="cong-rename"></a><a id="10396" href="/Substitution/#10396" class="Function">cong-rename</a> <a id="10408" class="Symbol">:</a> <a id="10410" class="Symbol">∀{</a><a id="10412" href="plfa.Substitution.html#10412" class="Bound">Γ</a> <a id="10414" href="plfa.Substitution.html#10414" class="Bound">Δ</a><a id="10415" class="Symbol">}{</a><a id="10417" href="plfa.Substitution.html#10417" class="Bound">ρ</a> <a id="10419" href="plfa.Substitution.html#10419" class="Bound">ρ′</a> <a id="10422" class="Symbol">:</a> <a id="10424" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="10431" href="plfa.Substitution.html#10412" class="Bound">Γ</a> <a id="10433" href="plfa.Substitution.html#10414" class="Bound">Δ</a><a id="10434" class="Symbol">}{</a><a id="10436" href="plfa.Substitution.html#10436" class="Bound">B</a><a id="10437" class="Symbol">}{</a><a id="10439" href="plfa.Substitution.html#10439" class="Bound">M</a> <a id="10441" href="plfa.Substitution.html#10441" class="Bound">M′</a> <a id="10444" class="Symbol">:</a> <a id="10446" href="plfa.Substitution.html#10412" class="Bound">Γ</a> <a id="10448" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="10450" href="plfa.Substitution.html#10436" class="Bound">B</a><a id="10451" class="Symbol">}</a>
        <a id="10461" class="Symbol">→</a> <a id="10463" class="Symbol">(∀{</a><a id="10466" href="/Substitution/#10466" class="Bound">A</a><a id="10467" class="Symbol">}</a> <a id="10469" class="Symbol">→</a> <a id="10471" href="plfa.Substitution.html#10417" class="Bound">ρ</a> <a id="10473" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10475" href="plfa.Substitution.html#10419" class="Bound">ρ′</a> <a id="10478" class="Symbol">{</a><a id="10479" href="plfa.Substitution.html#10466" class="Bound">A</a><a id="10480" class="Symbol">})</a>  <a id="10484" class="Symbol">→</a>  <a id="10487" href="plfa.Substitution.html#10439" class="Bound">M</a> <a id="10489" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10491" href="plfa.Substitution.html#10441" class="Bound">M′</a>
          <a id="10504" class="Comment">------------------------------</a>
        <a id="10543" class="Symbol">→</a> <a id="10545" href="/Untyped/#5969" class="Function">rename</a> <a id="10552" href="/Substitution/#10417" class="Bound">ρ</a> <a id="10554" href="plfa.Substitution.html#10439" class="Bound">M</a> <a id="10556" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10558" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="10565" href="plfa.Substitution.html#10419" class="Bound">ρ′</a> <a id="10568" href="plfa.Substitution.html#10439" class="Bound">M</a>
<a id="10570" href="/Substitution/#10396" class="Function">cong-rename</a> <a id="10582" class="Symbol">{</a><a id="10583" class="Argument">M</a> <a id="10585" class="Symbol">=</a> <a id="10587" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="10589" href="plfa.Substitution.html#10589" class="Bound">x</a><a id="10590" class="Symbol">}</a> <a id="10592" href="plfa.Substitution.html#10592" class="Bound">rr</a> <a id="10595" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="10600" class="Symbol">=</a> <a id="10602" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="10607" href="plfa.Untyped.html#4064" class="InductiveConstructor Operator">`_</a> <a id="10610" class="Symbol">(</a><a id="10611" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="10620" href="plfa.Substitution.html#10592" class="Bound">rr</a> <a id="10623" href="plfa.Substitution.html#10589" class="Bound">x</a><a id="10624" class="Symbol">)</a>
<a id="10626" href="/Substitution/#10396" class="Function">cong-rename</a> <a id="10638" class="Symbol">{</a><a id="10639" class="Argument">ρ</a> <a id="10641" class="Symbol">=</a> <a id="10643" href="plfa.Substitution.html#10643" class="Bound">ρ</a><a id="10644" class="Symbol">}</a> <a id="10646" class="Symbol">{</a><a id="10647" class="Argument">ρ′</a> <a id="10650" class="Symbol">=</a> <a id="10652" href="plfa.Substitution.html#10652" class="Bound">ρ′</a><a id="10654" class="Symbol">}</a> <a id="10656" class="Symbol">{</a><a id="10657" class="Argument">M</a> <a id="10659" class="Symbol">=</a> <a id="10661" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="10663" href="plfa.Substitution.html#10663" class="Bound">N</a><a id="10664" class="Symbol">}</a> <a id="10666" href="plfa.Substitution.html#10666" class="Bound">rr</a> <a id="10669" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="10674" class="Symbol">=</a>
   <a id="10679" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="10684" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="10687" class="Symbol">(</a><a id="10688" href="/Substitution/#10396" class="Function">cong-rename</a> <a id="10700" class="Symbol">{</a><a id="10701" class="Argument">ρ</a> <a id="10703" class="Symbol">=</a> <a id="10705" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="10709" href="plfa.Substitution.html#10643" class="Bound">ρ</a><a id="10710" class="Symbol">}{</a><a id="10712" class="Argument">ρ′</a> <a id="10715" class="Symbol">=</a> <a id="10717" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="10721" href="plfa.Substitution.html#10652" class="Bound">ρ′</a><a id="10723" class="Symbol">}{</a><a id="10725" class="Argument">M</a> <a id="10727" class="Symbol">=</a> <a id="10729" href="plfa.Substitution.html#10663" class="Bound">N</a><a id="10730" class="Symbol">}</a> <a id="10732" class="Symbol">(</a><a id="10733" href="plfa.Substitution.html#10064" class="Function">cong-ext</a> <a id="10742" href="plfa.Substitution.html#10666" class="Bound">rr</a><a id="10744" class="Symbol">)</a> <a id="10746" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="10750" class="Symbol">)</a>
<a id="10752" href="/Substitution/#10396" class="Function">cong-rename</a> <a id="10764" class="Symbol">{</a><a id="10765" class="Argument">M</a> <a id="10767" class="Symbol">=</a> <a id="10769" href="plfa.Substitution.html#10769" class="Bound">L</a> <a id="10771" href="/Untyped/#4176" class="InductiveConstructor Operator">·</a> <a id="10773" href="plfa.Substitution.html#10773" class="Bound">M</a><a id="10774" class="Symbol">}</a> <a id="10776" href="plfa.Substitution.html#10776" class="Bound">rr</a> <a id="10779" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="10784" class="Symbol">=</a>
   <a id="10789" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1436" class="Function">cong₂</a> <a id="10795" href="/Untyped/#4176" class="InductiveConstructor Operator">_·_</a> <a id="10799" class="Symbol">(</a><a id="10800" href="/Substitution/#10396" class="Function">cong-rename</a> <a id="10812" href="plfa.Substitution.html#10776" class="Bound">rr</a> <a id="10815" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="10819" class="Symbol">)</a> <a id="10821" class="Symbol">(</a><a id="10822" href="plfa.Substitution.html#10396" class="Function">cong-rename</a> <a id="10834" href="plfa.Substitution.html#10776" class="Bound">rr</a> <a id="10837" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="10841" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="cong-exts"></a><a id="10852" href="/Substitution/#10852" class="Function">cong-exts</a> <a id="10862" class="Symbol">:</a> <a id="10864" class="Symbol">∀{</a><a id="10866" href="plfa.Substitution.html#10866" class="Bound">Γ</a> <a id="10868" href="plfa.Substitution.html#10868" class="Bound">Δ</a><a id="10869" class="Symbol">}{</a><a id="10871" href="plfa.Substitution.html#10871" class="Bound">σ</a> <a id="10873" href="plfa.Substitution.html#10873" class="Bound">σ′</a> <a id="10876" class="Symbol">:</a> <a id="10878" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="10884" href="plfa.Substitution.html#10866" class="Bound">Γ</a> <a id="10886" href="plfa.Substitution.html#10868" class="Bound">Δ</a><a id="10887" class="Symbol">}{</a><a id="10889" href="plfa.Substitution.html#10889" class="Bound">B</a><a id="10890" class="Symbol">}</a>
   <a id="10895" class="Symbol">→</a> <a id="10897" class="Symbol">(∀{</a><a id="10900" href="/Substitution/#10900" class="Bound">A</a><a id="10901" class="Symbol">}</a> <a id="10903" class="Symbol">→</a> <a id="10905" href="plfa.Substitution.html#10871" class="Bound">σ</a> <a id="10907" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10909" href="plfa.Substitution.html#10873" class="Bound">σ′</a> <a id="10912" class="Symbol">{</a><a id="10913" href="plfa.Substitution.html#10900" class="Bound">A</a><a id="10914" class="Symbol">})</a>
     <a id="10922" class="Comment">-----------------------------------</a>
   <a id="10961" class="Symbol">→</a> <a id="10963" class="Symbol">∀{</a><a id="10965" href="/Substitution/#10965" class="Bound">A</a><a id="10966" class="Symbol">}</a> <a id="10968" class="Symbol">→</a> <a id="10970" href="/Untyped/#6405" class="Function">exts</a> <a id="10975" href="plfa.Substitution.html#10871" class="Bound">σ</a> <a id="10977" class="Symbol">{</a><a id="10978" class="Argument">B</a> <a id="10980" class="Symbol">=</a> <a id="10982" href="plfa.Substitution.html#10889" class="Bound">B</a><a id="10983" class="Symbol">}</a> <a id="10985" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="10987" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="10992" href="plfa.Substitution.html#10873" class="Bound">σ′</a> <a id="10995" class="Symbol">{</a><a id="10996" href="plfa.Substitution.html#10965" class="Bound">A</a><a id="10997" class="Symbol">}</a>
<a id="10999" href="/Substitution/#10852" class="Function">cong-exts</a><a id="11008" class="Symbol">{</a><a id="11009" href="plfa.Substitution.html#11009" class="Bound">Γ</a><a id="11010" class="Symbol">}{</a><a id="11012" href="plfa.Substitution.html#11012" class="Bound">Δ</a><a id="11013" class="Symbol">}{</a><a id="11015" href="plfa.Substitution.html#11015" class="Bound">σ</a><a id="11016" class="Symbol">}{</a><a id="11018" href="plfa.Substitution.html#11018" class="Bound">σ′</a><a id="11020" class="Symbol">}{</a><a id="11022" href="plfa.Substitution.html#11022" class="Bound">B</a><a id="11023" class="Symbol">}</a> <a id="11025" href="plfa.Substitution.html#11025" class="Bound">ss</a> <a id="11028" class="Symbol">{</a><a id="11029" href="plfa.Substitution.html#11029" class="Bound">A</a><a id="11030" class="Symbol">}</a> <a id="11032" class="Symbol">=</a> <a id="11034" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="11049" class="Symbol">λ</a> <a id="11051" href="plfa.Substitution.html#11051" class="Bound">x</a> <a id="11053" class="Symbol">→</a> <a id="11055" href="plfa.Substitution.html#11077" class="Function">lemma</a> <a id="11061" class="Symbol">{</a><a id="11062" href="plfa.Substitution.html#11051" class="Bound">x</a><a id="11063" class="Symbol">}</a>
   <a id="11068" class="Keyword">where</a>
   <a id="11077" href="/Substitution/#11077" class="Function">lemma</a> <a id="11083" class="Symbol">:</a> <a id="11085" class="Symbol">∀{</a><a id="11087" href="plfa.Substitution.html#11087" class="Bound">x</a><a id="11088" class="Symbol">}</a> <a id="11090" class="Symbol">→</a> <a id="11092" href="/Untyped/#6405" class="Function">exts</a> <a id="11097" href="plfa.Substitution.html#11015" class="Bound">σ</a> <a id="11099" href="plfa.Substitution.html#11087" class="Bound">x</a> <a id="11101" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="11103" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="11108" href="plfa.Substitution.html#11018" class="Bound">σ′</a> <a id="11111" href="plfa.Substitution.html#11087" class="Bound">x</a>
   <a id="11116" href="/Substitution/#11077" class="Function">lemma</a> <a id="11122" class="Symbol">{</a><a id="11123" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="11124" class="Symbol">}</a> <a id="11126" class="Symbol">=</a> <a id="11128" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
   <a id="11136" href="/Substitution/#11077" class="Function">lemma</a> <a id="11142" class="Symbol">{</a><a id="11143" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="11145" href="plfa.Substitution.html#11145" class="Bound">x</a><a id="11146" class="Symbol">}</a> <a id="11148" class="Symbol">=</a> <a id="11150" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="11155" class="Symbol">(</a><a id="11156" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="11163" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a><a id="11165" class="Symbol">)</a> <a id="11167" class="Symbol">(</a><a id="11168" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="11177" class="Symbol">(</a><a id="11178" href="plfa.Substitution.html#11025" class="Bound">ss</a> <a id="11181" class="Symbol">{</a><a id="11182" href="plfa.Substitution.html#11029" class="Bound">A</a><a id="11183" class="Symbol">})</a> <a id="11186" href="plfa.Substitution.html#11145" class="Bound">x</a><a id="11187" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="cong-sub"></a><a id="11198" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="11207" class="Symbol">:</a> <a id="11209" class="Symbol">∀{</a><a id="11211" href="plfa.Substitution.html#11211" class="Bound">Γ</a> <a id="11213" href="plfa.Substitution.html#11213" class="Bound">Δ</a><a id="11214" class="Symbol">}{</a><a id="11216" href="plfa.Substitution.html#11216" class="Bound">σ</a> <a id="11218" href="plfa.Substitution.html#11218" class="Bound">σ′</a> <a id="11221" class="Symbol">:</a> <a id="11223" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="11229" href="plfa.Substitution.html#11211" class="Bound">Γ</a> <a id="11231" href="plfa.Substitution.html#11213" class="Bound">Δ</a><a id="11232" class="Symbol">}{</a><a id="11234" href="plfa.Substitution.html#11234" class="Bound">A</a><a id="11235" class="Symbol">}{</a><a id="11237" href="plfa.Substitution.html#11237" class="Bound">M</a> <a id="11239" href="plfa.Substitution.html#11239" class="Bound">M′</a> <a id="11242" class="Symbol">:</a> <a id="11244" href="plfa.Substitution.html#11211" class="Bound">Γ</a> <a id="11246" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="11248" href="plfa.Substitution.html#11234" class="Bound">A</a><a id="11249" class="Symbol">}</a>
            <a id="11263" class="Symbol">→</a> <a id="11265" class="Symbol">(∀{</a><a id="11268" href="/Substitution/#11268" class="Bound">A</a><a id="11269" class="Symbol">}</a> <a id="11271" class="Symbol">→</a> <a id="11273" href="plfa.Substitution.html#11216" class="Bound">σ</a> <a id="11275" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="11277" href="plfa.Substitution.html#11218" class="Bound">σ′</a> <a id="11280" class="Symbol">{</a><a id="11281" href="plfa.Substitution.html#11268" class="Bound">A</a><a id="11282" class="Symbol">})</a>  <a id="11286" class="Symbol">→</a>  <a id="11289" href="plfa.Substitution.html#11237" class="Bound">M</a> <a id="11291" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="11293" href="plfa.Substitution.html#11239" class="Bound">M′</a>
              <a id="11310" class="Comment">------------------------------</a>
            <a id="11353" class="Symbol">→</a> <a id="11355" href="/Untyped/#6697" class="Function">subst</a> <a id="11361" href="/Substitution/#11216" class="Bound">σ</a> <a id="11363" href="plfa.Substitution.html#11237" class="Bound">M</a> <a id="11365" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="11367" href="plfa.Untyped.html#6697" class="Function">subst</a> <a id="11373" href="plfa.Substitution.html#11218" class="Bound">σ′</a> <a id="11376" href="plfa.Substitution.html#11239" class="Bound">M′</a>
<a id="11379" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="11388" class="Symbol">{</a><a id="11389" href="plfa.Substitution.html#11389" class="Bound">Γ</a><a id="11390" class="Symbol">}</a> <a id="11392" class="Symbol">{</a><a id="11393" href="plfa.Substitution.html#11393" class="Bound">Δ</a><a id="11394" class="Symbol">}</a> <a id="11396" class="Symbol">{</a><a id="11397" href="plfa.Substitution.html#11397" class="Bound">σ</a><a id="11398" class="Symbol">}</a> <a id="11400" class="Symbol">{</a><a id="11401" href="plfa.Substitution.html#11401" class="Bound">σ′</a><a id="11403" class="Symbol">}</a> <a id="11405" class="Symbol">{</a><a id="11406" href="plfa.Substitution.html#11406" class="Bound">A</a><a id="11407" class="Symbol">}</a> <a id="11409" class="Symbol">{</a><a id="11410" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="11412" href="plfa.Substitution.html#11412" class="Bound">x</a><a id="11413" class="Symbol">}</a> <a id="11415" href="plfa.Substitution.html#11415" class="Bound">ss</a> <a id="11418" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="11423" class="Symbol">=</a> <a id="11425" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="11434" href="plfa.Substitution.html#11415" class="Bound">ss</a> <a id="11437" href="plfa.Substitution.html#11412" class="Bound">x</a>
<a id="11439" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="11448" class="Symbol">{</a><a id="11449" href="plfa.Substitution.html#11449" class="Bound">Γ</a><a id="11450" class="Symbol">}</a> <a id="11452" class="Symbol">{</a><a id="11453" href="plfa.Substitution.html#11453" class="Bound">Δ</a><a id="11454" class="Symbol">}</a> <a id="11456" class="Symbol">{</a><a id="11457" href="plfa.Substitution.html#11457" class="Bound">σ</a><a id="11458" class="Symbol">}</a> <a id="11460" class="Symbol">{</a><a id="11461" href="plfa.Substitution.html#11461" class="Bound">σ′</a><a id="11463" class="Symbol">}</a> <a id="11465" class="Symbol">{</a><a id="11466" href="plfa.Substitution.html#11466" class="Bound">A</a><a id="11467" class="Symbol">}</a> <a id="11469" class="Symbol">{</a><a id="11470" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="11472" href="plfa.Substitution.html#11472" class="Bound">M</a><a id="11473" class="Symbol">}</a> <a id="11475" href="plfa.Substitution.html#11475" class="Bound">ss</a> <a id="11478" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="11483" class="Symbol">=</a>
   <a id="11488" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="11493" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="11496" class="Symbol">(</a><a id="11497" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="11506" class="Symbol">{</a><a id="11507" class="Argument">σ</a> <a id="11509" class="Symbol">=</a> <a id="11511" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="11516" href="plfa.Substitution.html#11457" class="Bound">σ</a><a id="11517" class="Symbol">}{</a><a id="11519" class="Argument">σ′</a> <a id="11522" class="Symbol">=</a> <a id="11524" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="11529" href="plfa.Substitution.html#11461" class="Bound">σ′</a><a id="11531" class="Symbol">}</a> <a id="11533" class="Symbol">{</a><a id="11534" class="Argument">M</a> <a id="11536" class="Symbol">=</a> <a id="11538" href="plfa.Substitution.html#11472" class="Bound">M</a><a id="11539" class="Symbol">}</a> <a id="11541" class="Symbol">(</a><a id="11542" href="plfa.Substitution.html#10852" class="Function">cong-exts</a> <a id="11552" href="plfa.Substitution.html#11475" class="Bound">ss</a><a id="11554" class="Symbol">)</a> <a id="11556" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="11560" class="Symbol">)</a>
<a id="11562" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="11571" class="Symbol">{</a><a id="11572" href="plfa.Substitution.html#11572" class="Bound">Γ</a><a id="11573" class="Symbol">}</a> <a id="11575" class="Symbol">{</a><a id="11576" href="plfa.Substitution.html#11576" class="Bound">Δ</a><a id="11577" class="Symbol">}</a> <a id="11579" class="Symbol">{</a><a id="11580" href="plfa.Substitution.html#11580" class="Bound">σ</a><a id="11581" class="Symbol">}</a> <a id="11583" class="Symbol">{</a><a id="11584" href="plfa.Substitution.html#11584" class="Bound">σ′</a><a id="11586" class="Symbol">}</a> <a id="11588" class="Symbol">{</a><a id="11589" href="plfa.Substitution.html#11589" class="Bound">A</a><a id="11590" class="Symbol">}</a> <a id="11592" class="Symbol">{</a><a id="11593" href="plfa.Substitution.html#11593" class="Bound">L</a> <a id="11595" href="/Untyped/#4176" class="InductiveConstructor Operator">·</a> <a id="11597" href="plfa.Substitution.html#11597" class="Bound">M</a><a id="11598" class="Symbol">}</a> <a id="11600" href="plfa.Substitution.html#11600" class="Bound">ss</a> <a id="11603" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="11608" class="Symbol">=</a>
   <a id="11613" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1436" class="Function">cong₂</a> <a id="11619" href="/Untyped/#4176" class="InductiveConstructor Operator">_·_</a> <a id="11623" class="Symbol">(</a><a id="11624" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="11633" class="Symbol">{</a><a id="11634" class="Argument">M</a> <a id="11636" class="Symbol">=</a> <a id="11638" href="plfa.Substitution.html#11593" class="Bound">L</a><a id="11639" class="Symbol">}</a> <a id="11641" href="plfa.Substitution.html#11600" class="Bound">ss</a> <a id="11644" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="11648" class="Symbol">)</a> <a id="11650" class="Symbol">(</a><a id="11651" href="plfa.Substitution.html#11198" class="Function">cong-sub</a> <a id="11660" class="Symbol">{</a><a id="11661" class="Argument">M</a> <a id="11663" class="Symbol">=</a> <a id="11665" href="plfa.Substitution.html#11597" class="Bound">M</a><a id="11666" class="Symbol">}</a> <a id="11668" href="plfa.Substitution.html#11600" class="Bound">ss</a> <a id="11671" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="11675" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="cong-sub-zero"></a><a id="11686" href="/Substitution/#11686" class="Function">cong-sub-zero</a> <a id="11700" class="Symbol">:</a> <a id="11702" class="Symbol">∀{</a><a id="11704" href="plfa.Substitution.html#11704" class="Bound">Γ</a><a id="11705" class="Symbol">}{</a><a id="11707" href="plfa.Substitution.html#11707" class="Bound">B</a> <a id="11709" class="Symbol">:</a> <a id="11711" href="/Untyped/#2633" class="Datatype">Type</a><a id="11715" class="Symbol">}{</a><a id="11717" href="plfa.Substitution.html#11717" class="Bound">M</a> <a id="11719" href="plfa.Substitution.html#11719" class="Bound">M′</a> <a id="11722" class="Symbol">:</a> <a id="11724" href="plfa.Substitution.html#11704" class="Bound">Γ</a> <a id="11726" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="11728" href="plfa.Substitution.html#11707" class="Bound">B</a><a id="11729" class="Symbol">}</a>
  <a id="11733" class="Symbol">→</a> <a id="11735" href="/Substitution/#11717" class="Bound">M</a> <a id="11737" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="11739" href="plfa.Substitution.html#11719" class="Bound">M′</a>
    <a id="11746" class="Comment">-----------------------------------------</a>
  <a id="11790" class="Symbol">→</a> <a id="11792" class="Symbol">∀{</a><a id="11794" href="/Substitution/#11794" class="Bound">A</a><a id="11795" class="Symbol">}</a> <a id="11797" class="Symbol">→</a> <a id="11799" href="/Untyped/#7109" class="Function">subst-zero</a> <a id="11810" href="plfa.Substitution.html#11717" class="Bound">M</a> <a id="11812" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="11814" class="Symbol">(</a><a id="11815" href="plfa.Untyped.html#7109" class="Function">subst-zero</a> <a id="11826" href="plfa.Substitution.html#11719" class="Bound">M′</a><a id="11828" class="Symbol">)</a> <a id="11830" class="Symbol">{</a><a id="11831" href="plfa.Substitution.html#11794" class="Bound">A</a><a id="11832" class="Symbol">}</a>
<a id="11834" href="/Substitution/#11686" class="Function">cong-sub-zero</a> <a id="11848" class="Symbol">{</a><a id="11849" href="plfa.Substitution.html#11849" class="Bound">Γ</a><a id="11850" class="Symbol">}{</a><a id="11852" href="plfa.Substitution.html#11852" class="Bound">B</a><a id="11853" class="Symbol">}{</a><a id="11855" href="plfa.Substitution.html#11855" class="Bound">M</a><a id="11856" class="Symbol">}{</a><a id="11858" href="plfa.Substitution.html#11858" class="Bound">M′</a><a id="11860" class="Symbol">}</a> <a id="11862" href="plfa.Substitution.html#11862" class="Bound">mm&#39;</a> <a id="11866" class="Symbol">{</a><a id="11867" href="plfa.Substitution.html#11867" class="Bound">A</a><a id="11868" class="Symbol">}</a> <a id="11870" class="Symbol">=</a>
   <a id="11875" href="/Substitution/#1953" class="Postulate">extensionality</a> <a id="11890" class="Symbol">λ</a> <a id="11892" href="plfa.Substitution.html#11892" class="Bound">x</a> <a id="11894" class="Symbol">→</a> <a id="11896" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="11901" class="Symbol">(λ</a> <a id="11904" href="plfa.Substitution.html#11904" class="Bound">z</a> <a id="11906" class="Symbol">→</a> <a id="11908" href="/Untyped/#7109" class="Function">subst-zero</a> <a id="11919" href="plfa.Substitution.html#11904" class="Bound">z</a> <a id="11921" href="plfa.Substitution.html#11892" class="Bound">x</a><a id="11922" class="Symbol">)</a> <a id="11924" href="plfa.Substitution.html#11862" class="Bound">mm&#39;</a>
</pre>
<pre class="Agda"><a id="cong-cons"></a><a id="11937" href="/Substitution/#11937" class="Function">cong-cons</a> <a id="11947" class="Symbol">:</a> <a id="11949" class="Symbol">∀{</a><a id="11951" href="plfa.Substitution.html#11951" class="Bound">Γ</a> <a id="11953" href="plfa.Substitution.html#11953" class="Bound">Δ</a><a id="11954" class="Symbol">}{</a><a id="11956" href="plfa.Substitution.html#11956" class="Bound">A</a><a id="11957" class="Symbol">}{</a><a id="11959" href="plfa.Substitution.html#11959" class="Bound">M</a> <a id="11961" href="plfa.Substitution.html#11961" class="Bound">N</a> <a id="11963" class="Symbol">:</a> <a id="11965" href="plfa.Substitution.html#11953" class="Bound">Δ</a> <a id="11967" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="11969" href="plfa.Substitution.html#11956" class="Bound">A</a><a id="11970" class="Symbol">}{</a><a id="11972" href="plfa.Substitution.html#11972" class="Bound">σ</a> <a id="11974" href="plfa.Substitution.html#11974" class="Bound">τ</a> <a id="11976" class="Symbol">:</a> <a id="11978" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="11984" href="plfa.Substitution.html#11951" class="Bound">Γ</a> <a id="11986" href="plfa.Substitution.html#11953" class="Bound">Δ</a><a id="11987" class="Symbol">}</a>
  <a id="11991" class="Symbol">→</a> <a id="11993" href="/Substitution/#11959" class="Bound">M</a> <a id="11995" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="11997" href="plfa.Substitution.html#11961" class="Bound">N</a>  <a id="12000" class="Symbol">→</a>  <a id="12003" class="Symbol">(∀{</a><a id="12006" href="plfa.Substitution.html#12006" class="Bound">A</a><a id="12007" class="Symbol">}</a> <a id="12009" class="Symbol">→</a> <a id="12011" href="plfa.Substitution.html#11972" class="Bound">σ</a> <a id="12013" class="Symbol">{</a><a id="12014" href="plfa.Substitution.html#12006" class="Bound">A</a><a id="12015" class="Symbol">}</a> <a id="12017" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="12019" href="plfa.Substitution.html#11974" class="Bound">τ</a> <a id="12021" class="Symbol">{</a><a id="12022" href="plfa.Substitution.html#12006" class="Bound">A</a><a id="12023" class="Symbol">})</a>
    <a id="12030" class="Comment">--------------------------------</a>
  <a id="12065" class="Symbol">→</a> <a id="12067" class="Symbol">∀{</a><a id="12069" href="/Substitution/#12069" class="Bound">A</a><a id="12070" class="Symbol">}</a> <a id="12072" class="Symbol">→</a> <a id="12074" class="Symbol">(</a><a id="12075" href="plfa.Substitution.html#11959" class="Bound">M</a> <a id="12077" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="12079" href="plfa.Substitution.html#11972" class="Bound">σ</a><a id="12080" class="Symbol">)</a> <a id="12082" class="Symbol">{</a><a id="12083" href="plfa.Substitution.html#12069" class="Bound">A</a><a id="12084" class="Symbol">}</a> <a id="12086" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="12088" class="Symbol">(</a><a id="12089" href="plfa.Substitution.html#11961" class="Bound">N</a> <a id="12091" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="12093" href="plfa.Substitution.html#11974" class="Bound">τ</a><a id="12094" class="Symbol">)</a> <a id="12096" class="Symbol">{</a><a id="12097" href="plfa.Substitution.html#12069" class="Bound">A</a><a id="12098" class="Symbol">}</a>
<a id="12100" href="/Substitution/#11937" class="Function">cong-cons</a><a id="12109" class="Symbol">{</a><a id="12110" href="plfa.Substitution.html#12110" class="Bound">Γ</a><a id="12111" class="Symbol">}{</a><a id="12113" href="plfa.Substitution.html#12113" class="Bound">Δ</a><a id="12114" class="Symbol">}{</a><a id="12116" href="plfa.Substitution.html#12116" class="Bound">A</a><a id="12117" class="Symbol">}{</a><a id="12119" href="plfa.Substitution.html#12119" class="Bound">M</a><a id="12120" class="Symbol">}{</a><a id="12122" href="plfa.Substitution.html#12122" class="Bound">N</a><a id="12123" class="Symbol">}{</a><a id="12125" href="plfa.Substitution.html#12125" class="Bound">σ</a><a id="12126" class="Symbol">}{</a><a id="12128" href="plfa.Substitution.html#12128" class="Bound">τ</a><a id="12129" class="Symbol">}</a> <a id="12131" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="12136" href="plfa.Substitution.html#12136" class="Bound">st</a> <a id="12139" class="Symbol">{</a><a id="12140" href="plfa.Substitution.html#12140" class="Bound">A′</a><a id="12142" class="Symbol">}</a> <a id="12144" class="Symbol">=</a> <a id="12146" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="12161" href="plfa.Substitution.html#12177" class="Function">lemma</a>
  <a id="12169" class="Keyword">where</a>
  <a id="12177" href="/Substitution/#12177" class="Function">lemma</a> <a id="12183" class="Symbol">:</a> <a id="12185" class="Symbol">(</a><a id="12186" href="plfa.Substitution.html#12186" class="Bound">x</a> <a id="12188" class="Symbol">:</a> <a id="12190" href="plfa.Substitution.html#12110" class="Bound">Γ</a> <a id="12192" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="12194" href="plfa.Substitution.html#12116" class="Bound">A</a> <a id="12196" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="12198" href="plfa.Substitution.html#12140" class="Bound">A′</a><a id="12200" class="Symbol">)</a> <a id="12202" class="Symbol">→</a> <a id="12204" class="Symbol">(</a><a id="12205" href="plfa.Substitution.html#12119" class="Bound">M</a> <a id="12207" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="12209" href="plfa.Substitution.html#12125" class="Bound">σ</a><a id="12210" class="Symbol">)</a> <a id="12212" href="plfa.Substitution.html#12186" class="Bound">x</a> <a id="12214" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="12216" class="Symbol">(</a><a id="12217" href="plfa.Substitution.html#12119" class="Bound">M</a> <a id="12219" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="12221" href="plfa.Substitution.html#12128" class="Bound">τ</a><a id="12222" class="Symbol">)</a> <a id="12224" href="plfa.Substitution.html#12186" class="Bound">x</a>
  <a id="12228" href="/Substitution/#12177" class="Function">lemma</a> <a id="12234" href="/Untyped/#3295" class="InductiveConstructor">Z</a> <a id="12236" class="Symbol">=</a> <a id="12238" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="12245" href="/Substitution/#12177" class="Function">lemma</a> <a id="12251" class="Symbol">(</a><a id="12252" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="12254" href="plfa.Substitution.html#12254" class="Bound">x</a><a id="12255" class="Symbol">)</a> <a id="12257" class="Symbol">=</a> <a id="12259" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="12268" href="plfa.Substitution.html#12136" class="Bound">st</a> <a id="12271" href="plfa.Substitution.html#12254" class="Bound">x</a>
</pre>
<pre class="Agda"><a id="cong-seq"></a><a id="12282" href="/Substitution/#12282" class="Function">cong-seq</a> <a id="12291" class="Symbol">:</a> <a id="12293" class="Symbol">∀{</a><a id="12295" href="plfa.Substitution.html#12295" class="Bound">Γ</a> <a id="12297" href="plfa.Substitution.html#12297" class="Bound">Δ</a> <a id="12299" href="plfa.Substitution.html#12299" class="Bound">Σ</a><a id="12300" class="Symbol">}{</a><a id="12302" href="plfa.Substitution.html#12302" class="Bound">σ</a> <a id="12304" href="plfa.Substitution.html#12304" class="Bound">σ′</a> <a id="12307" class="Symbol">:</a> <a id="12309" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="12315" href="plfa.Substitution.html#12295" class="Bound">Γ</a> <a id="12317" href="plfa.Substitution.html#12297" class="Bound">Δ</a><a id="12318" class="Symbol">}{</a><a id="12320" href="plfa.Substitution.html#12320" class="Bound">τ</a> <a id="12322" href="plfa.Substitution.html#12322" class="Bound">τ′</a> <a id="12325" class="Symbol">:</a> <a id="12327" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="12333" href="plfa.Substitution.html#12297" class="Bound">Δ</a> <a id="12335" href="plfa.Substitution.html#12299" class="Bound">Σ</a><a id="12336" class="Symbol">}</a>
  <a id="12340" class="Symbol">→</a> <a id="12342" class="Symbol">(∀{</a><a id="12345" href="/Substitution/#12345" class="Bound">A</a><a id="12346" class="Symbol">}</a> <a id="12348" class="Symbol">→</a> <a id="12350" href="plfa.Substitution.html#12302" class="Bound">σ</a> <a id="12352" class="Symbol">{</a><a id="12353" href="plfa.Substitution.html#12345" class="Bound">A</a><a id="12354" class="Symbol">}</a> <a id="12356" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="12358" href="plfa.Substitution.html#12304" class="Bound">σ′</a> <a id="12361" class="Symbol">{</a><a id="12362" href="plfa.Substitution.html#12345" class="Bound">A</a><a id="12363" class="Symbol">})</a> <a id="12366" class="Symbol">→</a> <a id="12368" class="Symbol">(∀{</a><a id="12371" href="plfa.Substitution.html#12371" class="Bound">A</a><a id="12372" class="Symbol">}</a> <a id="12374" class="Symbol">→</a> <a id="12376" href="plfa.Substitution.html#12320" class="Bound">τ</a> <a id="12378" class="Symbol">{</a><a id="12379" href="plfa.Substitution.html#12371" class="Bound">A</a><a id="12380" class="Symbol">}</a> <a id="12382" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="12384" href="plfa.Substitution.html#12322" class="Bound">τ′</a> <a id="12387" class="Symbol">{</a><a id="12388" href="plfa.Substitution.html#12371" class="Bound">A</a><a id="12389" class="Symbol">})</a>
  <a id="12394" class="Symbol">→</a> <a id="12396" class="Symbol">∀{</a><a id="12398" href="/Substitution/#12398" class="Bound">A</a><a id="12399" class="Symbol">}</a> <a id="12401" class="Symbol">→</a> <a id="12403" class="Symbol">(</a><a id="12404" href="plfa.Substitution.html#12302" class="Bound">σ</a> <a id="12406" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="12408" href="plfa.Substitution.html#12320" class="Bound">τ</a><a id="12409" class="Symbol">)</a> <a id="12411" class="Symbol">{</a><a id="12412" href="plfa.Substitution.html#12398" class="Bound">A</a><a id="12413" class="Symbol">}</a> <a id="12415" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="12417" class="Symbol">(</a><a id="12418" href="plfa.Substitution.html#12304" class="Bound">σ′</a> <a id="12421" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="12423" href="plfa.Substitution.html#12322" class="Bound">τ′</a><a id="12425" class="Symbol">)</a> <a id="12427" class="Symbol">{</a><a id="12428" href="plfa.Substitution.html#12398" class="Bound">A</a><a id="12429" class="Symbol">}</a>
<a id="12431" href="/Substitution/#12282" class="Function">cong-seq</a> <a id="12440" class="Symbol">{</a><a id="12441" href="plfa.Substitution.html#12441" class="Bound">Γ</a><a id="12442" class="Symbol">}{</a><a id="12444" href="plfa.Substitution.html#12444" class="Bound">Δ</a><a id="12445" class="Symbol">}{</a><a id="12447" href="plfa.Substitution.html#12447" class="Bound">Σ</a><a id="12448" class="Symbol">}{</a><a id="12450" href="plfa.Substitution.html#12450" class="Bound">σ</a><a id="12451" class="Symbol">}{</a><a id="12453" href="plfa.Substitution.html#12453" class="Bound">σ′</a><a id="12455" class="Symbol">}{</a><a id="12457" href="plfa.Substitution.html#12457" class="Bound">τ</a><a id="12458" class="Symbol">}{</a><a id="12460" href="plfa.Substitution.html#12460" class="Bound">τ′</a><a id="12462" class="Symbol">}</a> <a id="12464" href="plfa.Substitution.html#12464" class="Bound">ss&#39;</a> <a id="12468" href="plfa.Substitution.html#12468" class="Bound">tt&#39;</a> <a id="12472" class="Symbol">{</a><a id="12473" href="plfa.Substitution.html#12473" class="Bound">A</a><a id="12474" class="Symbol">}</a> <a id="12476" class="Symbol">=</a> <a id="12478" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="12493" href="plfa.Substitution.html#12509" class="Function">lemma</a>
  <a id="12501" class="Keyword">where</a>
  <a id="12509" href="/Substitution/#12509" class="Function">lemma</a> <a id="12515" class="Symbol">:</a> <a id="12517" class="Symbol">(</a><a id="12518" href="plfa.Substitution.html#12518" class="Bound">x</a> <a id="12520" class="Symbol">:</a> <a id="12522" href="plfa.Substitution.html#12441" class="Bound">Γ</a> <a id="12524" href="/Untyped/#3259" class="Datatype Operator">∋</a> <a id="12526" href="plfa.Substitution.html#12473" class="Bound">A</a><a id="12527" class="Symbol">)</a> <a id="12529" class="Symbol">→</a> <a id="12531" class="Symbol">(</a><a id="12532" href="plfa.Substitution.html#12450" class="Bound">σ</a> <a id="12534" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="12536" href="plfa.Substitution.html#12457" class="Bound">τ</a><a id="12537" class="Symbol">)</a> <a id="12539" href="plfa.Substitution.html#12518" class="Bound">x</a> <a id="12541" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="12543" class="Symbol">(</a><a id="12544" href="plfa.Substitution.html#12453" class="Bound">σ′</a> <a id="12547" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="12549" href="plfa.Substitution.html#12460" class="Bound">τ′</a><a id="12551" class="Symbol">)</a> <a id="12553" href="plfa.Substitution.html#12518" class="Bound">x</a>
  <a id="12557" href="/Substitution/#12509" class="Function">lemma</a> <a id="12563" href="plfa.Substitution.html#12563" class="Bound">x</a> <a id="12565" class="Symbol">=</a>
     <a id="12572" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
       <a id="12585" class="Symbol">(</a><a id="12586" href="/Substitution/#12450" class="Bound">σ</a> <a id="12588" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="12590" href="plfa.Substitution.html#12457" class="Bound">τ</a><a id="12591" class="Symbol">)</a> <a id="12593" href="plfa.Substitution.html#12563" class="Bound">x</a>
     <a id="12600" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
       <a id="12611" href="/Untyped/#6697" class="Function">subst</a> <a id="12617" href="/Substitution/#12457" class="Bound">τ</a> <a id="12619" class="Symbol">(</a><a id="12620" href="plfa.Substitution.html#12450" class="Bound">σ</a> <a id="12622" href="plfa.Substitution.html#12563" class="Bound">x</a><a id="12623" class="Symbol">)</a>
     <a id="12630" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="12633" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="12638" class="Symbol">(</a><a id="12639" href="/Untyped/#6697" class="Function">subst</a> <a id="12645" href="/Substitution/#12457" class="Bound">τ</a><a id="12646" class="Symbol">)</a> <a id="12648" class="Symbol">(</a><a id="12649" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="12658" href="plfa.Substitution.html#12464" class="Bound">ss&#39;</a> <a id="12662" href="plfa.Substitution.html#12563" class="Bound">x</a><a id="12663" class="Symbol">)</a> <a id="12665" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="12674" href="/Untyped/#6697" class="Function">subst</a> <a id="12680" href="/Substitution/#12457" class="Bound">τ</a> <a id="12682" class="Symbol">(</a><a id="12683" href="plfa.Substitution.html#12453" class="Bound">σ′</a> <a id="12686" href="plfa.Substitution.html#12563" class="Bound">x</a><a id="12687" class="Symbol">)</a>
     <a id="12694" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="12697" href="/Substitution/#11198" class="Function">cong-sub</a><a id="12705" class="Symbol">{</a><a id="12706" class="Argument">M</a> <a id="12708" class="Symbol">=</a> <a id="12710" href="plfa.Substitution.html#12453" class="Bound">σ′</a> <a id="12713" href="plfa.Substitution.html#12563" class="Bound">x</a><a id="12714" class="Symbol">}</a> <a id="12716" href="plfa.Substitution.html#12468" class="Bound">tt&#39;</a> <a id="12720" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="12725" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="12734" href="/Untyped/#6697" class="Function">subst</a> <a id="12740" href="/Substitution/#12460" class="Bound">τ′</a> <a id="12743" class="Symbol">(</a><a id="12744" href="plfa.Substitution.html#12453" class="Bound">σ′</a> <a id="12747" href="plfa.Substitution.html#12563" class="Bound">x</a><a id="12748" class="Symbol">)</a>
     <a id="12755" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
       <a id="12766" class="Symbol">(</a><a id="12767" href="/Substitution/#12453" class="Bound">σ′</a> <a id="12770" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="12772" href="plfa.Substitution.html#12460" class="Bound">τ′</a><a id="12774" class="Symbol">)</a> <a id="12776" href="plfa.Substitution.html#12563" class="Bound">x</a>
     <a id="12783" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>

<h2 id="relating-rename-exts-ext-and-subst-zero-to-the-σ-algebra">Relating <code class="highlighter-rouge">rename</code>, <code class="highlighter-rouge">exts</code>, <code class="highlighter-rouge">ext</code>, and <code class="highlighter-rouge">subst-zero</code> to the σ algebra</h2>

<p>In this section we establish equations that relate <code class="highlighter-rouge">subst</code> and its
helper functions (<code class="highlighter-rouge">rename</code>, <code class="highlighter-rouge">exts</code>, <code class="highlighter-rouge">ext</code>, and <code class="highlighter-rouge">subst-zero</code>) to terms
in the σ algebra.</p>

<p>The first equation we prove is</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rename ρ M ≡ ⟪ ren ρ ⟫ M              (rename-subst-ren)
</code></pre></div></div>

<p>Because <code class="highlighter-rouge">subst</code> uses the <code class="highlighter-rouge">exts</code> function, we need the following lemma
which says that <code class="highlighter-rouge">exts</code> and <code class="highlighter-rouge">ext</code> do the same thing except that <code class="highlighter-rouge">ext</code>
works on renamings and <code class="highlighter-rouge">exts</code> works on substitutions.</p>

<pre class="Agda"><a id="ren-ext"></a><a id="13311" href="/Substitution/#13311" class="Function">ren-ext</a> <a id="13319" class="Symbol">:</a> <a id="13321" class="Symbol">∀</a> <a id="13323" class="Symbol">{</a><a id="13324" href="plfa.Substitution.html#13324" class="Bound">Γ</a> <a id="13326" href="plfa.Substitution.html#13326" class="Bound">Δ</a><a id="13327" class="Symbol">}{</a><a id="13329" href="plfa.Substitution.html#13329" class="Bound">B</a> <a id="13331" href="plfa.Substitution.html#13331" class="Bound">C</a> <a id="13333" class="Symbol">:</a> <a id="13335" href="/Untyped/#2633" class="Datatype">Type</a><a id="13339" class="Symbol">}</a> <a id="13341" class="Symbol">{</a><a id="13342" href="plfa.Substitution.html#13342" class="Bound">ρ</a> <a id="13344" class="Symbol">:</a> <a id="13346" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="13353" href="plfa.Substitution.html#13324" class="Bound">Γ</a> <a id="13355" href="plfa.Substitution.html#13326" class="Bound">Δ</a><a id="13356" class="Symbol">}</a>
        <a id="13366" class="Symbol">→</a> <a id="13368" href="/Substitution/#6524" class="Function">ren</a> <a id="13372" class="Symbol">(</a><a id="13373" href="/Untyped/#5659" class="Function">ext</a> <a id="13377" href="plfa.Substitution.html#13342" class="Bound">ρ</a> <a id="13379" class="Symbol">{</a><a id="13380" class="Argument">B</a> <a id="13382" class="Symbol">=</a> <a id="13384" href="plfa.Substitution.html#13329" class="Bound">B</a><a id="13385" class="Symbol">})</a> <a id="13388" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="13390" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="13395" class="Symbol">(</a><a id="13396" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="13400" href="plfa.Substitution.html#13342" class="Bound">ρ</a><a id="13401" class="Symbol">)</a> <a id="13403" class="Symbol">{</a><a id="13404" href="plfa.Substitution.html#13331" class="Bound">C</a><a id="13405" class="Symbol">}</a>
<a id="13407" href="/Substitution/#13311" class="Function">ren-ext</a> <a id="13415" class="Symbol">{</a><a id="13416" href="plfa.Substitution.html#13416" class="Bound">Γ</a><a id="13417" class="Symbol">}{</a><a id="13419" href="plfa.Substitution.html#13419" class="Bound">Δ</a><a id="13420" class="Symbol">}{</a><a id="13422" href="plfa.Substitution.html#13422" class="Bound">B</a><a id="13423" class="Symbol">}{</a><a id="13425" href="plfa.Substitution.html#13425" class="Bound">C</a><a id="13426" class="Symbol">}{</a><a id="13428" href="plfa.Substitution.html#13428" class="Bound">ρ</a><a id="13429" class="Symbol">}</a> <a id="13431" class="Symbol">=</a> <a id="13433" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="13448" class="Symbol">λ</a> <a id="13450" href="plfa.Substitution.html#13450" class="Bound">x</a> <a id="13452" class="Symbol">→</a> <a id="13454" href="plfa.Substitution.html#13478" class="Function">lemma</a> <a id="13460" class="Symbol">{</a><a id="13461" class="Argument">x</a> <a id="13463" class="Symbol">=</a> <a id="13465" href="plfa.Substitution.html#13450" class="Bound">x</a><a id="13466" class="Symbol">}</a>
  <a id="13470" class="Keyword">where</a>
  <a id="13478" href="/Substitution/#13478" class="Function">lemma</a> <a id="13484" class="Symbol">:</a> <a id="13486" class="Symbol">∀</a> <a id="13488" class="Symbol">{</a><a id="13489" href="plfa.Substitution.html#13489" class="Bound">x</a> <a id="13491" class="Symbol">:</a> <a id="13493" href="plfa.Substitution.html#13416" class="Bound">Γ</a> <a id="13495" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="13497" href="plfa.Substitution.html#13422" class="Bound">B</a> <a id="13499" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="13501" href="plfa.Substitution.html#13425" class="Bound">C</a><a id="13502" class="Symbol">}</a> <a id="13504" class="Symbol">→</a> <a id="13506" class="Symbol">(</a><a id="13507" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="13511" class="Symbol">(</a><a id="13512" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="13516" href="plfa.Substitution.html#13428" class="Bound">ρ</a><a id="13517" class="Symbol">))</a> <a id="13520" href="plfa.Substitution.html#13489" class="Bound">x</a> <a id="13522" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="13524" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="13529" class="Symbol">(</a><a id="13530" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="13534" href="plfa.Substitution.html#13428" class="Bound">ρ</a><a id="13535" class="Symbol">)</a> <a id="13537" href="plfa.Substitution.html#13489" class="Bound">x</a>
  <a id="13541" href="/Substitution/#13478" class="Function">lemma</a> <a id="13547" class="Symbol">{</a><a id="13548" class="Argument">x</a> <a id="13550" class="Symbol">=</a> <a id="13552" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="13553" class="Symbol">}</a> <a id="13555" class="Symbol">=</a> <a id="13557" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="13564" href="/Substitution/#13478" class="Function">lemma</a> <a id="13570" class="Symbol">{</a><a id="13571" class="Argument">x</a> <a id="13573" class="Symbol">=</a> <a id="13575" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="13577" href="plfa.Substitution.html#13577" class="Bound">x</a><a id="13578" class="Symbol">}</a> <a id="13580" class="Symbol">=</a> <a id="13582" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<p>With this lemma in hand, the proof is a straightforward induction on
the term <code class="highlighter-rouge">M</code>.</p>

<pre class="Agda"><a id="rename-subst-ren"></a><a id="13680" href="/Substitution/#13680" class="Function">rename-subst-ren</a> <a id="13697" class="Symbol">:</a> <a id="13699" class="Symbol">∀</a> <a id="13701" class="Symbol">{</a><a id="13702" href="plfa.Substitution.html#13702" class="Bound">Γ</a> <a id="13704" href="plfa.Substitution.html#13704" class="Bound">Δ</a><a id="13705" class="Symbol">}{</a><a id="13707" href="plfa.Substitution.html#13707" class="Bound">A</a><a id="13708" class="Symbol">}</a> <a id="13710" class="Symbol">{</a><a id="13711" href="plfa.Substitution.html#13711" class="Bound">ρ</a> <a id="13713" class="Symbol">:</a> <a id="13715" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="13722" href="plfa.Substitution.html#13702" class="Bound">Γ</a> <a id="13724" href="plfa.Substitution.html#13704" class="Bound">Δ</a><a id="13725" class="Symbol">}{</a><a id="13727" href="plfa.Substitution.html#13727" class="Bound">M</a> <a id="13729" class="Symbol">:</a> <a id="13731" href="plfa.Substitution.html#13702" class="Bound">Γ</a> <a id="13733" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="13735" href="plfa.Substitution.html#13707" class="Bound">A</a><a id="13736" class="Symbol">}</a>
                 <a id="13755" class="Symbol">→</a> <a id="13757" href="/Untyped/#5969" class="Function">rename</a> <a id="13764" href="/Substitution/#13711" class="Bound">ρ</a> <a id="13766" href="plfa.Substitution.html#13727" class="Bound">M</a> <a id="13768" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="13770" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="13772" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="13776" href="plfa.Substitution.html#13711" class="Bound">ρ</a> <a id="13778" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="13780" href="plfa.Substitution.html#13727" class="Bound">M</a>
<a id="13782" href="/Substitution/#13680" class="Function">rename-subst-ren</a> <a id="13799" class="Symbol">{</a><a id="13800" class="Argument">M</a> <a id="13802" class="Symbol">=</a> <a id="13804" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="13806" href="plfa.Substitution.html#13806" class="Bound">x</a><a id="13807" class="Symbol">}</a> <a id="13809" class="Symbol">=</a> <a id="13811" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="13816" href="/Substitution/#13680" class="Function">rename-subst-ren</a> <a id="13833" class="Symbol">{</a><a id="13834" class="Argument">ρ</a> <a id="13836" class="Symbol">=</a> <a id="13838" href="plfa.Substitution.html#13838" class="Bound">ρ</a><a id="13839" class="Symbol">}{</a><a id="13841" class="Argument">M</a> <a id="13843" class="Symbol">=</a> <a id="13845" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="13847" href="plfa.Substitution.html#13847" class="Bound">N</a><a id="13848" class="Symbol">}</a> <a id="13850" class="Symbol">=</a>
  <a id="13854" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
      <a id="13866" href="/Untyped/#5969" class="Function">rename</a> <a id="13873" href="/Substitution/#13838" class="Bound">ρ</a> <a id="13875" class="Symbol">(</a><a id="13876" href="plfa.Untyped.html#4116" class="InductiveConstructor Operator">ƛ</a> <a id="13878" href="plfa.Substitution.html#13847" class="Bound">N</a><a id="13879" class="Symbol">)</a>
    <a id="13885" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
      <a id="13895" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="13897" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="13904" class="Symbol">(</a><a id="13905" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="13909" href="/Substitution/#13838" class="Bound">ρ</a><a id="13910" class="Symbol">)</a> <a id="13912" href="plfa.Substitution.html#13847" class="Bound">N</a>
    <a id="13918" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="13921" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="13926" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="13929" class="Symbol">(</a><a id="13930" href="/Substitution/#13680" class="Function">rename-subst-ren</a> <a id="13947" class="Symbol">{</a><a id="13948" class="Argument">ρ</a> <a id="13950" class="Symbol">=</a> <a id="13952" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="13956" href="plfa.Substitution.html#13838" class="Bound">ρ</a><a id="13957" class="Symbol">}{</a><a id="13959" class="Argument">M</a> <a id="13961" class="Symbol">=</a> <a id="13963" href="plfa.Substitution.html#13847" class="Bound">N</a><a id="13964" class="Symbol">})</a> <a id="13967" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
      <a id="13975" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="13977" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="13979" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="13983" class="Symbol">(</a><a id="13984" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="13988" href="plfa.Substitution.html#13838" class="Bound">ρ</a><a id="13989" class="Symbol">)</a> <a id="13991" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="13993" href="plfa.Substitution.html#13847" class="Bound">N</a>
    <a id="13999" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="14002" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="14007" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="14010" class="Symbol">(</a><a id="14011" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="14020" class="Symbol">{</a><a id="14021" class="Argument">M</a> <a id="14023" class="Symbol">=</a> <a id="14025" href="plfa.Substitution.html#13847" class="Bound">N</a><a id="14026" class="Symbol">}</a> <a id="14028" href="plfa.Substitution.html#13311" class="Function">ren-ext</a> <a id="14036" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="14040" class="Symbol">)</a> <a id="14042" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
      <a id="14050" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="14052" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="14054" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="14059" class="Symbol">(</a><a id="14060" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="14064" href="plfa.Substitution.html#13838" class="Bound">ρ</a><a id="14065" class="Symbol">)</a> <a id="14067" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a>  <a id="14070" href="plfa.Substitution.html#13847" class="Bound">N</a>
    <a id="14076" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
      <a id="14086" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="14088" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="14092" href="plfa.Substitution.html#13838" class="Bound">ρ</a> <a id="14094" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="14096" class="Symbol">(</a><a id="14097" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="14099" href="plfa.Substitution.html#13847" class="Bound">N</a><a id="14100" class="Symbol">)</a>
  <a id="14104" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
<a id="14106" href="/Substitution/#13680" class="Function">rename-subst-ren</a> <a id="14123" class="Symbol">{</a><a id="14124" class="Argument">M</a> <a id="14126" class="Symbol">=</a> <a id="14128" href="plfa.Substitution.html#14128" class="Bound">L</a> <a id="14130" href="/Untyped/#4176" class="InductiveConstructor Operator">·</a> <a id="14132" href="plfa.Substitution.html#14132" class="Bound">M</a><a id="14133" class="Symbol">}</a> <a id="14135" class="Symbol">=</a> <a id="14137" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1436" class="Function">cong₂</a> <a id="14143" href="plfa.Untyped.html#4176" class="InductiveConstructor Operator">_·_</a> <a id="14147" href="plfa.Substitution.html#13680" class="Function">rename-subst-ren</a> <a id="14164" href="plfa.Substitution.html#13680" class="Function">rename-subst-ren</a>
</pre>
<p>The substitution <code class="highlighter-rouge">ren S_</code> is equivalent to <code class="highlighter-rouge">↑</code>.</p>

<pre class="Agda"><a id="ren-shift"></a><a id="14239" href="/Substitution/#14239" class="Function">ren-shift</a> <a id="14249" class="Symbol">:</a> <a id="14251" class="Symbol">∀{</a><a id="14253" href="plfa.Substitution.html#14253" class="Bound">Γ</a><a id="14254" class="Symbol">}{</a><a id="14256" href="plfa.Substitution.html#14256" class="Bound">A</a><a id="14257" class="Symbol">}{</a><a id="14259" href="plfa.Substitution.html#14259" class="Bound">B</a><a id="14260" class="Symbol">}</a>
          <a id="14272" class="Symbol">→</a> <a id="14274" href="/Substitution/#6524" class="Function">ren</a> <a id="14278" href="/Untyped/#3340" class="InductiveConstructor Operator">S_</a> <a id="14281" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="14283" href="plfa.Substitution.html#3211" class="Function">↑</a> <a id="14285" class="Symbol">{</a><a id="14286" class="Argument">A</a> <a id="14288" class="Symbol">=</a> <a id="14290" href="plfa.Substitution.html#14259" class="Bound">B</a><a id="14291" class="Symbol">}</a> <a id="14293" class="Symbol">{</a><a id="14294" href="plfa.Substitution.html#14256" class="Bound">A</a><a id="14295" class="Symbol">}</a>
<a id="14297" href="/Substitution/#14239" class="Function">ren-shift</a> <a id="14307" class="Symbol">{</a><a id="14308" href="plfa.Substitution.html#14308" class="Bound">Γ</a><a id="14309" class="Symbol">}{</a><a id="14311" href="plfa.Substitution.html#14311" class="Bound">A</a><a id="14312" class="Symbol">}{</a><a id="14314" href="plfa.Substitution.html#14314" class="Bound">B</a><a id="14315" class="Symbol">}</a> <a id="14317" class="Symbol">=</a> <a id="14319" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="14334" class="Symbol">λ</a> <a id="14336" href="plfa.Substitution.html#14336" class="Bound">x</a> <a id="14338" class="Symbol">→</a> <a id="14340" href="plfa.Substitution.html#14364" class="Function">lemma</a> <a id="14346" class="Symbol">{</a><a id="14347" class="Argument">x</a> <a id="14349" class="Symbol">=</a> <a id="14351" href="plfa.Substitution.html#14336" class="Bound">x</a><a id="14352" class="Symbol">}</a>
  <a id="14356" class="Keyword">where</a>
  <a id="14364" href="/Substitution/#14364" class="Function">lemma</a> <a id="14370" class="Symbol">:</a> <a id="14372" class="Symbol">∀</a> <a id="14374" class="Symbol">{</a><a id="14375" href="plfa.Substitution.html#14375" class="Bound">x</a> <a id="14377" class="Symbol">:</a> <a id="14379" href="plfa.Substitution.html#14308" class="Bound">Γ</a> <a id="14381" href="/Untyped/#3259" class="Datatype Operator">∋</a> <a id="14383" href="plfa.Substitution.html#14311" class="Bound">A</a><a id="14384" class="Symbol">}</a> <a id="14386" class="Symbol">→</a> <a id="14388" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="14392" class="Symbol">(</a><a id="14393" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a><a id="14395" class="Symbol">{</a><a id="14396" class="Argument">B</a> <a id="14398" class="Symbol">=</a> <a id="14400" href="plfa.Substitution.html#14314" class="Bound">B</a><a id="14401" class="Symbol">})</a> <a id="14404" href="plfa.Substitution.html#14375" class="Bound">x</a> <a id="14406" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="14408" href="plfa.Substitution.html#3211" class="Function">↑</a> <a id="14410" class="Symbol">{</a><a id="14411" class="Argument">A</a> <a id="14413" class="Symbol">=</a> <a id="14415" href="plfa.Substitution.html#14314" class="Bound">B</a><a id="14416" class="Symbol">}</a> <a id="14418" href="plfa.Substitution.html#14375" class="Bound">x</a>
  <a id="14422" href="/Substitution/#14364" class="Function">lemma</a> <a id="14428" class="Symbol">{</a><a id="14429" class="Argument">x</a> <a id="14431" class="Symbol">=</a> <a id="14433" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="14434" class="Symbol">}</a> <a id="14436" class="Symbol">=</a> <a id="14438" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="14445" href="/Substitution/#14364" class="Function">lemma</a> <a id="14451" class="Symbol">{</a><a id="14452" class="Argument">x</a> <a id="14454" class="Symbol">=</a> <a id="14456" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="14458" href="plfa.Substitution.html#14458" class="Bound">x</a><a id="14459" class="Symbol">}</a> <a id="14461" class="Symbol">=</a> <a id="14463" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<p>The substitution <code class="highlighter-rouge">rename S_ M</code> is equivalent to shifting: <code class="highlighter-rouge">⟪ ↑ ⟫ M</code>.</p>

<pre class="Agda"><a id="rename-shift"></a><a id="14547" href="/Substitution/#14547" class="Function">rename-shift</a> <a id="14560" class="Symbol">:</a> <a id="14562" class="Symbol">∀{</a><a id="14564" href="plfa.Substitution.html#14564" class="Bound">Γ</a><a id="14565" class="Symbol">}</a> <a id="14567" class="Symbol">{</a><a id="14568" href="plfa.Substitution.html#14568" class="Bound">A</a><a id="14569" class="Symbol">}</a> <a id="14571" class="Symbol">{</a><a id="14572" href="plfa.Substitution.html#14572" class="Bound">B</a><a id="14573" class="Symbol">}</a> <a id="14575" class="Symbol">{</a><a id="14576" href="plfa.Substitution.html#14576" class="Bound">M</a> <a id="14578" class="Symbol">:</a> <a id="14580" href="plfa.Substitution.html#14564" class="Bound">Γ</a> <a id="14582" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="14584" href="plfa.Substitution.html#14568" class="Bound">A</a><a id="14585" class="Symbol">}</a>
             <a id="14600" class="Symbol">→</a> <a id="14602" href="/Untyped/#5969" class="Function">rename</a> <a id="14609" class="Symbol">(</a><a id="14610" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a><a id="14612" class="Symbol">{</a><a id="14613" class="Argument">B</a> <a id="14615" class="Symbol">=</a> <a id="14617" href="/Substitution/#14572" class="Bound">B</a><a id="14618" class="Symbol">})</a> <a id="14621" href="plfa.Substitution.html#14576" class="Bound">M</a> <a id="14623" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="14625" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="14627" href="plfa.Substitution.html#3211" class="Function">↑</a> <a id="14629" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="14631" href="plfa.Substitution.html#14576" class="Bound">M</a>
<a id="14633" href="/Substitution/#14547" class="Function">rename-shift</a><a id="14645" class="Symbol">{</a><a id="14646" href="plfa.Substitution.html#14646" class="Bound">Γ</a><a id="14647" class="Symbol">}{</a><a id="14649" href="plfa.Substitution.html#14649" class="Bound">A</a><a id="14650" class="Symbol">}{</a><a id="14652" href="plfa.Substitution.html#14652" class="Bound">B</a><a id="14653" class="Symbol">}{</a><a id="14655" href="plfa.Substitution.html#14655" class="Bound">M</a><a id="14656" class="Symbol">}</a> <a id="14658" class="Symbol">=</a>
  <a id="14662" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
    <a id="14672" href="/Untyped/#5969" class="Function">rename</a> <a id="14679" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="14682" href="/Substitution/#14655" class="Bound">M</a>
  <a id="14686" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="14689" href="/Substitution/#13680" class="Function">rename-subst-ren</a> <a id="14706" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
    <a id="14712" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="14714" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="14718" href="/Untyped/#3340" class="InductiveConstructor Operator">S_</a> <a id="14721" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="14723" href="plfa.Substitution.html#14655" class="Bound">M</a>
  <a id="14727" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="14730" href="/Substitution/#11198" class="Function">cong-sub</a><a id="14738" class="Symbol">{</a><a id="14739" class="Argument">M</a> <a id="14741" class="Symbol">=</a> <a id="14743" href="plfa.Substitution.html#14655" class="Bound">M</a><a id="14744" class="Symbol">}</a> <a id="14746" href="plfa.Substitution.html#14239" class="Function">ren-shift</a> <a id="14756" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="14761" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
    <a id="14767" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="14769" href="plfa.Substitution.html#3211" class="Function">↑</a> <a id="14771" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="14773" href="plfa.Substitution.html#14655" class="Bound">M</a>
  <a id="14777" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>
<p>Next we prove the equation <code class="highlighter-rouge">exts-cons-shift</code>, which states that <code class="highlighter-rouge">exts</code>
is equivalent to cons’ing Z onto the sequence formed by applying <code class="highlighter-rouge">σ</code>
and then shifting. The proof is by case analysis on the variable <code class="highlighter-rouge">x</code>,
using <code class="highlighter-rouge">rename-subst-ren</code> for when <code class="highlighter-rouge">x = S y</code>.</p>

<pre class="Agda"><a id="exts-cons-shift"></a><a id="15044" href="/Substitution/#15044" class="Function">exts-cons-shift</a> <a id="15060" class="Symbol">:</a> <a id="15062" class="Symbol">∀{</a><a id="15064" href="plfa.Substitution.html#15064" class="Bound">Γ</a> <a id="15066" href="plfa.Substitution.html#15066" class="Bound">Δ</a><a id="15067" class="Symbol">}</a> <a id="15069" class="Symbol">{</a><a id="15070" href="plfa.Substitution.html#15070" class="Bound">A</a> <a id="15072" href="plfa.Substitution.html#15072" class="Bound">B</a><a id="15073" class="Symbol">}</a> <a id="15075" class="Symbol">{</a><a id="15076" href="plfa.Substitution.html#15076" class="Bound">σ</a> <a id="15078" class="Symbol">:</a> <a id="15080" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="15086" href="plfa.Substitution.html#15064" class="Bound">Γ</a> <a id="15088" href="plfa.Substitution.html#15066" class="Bound">Δ</a><a id="15089" class="Symbol">}</a>
                <a id="15107" class="Symbol">→</a> <a id="15109" href="/Untyped/#6405" class="Function">exts</a> <a id="15114" href="/Substitution/#15076" class="Bound">σ</a> <a id="15116" class="Symbol">{</a><a id="15117" href="plfa.Substitution.html#15070" class="Bound">A</a><a id="15118" class="Symbol">}</a> <a id="15120" class="Symbol">{</a><a id="15121" href="plfa.Substitution.html#15072" class="Bound">B</a><a id="15122" class="Symbol">}</a> <a id="15124" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="15126" class="Symbol">(</a><a id="15127" href="plfa.Untyped.html#4064" class="InductiveConstructor Operator">`</a> <a id="15129" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a> <a id="15131" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="15133" class="Symbol">(</a><a id="15134" href="plfa.Substitution.html#15076" class="Bound">σ</a> <a id="15136" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="15138" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="15139" class="Symbol">))</a>
<a id="15142" href="/Substitution/#15044" class="Function">exts-cons-shift</a> <a id="15158" class="Symbol">=</a> <a id="15160" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="15175" class="Symbol">λ</a> <a id="15177" href="plfa.Substitution.html#15177" class="Bound">x</a> <a id="15179" class="Symbol">→</a> <a id="15181" href="plfa.Substitution.html#15204" class="Function">lemma</a><a id="15186" class="Symbol">{</a><a id="15187" class="Argument">x</a> <a id="15189" class="Symbol">=</a> <a id="15191" href="plfa.Substitution.html#15177" class="Bound">x</a><a id="15192" class="Symbol">}</a>
  <a id="15196" class="Keyword">where</a>
  <a id="15204" href="/Substitution/#15204" class="Function">lemma</a> <a id="15210" class="Symbol">:</a> <a id="15212" class="Symbol">∀{</a><a id="15214" href="plfa.Substitution.html#15214" class="Bound">Γ</a> <a id="15216" href="plfa.Substitution.html#15216" class="Bound">Δ</a><a id="15217" class="Symbol">}</a> <a id="15219" class="Symbol">{</a><a id="15220" href="plfa.Substitution.html#15220" class="Bound">A</a> <a id="15222" href="plfa.Substitution.html#15222" class="Bound">B</a><a id="15223" class="Symbol">}</a> <a id="15225" class="Symbol">{</a><a id="15226" href="plfa.Substitution.html#15226" class="Bound">σ</a> <a id="15228" class="Symbol">:</a> <a id="15230" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="15236" href="plfa.Substitution.html#15214" class="Bound">Γ</a> <a id="15238" href="plfa.Substitution.html#15216" class="Bound">Δ</a><a id="15239" class="Symbol">}</a> <a id="15241" class="Symbol">{</a><a id="15242" href="plfa.Substitution.html#15242" class="Bound">x</a> <a id="15244" class="Symbol">:</a> <a id="15246" href="plfa.Substitution.html#15214" class="Bound">Γ</a> <a id="15248" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="15250" href="plfa.Substitution.html#15222" class="Bound">B</a> <a id="15252" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="15254" href="plfa.Substitution.html#15220" class="Bound">A</a><a id="15255" class="Symbol">}</a>
                  <a id="15275" class="Symbol">→</a> <a id="15277" href="/Untyped/#6405" class="Function">exts</a> <a id="15282" href="/Substitution/#15226" class="Bound">σ</a> <a id="15284" href="plfa.Substitution.html#15242" class="Bound">x</a> <a id="15286" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="15288" class="Symbol">(</a><a id="15289" href="plfa.Untyped.html#4064" class="InductiveConstructor Operator">`</a> <a id="15291" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a> <a id="15293" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="15295" class="Symbol">(</a><a id="15296" href="plfa.Substitution.html#15226" class="Bound">σ</a> <a id="15298" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="15300" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="15301" class="Symbol">))</a> <a id="15304" href="plfa.Substitution.html#15242" class="Bound">x</a>
  <a id="15308" href="/Substitution/#15204" class="Function">lemma</a> <a id="15314" class="Symbol">{</a><a id="15315" class="Argument">x</a> <a id="15317" class="Symbol">=</a> <a id="15319" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="15320" class="Symbol">}</a> <a id="15322" class="Symbol">=</a> <a id="15324" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="15331" href="/Substitution/#15204" class="Function">lemma</a> <a id="15337" class="Symbol">{</a><a id="15338" class="Argument">x</a> <a id="15340" class="Symbol">=</a> <a id="15342" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="15344" href="plfa.Substitution.html#15344" class="Bound">y</a><a id="15345" class="Symbol">}</a> <a id="15347" class="Symbol">=</a> <a id="15349" href="plfa.Substitution.html#13680" class="Function">rename-subst-ren</a>
</pre>
<p>As a corollary, we have a similar correspondence for <code class="highlighter-rouge">ren (ext ρ)</code>.</p>

<pre class="Agda"><a id="ext-cons-Z-shift"></a><a id="15444" href="/Substitution/#15444" class="Function">ext-cons-Z-shift</a> <a id="15461" class="Symbol">:</a> <a id="15463" class="Symbol">∀{</a><a id="15465" href="plfa.Substitution.html#15465" class="Bound">Γ</a> <a id="15467" href="plfa.Substitution.html#15467" class="Bound">Δ</a><a id="15468" class="Symbol">}</a> <a id="15470" class="Symbol">{</a><a id="15471" href="plfa.Substitution.html#15471" class="Bound">ρ</a> <a id="15473" class="Symbol">:</a> <a id="15475" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="15482" href="plfa.Substitution.html#15465" class="Bound">Γ</a> <a id="15484" href="plfa.Substitution.html#15467" class="Bound">Δ</a><a id="15485" class="Symbol">}{</a><a id="15487" href="plfa.Substitution.html#15487" class="Bound">A</a><a id="15488" class="Symbol">}{</a><a id="15490" href="plfa.Substitution.html#15490" class="Bound">B</a><a id="15491" class="Symbol">}</a>
                 <a id="15510" class="Symbol">→</a> <a id="15512" href="/Substitution/#6524" class="Function">ren</a> <a id="15516" class="Symbol">(</a><a id="15517" href="/Untyped/#5659" class="Function">ext</a> <a id="15521" href="plfa.Substitution.html#15471" class="Bound">ρ</a> <a id="15523" class="Symbol">{</a><a id="15524" class="Argument">B</a> <a id="15526" class="Symbol">=</a> <a id="15528" href="plfa.Substitution.html#15490" class="Bound">B</a><a id="15529" class="Symbol">})</a> <a id="15532" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="15534" class="Symbol">(</a><a id="15535" href="plfa.Untyped.html#4064" class="InductiveConstructor Operator">`</a> <a id="15537" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a> <a id="15539" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="15541" class="Symbol">(</a><a id="15542" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="15546" href="plfa.Substitution.html#15471" class="Bound">ρ</a> <a id="15548" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="15550" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="15551" class="Symbol">))</a> <a id="15554" class="Symbol">{</a><a id="15555" href="plfa.Substitution.html#15487" class="Bound">A</a><a id="15556" class="Symbol">}</a>
<a id="15558" href="/Substitution/#15444" class="Function">ext-cons-Z-shift</a> <a id="15575" class="Symbol">{</a><a id="15576" href="plfa.Substitution.html#15576" class="Bound">Γ</a><a id="15577" class="Symbol">}{</a><a id="15579" href="plfa.Substitution.html#15579" class="Bound">Δ</a><a id="15580" class="Symbol">}{</a><a id="15582" href="plfa.Substitution.html#15582" class="Bound">ρ</a><a id="15583" class="Symbol">}{</a><a id="15585" href="plfa.Substitution.html#15585" class="Bound">A</a><a id="15586" class="Symbol">}{</a><a id="15588" href="plfa.Substitution.html#15588" class="Bound">B</a><a id="15589" class="Symbol">}</a> <a id="15591" class="Symbol">=</a>
  <a id="15595" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
    <a id="15605" href="/Substitution/#6524" class="Function">ren</a> <a id="15609" class="Symbol">(</a><a id="15610" href="/Untyped/#5659" class="Function">ext</a> <a id="15614" href="plfa.Substitution.html#15582" class="Bound">ρ</a><a id="15615" class="Symbol">)</a>
  <a id="15619" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="15622" href="/Substitution/#13311" class="Function">ren-ext</a> <a id="15630" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
    <a id="15636" href="/Untyped/#6405" class="Function">exts</a> <a id="15641" class="Symbol">(</a><a id="15642" href="/Substitution/#6524" class="Function">ren</a> <a id="15646" href="plfa.Substitution.html#15582" class="Bound">ρ</a><a id="15647" class="Symbol">)</a>
  <a id="15651" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="15654" href="/Substitution/#15044" class="Function">exts-cons-shift</a><a id="15669" class="Symbol">{</a><a id="15670" class="Argument">σ</a> <a id="15672" class="Symbol">=</a> <a id="15674" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="15678" href="plfa.Substitution.html#15582" class="Bound">ρ</a><a id="15679" class="Symbol">}</a> <a id="15681" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
   <a id="15686" class="Symbol">((</a><a id="15688" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="15690" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="15691" class="Symbol">)</a> <a id="15693" href="/Substitution/#3453" class="Function Operator">•</a> <a id="15695" class="Symbol">(</a><a id="15696" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="15700" href="plfa.Substitution.html#15582" class="Bound">ρ</a> <a id="15702" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="15704" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="15705" class="Symbol">))</a>
  <a id="15710" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>
<p>Finally, the <code class="highlighter-rouge">subst-zero M</code> substitution is equivalent to cons’ing <code class="highlighter-rouge">M</code>
onto the identity substitution.</p>

<pre class="Agda"><a id="subst-Z-cons-ids"></a><a id="15825" href="/Substitution/#15825" class="Function">subst-Z-cons-ids</a> <a id="15842" class="Symbol">:</a> <a id="15844" class="Symbol">∀{</a><a id="15846" href="plfa.Substitution.html#15846" class="Bound">Γ</a><a id="15847" class="Symbol">}{</a><a id="15849" href="plfa.Substitution.html#15849" class="Bound">A</a> <a id="15851" href="plfa.Substitution.html#15851" class="Bound">B</a> <a id="15853" class="Symbol">:</a> <a id="15855" href="/Untyped/#2633" class="Datatype">Type</a><a id="15859" class="Symbol">}{</a><a id="15861" href="plfa.Substitution.html#15861" class="Bound">M</a> <a id="15863" class="Symbol">:</a> <a id="15865" href="plfa.Substitution.html#15846" class="Bound">Γ</a> <a id="15867" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="15869" href="plfa.Substitution.html#15851" class="Bound">B</a><a id="15870" class="Symbol">}</a>
                 <a id="15889" class="Symbol">→</a> <a id="15891" href="/Untyped/#7109" class="Function">subst-zero</a> <a id="15902" href="/Substitution/#15861" class="Bound">M</a> <a id="15904" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="15906" class="Symbol">(</a><a id="15907" href="plfa.Substitution.html#15861" class="Bound">M</a> <a id="15909" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="15911" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="15914" class="Symbol">)</a> <a id="15916" class="Symbol">{</a><a id="15917" href="plfa.Substitution.html#15849" class="Bound">A</a><a id="15918" class="Symbol">}</a>
<a id="15920" href="/Substitution/#15825" class="Function">subst-Z-cons-ids</a> <a id="15937" class="Symbol">=</a> <a id="15939" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="15954" class="Symbol">λ</a> <a id="15956" href="plfa.Substitution.html#15956" class="Bound">x</a> <a id="15958" class="Symbol">→</a> <a id="15960" href="plfa.Substitution.html#15984" class="Function">lemma</a> <a id="15966" class="Symbol">{</a><a id="15967" class="Argument">x</a> <a id="15969" class="Symbol">=</a> <a id="15971" href="plfa.Substitution.html#15956" class="Bound">x</a><a id="15972" class="Symbol">}</a>
  <a id="15976" class="Keyword">where</a>
  <a id="15984" href="/Substitution/#15984" class="Function">lemma</a> <a id="15990" class="Symbol">:</a> <a id="15992" class="Symbol">∀{</a><a id="15994" href="plfa.Substitution.html#15994" class="Bound">Γ</a><a id="15995" class="Symbol">}{</a><a id="15997" href="plfa.Substitution.html#15997" class="Bound">A</a> <a id="15999" href="plfa.Substitution.html#15999" class="Bound">B</a> <a id="16001" class="Symbol">:</a> <a id="16003" href="/Untyped/#2633" class="Datatype">Type</a><a id="16007" class="Symbol">}{</a><a id="16009" href="plfa.Substitution.html#16009" class="Bound">M</a> <a id="16011" class="Symbol">:</a> <a id="16013" href="plfa.Substitution.html#15994" class="Bound">Γ</a> <a id="16015" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="16017" href="plfa.Substitution.html#15999" class="Bound">B</a><a id="16018" class="Symbol">}{</a><a id="16020" href="plfa.Substitution.html#16020" class="Bound">x</a> <a id="16022" class="Symbol">:</a> <a id="16024" href="plfa.Substitution.html#15994" class="Bound">Γ</a> <a id="16026" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="16028" href="plfa.Substitution.html#15999" class="Bound">B</a> <a id="16030" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="16032" href="plfa.Substitution.html#15997" class="Bound">A</a><a id="16033" class="Symbol">}</a>
                      <a id="16057" class="Symbol">→</a> <a id="16059" href="/Untyped/#7109" class="Function">subst-zero</a> <a id="16070" href="/Substitution/#16009" class="Bound">M</a> <a id="16072" href="plfa.Substitution.html#16020" class="Bound">x</a> <a id="16074" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="16076" class="Symbol">(</a><a id="16077" href="plfa.Substitution.html#16009" class="Bound">M</a> <a id="16079" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="16081" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="16084" class="Symbol">)</a> <a id="16086" href="plfa.Substitution.html#16020" class="Bound">x</a>
  <a id="16090" href="/Substitution/#15984" class="Function">lemma</a> <a id="16096" class="Symbol">{</a><a id="16097" class="Argument">x</a> <a id="16099" class="Symbol">=</a> <a id="16101" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="16102" class="Symbol">}</a> <a id="16104" class="Symbol">=</a> <a id="16106" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="16113" href="/Substitution/#15984" class="Function">lemma</a> <a id="16119" class="Symbol">{</a><a id="16120" class="Argument">x</a> <a id="16122" class="Symbol">=</a> <a id="16124" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="16126" href="plfa.Substitution.html#16126" class="Bound">x</a><a id="16127" class="Symbol">}</a> <a id="16129" class="Symbol">=</a> <a id="16131" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>

<h2 id="proofs-of-sub-abs-sub-id-and-rename-id">Proofs of sub-abs, sub-id, and rename-id</h2>

<p>The equation <code class="highlighter-rouge">sub-abs</code> follows immediately from the equation
<code class="highlighter-rouge">exts-cons-shift</code>.</p>

<pre class="Agda"><a id="sub-abs"></a><a id="16272" href="/Substitution/#16272" class="Function">sub-abs</a> <a id="16280" class="Symbol">:</a> <a id="16282" class="Symbol">∀{</a><a id="16284" href="plfa.Substitution.html#16284" class="Bound">Γ</a> <a id="16286" href="plfa.Substitution.html#16286" class="Bound">Δ</a><a id="16287" class="Symbol">}</a> <a id="16289" class="Symbol">{</a><a id="16290" href="plfa.Substitution.html#16290" class="Bound">σ</a> <a id="16292" class="Symbol">:</a> <a id="16294" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="16300" href="plfa.Substitution.html#16284" class="Bound">Γ</a> <a id="16302" href="plfa.Substitution.html#16286" class="Bound">Δ</a><a id="16303" class="Symbol">}</a> <a id="16305" class="Symbol">{</a><a id="16306" href="plfa.Substitution.html#16306" class="Bound">N</a> <a id="16308" class="Symbol">:</a> <a id="16310" href="plfa.Substitution.html#16284" class="Bound">Γ</a> <a id="16312" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="16314" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a> <a id="16316" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="16318" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="16319" class="Symbol">}</a>
        <a id="16329" class="Symbol">→</a> <a id="16331" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="16333" href="plfa.Substitution.html#16290" class="Bound">σ</a> <a id="16335" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="16337" class="Symbol">(</a><a id="16338" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="16340" href="plfa.Substitution.html#16306" class="Bound">N</a><a id="16341" class="Symbol">)</a> <a id="16343" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="16345" href="plfa.Untyped.html#4116" class="InductiveConstructor Operator">ƛ</a> <a id="16347" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="16349" class="Symbol">(</a><a id="16350" href="plfa.Untyped.html#4064" class="InductiveConstructor Operator">`</a> <a id="16352" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="16353" class="Symbol">)</a> <a id="16355" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="16357" class="Symbol">(</a><a id="16358" href="plfa.Substitution.html#16290" class="Bound">σ</a> <a id="16360" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="16362" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="16363" class="Symbol">)</a> <a id="16365" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="16367" href="plfa.Substitution.html#16306" class="Bound">N</a>
<a id="16369" href="/Substitution/#16272" class="Function">sub-abs</a> <a id="16377" class="Symbol">{</a><a id="16378" class="Argument">σ</a> <a id="16380" class="Symbol">=</a> <a id="16382" href="plfa.Substitution.html#16382" class="Bound">σ</a><a id="16383" class="Symbol">}{</a><a id="16385" class="Argument">N</a> <a id="16387" class="Symbol">=</a> <a id="16389" href="plfa.Substitution.html#16389" class="Bound">N</a><a id="16390" class="Symbol">}</a> <a id="16392" class="Symbol">=</a>
   <a id="16397" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
     <a id="16408" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="16410" href="plfa.Substitution.html#16382" class="Bound">σ</a> <a id="16412" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="16414" class="Symbol">(</a><a id="16415" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="16417" href="plfa.Substitution.html#16389" class="Bound">N</a><a id="16418" class="Symbol">)</a>
   <a id="16423" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
     <a id="16432" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="16434" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="16436" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="16441" href="plfa.Substitution.html#16382" class="Bound">σ</a> <a id="16443" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="16445" href="plfa.Substitution.html#16389" class="Bound">N</a>
   <a id="16450" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="16453" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="16458" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="16461" class="Symbol">(</a><a id="16462" href="/Substitution/#11198" class="Function">cong-sub</a><a id="16470" class="Symbol">{</a><a id="16471" class="Argument">M</a> <a id="16473" class="Symbol">=</a> <a id="16475" href="plfa.Substitution.html#16389" class="Bound">N</a><a id="16476" class="Symbol">}</a> <a id="16478" href="plfa.Substitution.html#15044" class="Function">exts-cons-shift</a> <a id="16494" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="16498" class="Symbol">)</a> <a id="16500" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="16507" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="16509" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="16511" class="Symbol">(</a><a id="16512" href="plfa.Untyped.html#4064" class="InductiveConstructor Operator">`</a> <a id="16514" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="16515" class="Symbol">)</a> <a id="16517" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="16519" class="Symbol">(</a><a id="16520" href="plfa.Substitution.html#16382" class="Bound">σ</a> <a id="16522" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="16524" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="16525" class="Symbol">)</a> <a id="16527" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="16529" href="plfa.Substitution.html#16389" class="Bound">N</a>
   <a id="16534" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>
<p>The proof of <code class="highlighter-rouge">sub-id</code> requires the following lemma which says that
extending the identity substitution produces the identity
substitution.</p>

<pre class="Agda"><a id="exts-ids"></a><a id="16685" href="/Substitution/#16685" class="Function">exts-ids</a> <a id="16694" class="Symbol">:</a> <a id="16696" class="Symbol">∀{</a><a id="16698" href="plfa.Substitution.html#16698" class="Bound">Γ</a><a id="16699" class="Symbol">}{</a><a id="16701" href="plfa.Substitution.html#16701" class="Bound">A</a> <a id="16703" href="plfa.Substitution.html#16703" class="Bound">B</a><a id="16704" class="Symbol">}</a>
         <a id="16715" class="Symbol">→</a> <a id="16717" href="/Untyped/#6405" class="Function">exts</a> <a id="16722" href="/Substitution/#3072" class="Function">ids</a> <a id="16726" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="16728" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="16732" class="Symbol">{</a><a id="16733" href="plfa.Substitution.html#16698" class="Bound">Γ</a> <a id="16735" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="16737" href="plfa.Substitution.html#16703" class="Bound">B</a><a id="16738" class="Symbol">}</a> <a id="16740" class="Symbol">{</a><a id="16741" href="plfa.Substitution.html#16701" class="Bound">A</a><a id="16742" class="Symbol">}</a>
<a id="16744" href="/Substitution/#16685" class="Function">exts-ids</a> <a id="16753" class="Symbol">{</a><a id="16754" href="plfa.Substitution.html#16754" class="Bound">Γ</a><a id="16755" class="Symbol">}{</a><a id="16757" href="plfa.Substitution.html#16757" class="Bound">A</a><a id="16758" class="Symbol">}{</a><a id="16760" href="plfa.Substitution.html#16760" class="Bound">B</a><a id="16761" class="Symbol">}</a> <a id="16763" class="Symbol">=</a> <a id="16765" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="16780" href="plfa.Substitution.html#16794" class="Function">lemma</a>
  <a id="16788" class="Keyword">where</a> <a id="16794" href="/Substitution/#16794" class="Function">lemma</a> <a id="16800" class="Symbol">:</a> <a id="16802" class="Symbol">(</a><a id="16803" href="plfa.Substitution.html#16803" class="Bound">x</a> <a id="16805" class="Symbol">:</a> <a id="16807" href="plfa.Substitution.html#16754" class="Bound">Γ</a> <a id="16809" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="16811" href="plfa.Substitution.html#16760" class="Bound">B</a> <a id="16813" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="16815" href="plfa.Substitution.html#16757" class="Bound">A</a><a id="16816" class="Symbol">)</a> <a id="16818" class="Symbol">→</a> <a id="16820" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="16825" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="16829" href="plfa.Substitution.html#16803" class="Bound">x</a> <a id="16831" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="16833" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="16837" href="plfa.Substitution.html#16803" class="Bound">x</a>
        <a id="16847" href="/Substitution/#16794" class="Function">lemma</a> <a id="16853" href="/Untyped/#3295" class="InductiveConstructor">Z</a> <a id="16855" class="Symbol">=</a> <a id="16857" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
        <a id="16870" href="/Substitution/#16794" class="Function">lemma</a> <a id="16876" class="Symbol">(</a><a id="16877" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="16879" href="plfa.Substitution.html#16879" class="Bound">x</a><a id="16880" class="Symbol">)</a> <a id="16882" class="Symbol">=</a> <a id="16884" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<p>The proof of <code class="highlighter-rouge">⟪ ids ⟫ M ≡ M</code> now follows easily by induction on <code class="highlighter-rouge">M</code>,
using <code class="highlighter-rouge">exts-ids</code> in the case for <code class="highlighter-rouge">M ≡ ƛ N</code>.</p>

<pre class="Agda"><a id="sub-id"></a><a id="17012" href="/Substitution/#17012" class="Function">sub-id</a> <a id="17019" class="Symbol">:</a> <a id="17021" class="Symbol">∀{</a><a id="17023" href="plfa.Substitution.html#17023" class="Bound">Γ</a><a id="17024" class="Symbol">}</a> <a id="17026" class="Symbol">{</a><a id="17027" href="plfa.Substitution.html#17027" class="Bound">A</a><a id="17028" class="Symbol">}</a> <a id="17030" class="Symbol">{</a><a id="17031" href="plfa.Substitution.html#17031" class="Bound">M</a> <a id="17033" class="Symbol">:</a> <a id="17035" href="plfa.Substitution.html#17023" class="Bound">Γ</a> <a id="17037" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="17039" href="plfa.Substitution.html#17027" class="Bound">A</a><a id="17040" class="Symbol">}</a>
         <a id="17051" class="Symbol">→</a> <a id="17053" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="17055" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="17059" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="17061" href="plfa.Substitution.html#17031" class="Bound">M</a> <a id="17063" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="17065" href="plfa.Substitution.html#17031" class="Bound">M</a>
<a id="17067" href="/Substitution/#17012" class="Function">sub-id</a> <a id="17074" class="Symbol">{</a><a id="17075" class="Argument">M</a> <a id="17077" class="Symbol">=</a> <a id="17079" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="17081" href="plfa.Substitution.html#17081" class="Bound">x</a><a id="17082" class="Symbol">}</a> <a id="17084" class="Symbol">=</a> <a id="17086" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="17091" href="/Substitution/#17012" class="Function">sub-id</a> <a id="17098" class="Symbol">{</a><a id="17099" class="Argument">M</a> <a id="17101" class="Symbol">=</a> <a id="17103" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="17105" href="plfa.Substitution.html#17105" class="Bound">N</a><a id="17106" class="Symbol">}</a> <a id="17108" class="Symbol">=</a>
   <a id="17113" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
     <a id="17124" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="17126" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="17130" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="17132" class="Symbol">(</a><a id="17133" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="17135" href="plfa.Substitution.html#17105" class="Bound">N</a><a id="17136" class="Symbol">)</a>
   <a id="17141" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
     <a id="17150" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="17152" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="17154" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="17159" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="17163" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="17165" href="plfa.Substitution.html#17105" class="Bound">N</a>
   <a id="17170" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="17173" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="17178" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="17181" class="Symbol">(</a><a id="17182" href="/Substitution/#11198" class="Function">cong-sub</a><a id="17190" class="Symbol">{</a><a id="17191" class="Argument">M</a> <a id="17193" class="Symbol">=</a> <a id="17195" href="plfa.Substitution.html#17105" class="Bound">N</a><a id="17196" class="Symbol">}</a> <a id="17198" href="plfa.Substitution.html#16685" class="Function">exts-ids</a> <a id="17207" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="17211" class="Symbol">)</a>  <a id="17214" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="17221" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="17223" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="17225" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="17229" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="17231" href="plfa.Substitution.html#17105" class="Bound">N</a>
   <a id="17236" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="17239" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="17244" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="17247" href="/Substitution/#17012" class="Function">sub-id</a> <a id="17254" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="17261" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="17263" href="/Substitution/#17105" class="Bound">N</a>
   <a id="17268" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
<a id="17270" href="/Substitution/#17012" class="Function">sub-id</a> <a id="17277" class="Symbol">{</a><a id="17278" class="Argument">M</a> <a id="17280" class="Symbol">=</a> <a id="17282" href="plfa.Substitution.html#17282" class="Bound">L</a> <a id="17284" href="/Untyped/#4176" class="InductiveConstructor Operator">·</a> <a id="17286" href="plfa.Substitution.html#17286" class="Bound">M</a><a id="17287" class="Symbol">}</a> <a id="17289" class="Symbol">=</a> <a id="17291" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1436" class="Function">cong₂</a> <a id="17297" href="plfa.Untyped.html#4176" class="InductiveConstructor Operator">_·_</a> <a id="17301" href="plfa.Substitution.html#17012" class="Function">sub-id</a> <a id="17308" href="plfa.Substitution.html#17012" class="Function">sub-id</a>
</pre>
<p>The <code class="highlighter-rouge">rename-id</code> equation is a corollary is <code class="highlighter-rouge">sub-id</code>.</p>

<pre class="Agda"><a id="rename-id"></a><a id="17378" href="/Substitution/#17378" class="Function">rename-id</a> <a id="17388" class="Symbol">:</a> <a id="17390" class="Symbol">∀</a> <a id="17392" class="Symbol">{</a><a id="17393" href="plfa.Substitution.html#17393" class="Bound">Γ</a><a id="17394" class="Symbol">}{</a><a id="17396" href="plfa.Substitution.html#17396" class="Bound">A</a><a id="17397" class="Symbol">}</a> <a id="17399" class="Symbol">{</a><a id="17400" href="plfa.Substitution.html#17400" class="Bound">M</a> <a id="17402" class="Symbol">:</a> <a id="17404" href="plfa.Substitution.html#17393" class="Bound">Γ</a> <a id="17406" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="17408" href="plfa.Substitution.html#17396" class="Bound">A</a><a id="17409" class="Symbol">}</a>
  <a id="17413" class="Symbol">→</a> <a id="17415" href="/Untyped/#5969" class="Function">rename</a> <a id="17422" class="Symbol">(λ</a> <a id="17425" class="Symbol">{</a><a id="17426" href="/Substitution/#17426" class="Bound">A</a><a id="17427" class="Symbol">}</a> <a id="17429" href="plfa.Substitution.html#17429" class="Bound">x</a> <a id="17431" class="Symbol">→</a> <a id="17433" href="plfa.Substitution.html#17429" class="Bound">x</a><a id="17434" class="Symbol">)</a> <a id="17436" href="plfa.Substitution.html#17400" class="Bound">M</a> <a id="17438" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="17440" href="plfa.Substitution.html#17400" class="Bound">M</a>
<a id="17442" href="/Substitution/#17378" class="Function">rename-id</a> <a id="17452" class="Symbol">{</a><a id="17453" class="Argument">M</a> <a id="17455" class="Symbol">=</a> <a id="17457" href="plfa.Substitution.html#17457" class="Bound">M</a><a id="17458" class="Symbol">}</a> <a id="17460" class="Symbol">=</a>
   <a id="17465" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
     <a id="17476" href="/Untyped/#5969" class="Function">rename</a> <a id="17483" class="Symbol">(λ</a> <a id="17486" class="Symbol">{</a><a id="17487" href="/Substitution/#17487" class="Bound">A</a><a id="17488" class="Symbol">}</a> <a id="17490" href="plfa.Substitution.html#17490" class="Bound">x</a> <a id="17492" class="Symbol">→</a> <a id="17494" href="plfa.Substitution.html#17490" class="Bound">x</a><a id="17495" class="Symbol">)</a> <a id="17497" href="plfa.Substitution.html#17457" class="Bound">M</a>
   <a id="17502" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="17505" href="/Substitution/#13680" class="Function">rename-subst-ren</a>  <a id="17523" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="17530" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="17532" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="17536" class="Symbol">(λ</a> <a id="17539" class="Symbol">{</a><a id="17540" href="plfa.Substitution.html#17540" class="Bound">A</a><a id="17541" class="Symbol">}</a> <a id="17543" href="plfa.Substitution.html#17543" class="Bound">x</a> <a id="17545" class="Symbol">→</a> <a id="17547" href="plfa.Substitution.html#17543" class="Bound">x</a><a id="17548" class="Symbol">)</a> <a id="17550" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="17552" href="plfa.Substitution.html#17457" class="Bound">M</a>
   <a id="17557" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
     <a id="17566" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="17568" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="17572" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="17574" href="plfa.Substitution.html#17457" class="Bound">M</a>
   <a id="17579" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="17582" href="/Substitution/#17012" class="Function">sub-id</a>  <a id="17590" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="17597" href="/Substitution/#17457" class="Bound">M</a>
   <a id="17602" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>
<h2 id="proof-of-sub-idr">Proof of sub-idR</h2>

<p>The proof of <code class="highlighter-rouge">sub-idR</code> follows directly from <code class="highlighter-rouge">sub-id</code>.</p>

<pre class="Agda"><a id="sub-idR"></a><a id="17690" href="/Substitution/#17690" class="Function">sub-idR</a> <a id="17698" class="Symbol">:</a> <a id="17700" class="Symbol">∀{</a><a id="17702" href="plfa.Substitution.html#17702" class="Bound">Γ</a> <a id="17704" href="plfa.Substitution.html#17704" class="Bound">Δ</a><a id="17705" class="Symbol">}</a> <a id="17707" class="Symbol">{</a><a id="17708" href="plfa.Substitution.html#17708" class="Bound">σ</a> <a id="17710" class="Symbol">:</a> <a id="17712" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="17718" href="plfa.Substitution.html#17702" class="Bound">Γ</a> <a id="17720" href="plfa.Substitution.html#17704" class="Bound">Δ</a><a id="17721" class="Symbol">}</a> <a id="17723" class="Symbol">{</a><a id="17724" href="plfa.Substitution.html#17724" class="Bound">A</a><a id="17725" class="Symbol">}</a>
       <a id="17734" class="Symbol">→</a> <a id="17736" class="Symbol">(</a><a id="17737" href="/Substitution/#17708" class="Bound">σ</a> <a id="17739" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="17741" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="17744" class="Symbol">)</a> <a id="17746" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="17748" href="plfa.Substitution.html#17708" class="Bound">σ</a> <a id="17750" class="Symbol">{</a><a id="17751" href="plfa.Substitution.html#17724" class="Bound">A</a><a id="17752" class="Symbol">}</a>
<a id="17754" href="/Substitution/#17690" class="Function">sub-idR</a> <a id="17762" class="Symbol">{</a><a id="17763" href="plfa.Substitution.html#17763" class="Bound">Γ</a><a id="17764" class="Symbol">}{</a><a id="17766" class="Argument">σ</a> <a id="17768" class="Symbol">=</a> <a id="17770" href="plfa.Substitution.html#17770" class="Bound">σ</a><a id="17771" class="Symbol">}{</a><a id="17773" href="plfa.Substitution.html#17773" class="Bound">A</a><a id="17774" class="Symbol">}</a> <a id="17776" class="Symbol">=</a>
          <a id="17788" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
            <a id="17806" href="/Substitution/#17770" class="Bound">σ</a> <a id="17808" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="17810" href="plfa.Substitution.html#3072" class="Function">ids</a>
          <a id="17824" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
            <a id="17840" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="17842" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="17846" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="17848" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="17850" href="plfa.Substitution.html#17770" class="Bound">σ</a>
          <a id="17862" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="17865" href="/Substitution/#1953" class="Postulate">extensionality</a> <a id="17880" class="Symbol">(λ</a> <a id="17883" href="plfa.Substitution.html#17883" class="Bound">x</a> <a id="17885" class="Symbol">→</a> <a id="17887" href="plfa.Substitution.html#17012" class="Function">sub-id</a><a id="17893" class="Symbol">)</a> <a id="17895" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
            <a id="17909" href="/Substitution/#17770" class="Bound">σ</a>
          <a id="17921" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>

<h2 id="proof-of-sub-sub">Proof of sub-sub</h2>

<p>The <code class="highlighter-rouge">sub-sub</code> equation states that sequenced substitutions <code class="highlighter-rouge">σ ⨟ τ</code>
are equivalent to first applying <code class="highlighter-rouge">σ</code> then applying <code class="highlighter-rouge">τ</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟪ τ ⟫ ⟪ σ ⟫ M  ≡ ⟪ σ ⨟ τ ⟫ M
</code></pre></div></div>

<p>The proof requires several lemmas. First, we need to prove the
specialization for renaming.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rename ρ (rename ρ′ M) ≡ rename (ρ ∘ ρ′) M
</code></pre></div></div>

<p>This in turn requires the following lemma about <code class="highlighter-rouge">ext</code>.</p>

<pre class="Agda"><a id="compose-ext"></a><a id="18309" href="/Substitution/#18309" class="Function">compose-ext</a> <a id="18321" class="Symbol">:</a> <a id="18323" class="Symbol">∀{</a><a id="18325" href="plfa.Substitution.html#18325" class="Bound">Γ</a> <a id="18327" href="plfa.Substitution.html#18327" class="Bound">Δ</a> <a id="18329" href="plfa.Substitution.html#18329" class="Bound">Σ</a><a id="18330" class="Symbol">}{</a><a id="18332" href="plfa.Substitution.html#18332" class="Bound">ρ</a> <a id="18334" class="Symbol">:</a> <a id="18336" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="18343" href="plfa.Substitution.html#18327" class="Bound">Δ</a> <a id="18345" href="plfa.Substitution.html#18329" class="Bound">Σ</a><a id="18346" class="Symbol">}</a> <a id="18348" class="Symbol">{</a><a id="18349" href="plfa.Substitution.html#18349" class="Bound">ρ′</a> <a id="18352" class="Symbol">:</a> <a id="18354" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="18361" href="plfa.Substitution.html#18325" class="Bound">Γ</a> <a id="18363" href="plfa.Substitution.html#18327" class="Bound">Δ</a><a id="18364" class="Symbol">}</a> <a id="18366" class="Symbol">{</a><a id="18367" href="plfa.Substitution.html#18367" class="Bound">A</a> <a id="18369" href="plfa.Substitution.html#18369" class="Bound">B</a><a id="18370" class="Symbol">}</a>
            <a id="18384" class="Symbol">→</a> <a id="18386" class="Symbol">((</a><a id="18388" href="/Untyped/#5659" class="Function">ext</a> <a id="18392" href="/Substitution/#18332" class="Bound">ρ</a><a id="18393" class="Symbol">)</a> <a id="18395" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="18397" class="Symbol">(</a><a id="18398" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="18402" href="plfa.Substitution.html#18349" class="Bound">ρ′</a><a id="18404" class="Symbol">))</a> <a id="18407" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="18409" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="18413" class="Symbol">(</a><a id="18414" href="plfa.Substitution.html#18332" class="Bound">ρ</a> <a id="18416" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="18418" href="plfa.Substitution.html#18349" class="Bound">ρ′</a><a id="18420" class="Symbol">)</a> <a id="18422" class="Symbol">{</a><a id="18423" href="plfa.Substitution.html#18369" class="Bound">B</a><a id="18424" class="Symbol">}</a> <a id="18426" class="Symbol">{</a><a id="18427" href="plfa.Substitution.html#18367" class="Bound">A</a><a id="18428" class="Symbol">}</a>
<a id="18430" href="/Substitution/#18309" class="Function">compose-ext</a> <a id="18442" class="Symbol">=</a> <a id="18444" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="18459" class="Symbol">λ</a> <a id="18461" href="plfa.Substitution.html#18461" class="Bound">x</a> <a id="18463" class="Symbol">→</a> <a id="18465" href="plfa.Substitution.html#18489" class="Function">lemma</a> <a id="18471" class="Symbol">{</a><a id="18472" class="Argument">x</a> <a id="18474" class="Symbol">=</a> <a id="18476" href="plfa.Substitution.html#18461" class="Bound">x</a><a id="18477" class="Symbol">}</a>
  <a id="18481" class="Keyword">where</a>
  <a id="18489" href="/Substitution/#18489" class="Function">lemma</a> <a id="18495" class="Symbol">:</a> <a id="18497" class="Symbol">∀{</a><a id="18499" href="plfa.Substitution.html#18499" class="Bound">Γ</a> <a id="18501" href="plfa.Substitution.html#18501" class="Bound">Δ</a> <a id="18503" href="plfa.Substitution.html#18503" class="Bound">Σ</a><a id="18504" class="Symbol">}{</a><a id="18506" href="plfa.Substitution.html#18506" class="Bound">ρ</a> <a id="18508" class="Symbol">:</a> <a id="18510" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="18517" href="plfa.Substitution.html#18501" class="Bound">Δ</a> <a id="18519" href="plfa.Substitution.html#18503" class="Bound">Σ</a><a id="18520" class="Symbol">}</a> <a id="18522" class="Symbol">{</a><a id="18523" href="plfa.Substitution.html#18523" class="Bound">ρ′</a> <a id="18526" class="Symbol">:</a> <a id="18528" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="18535" href="plfa.Substitution.html#18499" class="Bound">Γ</a> <a id="18537" href="plfa.Substitution.html#18501" class="Bound">Δ</a><a id="18538" class="Symbol">}</a> <a id="18540" class="Symbol">{</a><a id="18541" href="plfa.Substitution.html#18541" class="Bound">A</a> <a id="18543" href="plfa.Substitution.html#18543" class="Bound">B</a><a id="18544" class="Symbol">}</a> <a id="18546" class="Symbol">{</a><a id="18547" href="plfa.Substitution.html#18547" class="Bound">x</a> <a id="18549" class="Symbol">:</a> <a id="18551" href="plfa.Substitution.html#18499" class="Bound">Γ</a> <a id="18553" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="18555" href="plfa.Substitution.html#18543" class="Bound">B</a> <a id="18557" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="18559" href="plfa.Substitution.html#18541" class="Bound">A</a><a id="18560" class="Symbol">}</a>
              <a id="18576" class="Symbol">→</a> <a id="18578" class="Symbol">((</a><a id="18580" href="/Untyped/#5659" class="Function">ext</a> <a id="18584" href="/Substitution/#18506" class="Bound">ρ</a><a id="18585" class="Symbol">)</a> <a id="18587" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="18589" class="Symbol">(</a><a id="18590" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="18594" href="plfa.Substitution.html#18523" class="Bound">ρ′</a><a id="18596" class="Symbol">))</a> <a id="18599" href="plfa.Substitution.html#18547" class="Bound">x</a> <a id="18601" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="18603" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="18607" class="Symbol">(</a><a id="18608" href="plfa.Substitution.html#18506" class="Bound">ρ</a> <a id="18610" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="18612" href="plfa.Substitution.html#18523" class="Bound">ρ′</a><a id="18614" class="Symbol">)</a> <a id="18616" href="plfa.Substitution.html#18547" class="Bound">x</a>
  <a id="18620" href="/Substitution/#18489" class="Function">lemma</a> <a id="18626" class="Symbol">{</a><a id="18627" class="Argument">x</a> <a id="18629" class="Symbol">=</a> <a id="18631" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="18632" class="Symbol">}</a> <a id="18634" class="Symbol">=</a> <a id="18636" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="18643" href="/Substitution/#18489" class="Function">lemma</a> <a id="18649" class="Symbol">{</a><a id="18650" class="Argument">x</a> <a id="18652" class="Symbol">=</a> <a id="18654" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="18656" href="plfa.Substitution.html#18656" class="Bound">x</a><a id="18657" class="Symbol">}</a> <a id="18659" class="Symbol">=</a> <a id="18661" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<p>To prove that composing renamings is equivalent to applying one after
the other using <code class="highlighter-rouge">rename</code>, we proceed by induction on the term <code class="highlighter-rouge">M</code>,
using the <code class="highlighter-rouge">compose-ext</code> lemma in the case for <code class="highlighter-rouge">M ≡ ƛ N</code>.</p>

<pre class="Agda"><a id="compose-rename"></a><a id="18870" href="/Substitution/#18870" class="Function">compose-rename</a> <a id="18885" class="Symbol">:</a> <a id="18887" class="Symbol">∀{</a><a id="18889" href="plfa.Substitution.html#18889" class="Bound">Γ</a> <a id="18891" href="plfa.Substitution.html#18891" class="Bound">Δ</a> <a id="18893" href="plfa.Substitution.html#18893" class="Bound">Σ</a><a id="18894" class="Symbol">}{</a><a id="18896" href="plfa.Substitution.html#18896" class="Bound">A</a><a id="18897" class="Symbol">}{</a><a id="18899" href="plfa.Substitution.html#18899" class="Bound">M</a> <a id="18901" class="Symbol">:</a> <a id="18903" href="plfa.Substitution.html#18889" class="Bound">Γ</a> <a id="18905" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="18907" href="plfa.Substitution.html#18896" class="Bound">A</a><a id="18908" class="Symbol">}{</a><a id="18910" href="plfa.Substitution.html#18910" class="Bound">ρ</a> <a id="18912" class="Symbol">:</a> <a id="18914" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="18921" href="plfa.Substitution.html#18891" class="Bound">Δ</a> <a id="18923" href="plfa.Substitution.html#18893" class="Bound">Σ</a><a id="18924" class="Symbol">}{</a><a id="18926" href="plfa.Substitution.html#18926" class="Bound">ρ′</a> <a id="18929" class="Symbol">:</a> <a id="18931" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="18938" href="plfa.Substitution.html#18889" class="Bound">Γ</a> <a id="18940" href="plfa.Substitution.html#18891" class="Bound">Δ</a><a id="18941" class="Symbol">}</a>
  <a id="18945" class="Symbol">→</a> <a id="18947" href="/Untyped/#5969" class="Function">rename</a> <a id="18954" href="/Substitution/#18910" class="Bound">ρ</a> <a id="18956" class="Symbol">(</a><a id="18957" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="18964" href="plfa.Substitution.html#18926" class="Bound">ρ′</a> <a id="18967" href="plfa.Substitution.html#18899" class="Bound">M</a><a id="18968" class="Symbol">)</a> <a id="18970" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="18972" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="18979" class="Symbol">(</a><a id="18980" href="plfa.Substitution.html#18910" class="Bound">ρ</a> <a id="18982" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="18984" href="plfa.Substitution.html#18926" class="Bound">ρ′</a><a id="18986" class="Symbol">)</a> <a id="18988" href="plfa.Substitution.html#18899" class="Bound">M</a>
<a id="18990" href="/Substitution/#18870" class="Function">compose-rename</a> <a id="19005" class="Symbol">{</a><a id="19006" class="Argument">M</a> <a id="19008" class="Symbol">=</a> <a id="19010" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="19012" href="plfa.Substitution.html#19012" class="Bound">x</a><a id="19013" class="Symbol">}</a> <a id="19015" class="Symbol">=</a> <a id="19017" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="19022" href="/Substitution/#18870" class="Function">compose-rename</a> <a id="19037" class="Symbol">{</a><a id="19038" href="plfa.Substitution.html#19038" class="Bound">Γ</a><a id="19039" class="Symbol">}{</a><a id="19041" href="plfa.Substitution.html#19041" class="Bound">Δ</a><a id="19042" class="Symbol">}{</a><a id="19044" href="plfa.Substitution.html#19044" class="Bound">Σ</a><a id="19045" class="Symbol">}{</a><a id="19047" href="plfa.Substitution.html#19047" class="Bound">A</a><a id="19048" class="Symbol">}{</a><a id="19050" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="19052" href="plfa.Substitution.html#19052" class="Bound">N</a><a id="19053" class="Symbol">}{</a><a id="19055" href="plfa.Substitution.html#19055" class="Bound">ρ</a><a id="19056" class="Symbol">}{</a><a id="19058" href="plfa.Substitution.html#19058" class="Bound">ρ′</a><a id="19060" class="Symbol">}</a> <a id="19062" class="Symbol">=</a> <a id="19064" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="19069" href="plfa.Untyped.html#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="19072" href="plfa.Substitution.html#19084" class="Function">G</a>
  <a id="19076" class="Keyword">where</a>
  <a id="19084" href="/Substitution/#19084" class="Function">G</a> <a id="19086" class="Symbol">:</a> <a id="19088" href="/Untyped/#5969" class="Function">rename</a> <a id="19095" class="Symbol">(</a><a id="19096" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19100" href="plfa.Substitution.html#19055" class="Bound">ρ</a><a id="19101" class="Symbol">)</a> <a id="19103" class="Symbol">(</a><a id="19104" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="19111" class="Symbol">(</a><a id="19112" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19116" href="plfa.Substitution.html#19058" class="Bound">ρ′</a><a id="19118" class="Symbol">)</a> <a id="19120" href="plfa.Substitution.html#19052" class="Bound">N</a><a id="19121" class="Symbol">)</a> <a id="19123" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="19125" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="19132" class="Symbol">(</a><a id="19133" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19137" class="Symbol">(</a><a id="19138" href="plfa.Substitution.html#19055" class="Bound">ρ</a> <a id="19140" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="19142" href="plfa.Substitution.html#19058" class="Bound">ρ′</a><a id="19144" class="Symbol">))</a> <a id="19147" href="plfa.Substitution.html#19052" class="Bound">N</a>
  <a id="19151" href="/Substitution/#19084" class="Function">G</a> <a id="19153" class="Symbol">=</a>
      <a id="19161" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
        <a id="19175" href="/Untyped/#5969" class="Function">rename</a> <a id="19182" class="Symbol">(</a><a id="19183" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19187" href="/Substitution/#19055" class="Bound">ρ</a><a id="19188" class="Symbol">)</a> <a id="19190" class="Symbol">(</a><a id="19191" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="19198" class="Symbol">(</a><a id="19199" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19203" href="plfa.Substitution.html#19058" class="Bound">ρ′</a><a id="19205" class="Symbol">)</a> <a id="19207" href="plfa.Substitution.html#19052" class="Bound">N</a><a id="19208" class="Symbol">)</a>
      <a id="19216" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="19219" href="/Substitution/#18870" class="Function">compose-rename</a><a id="19233" class="Symbol">{</a><a id="19234" class="Argument">ρ</a> <a id="19236" class="Symbol">=</a> <a id="19238" href="/Untyped/#5659" class="Function">ext</a> <a id="19242" href="plfa.Substitution.html#19055" class="Bound">ρ</a><a id="19243" class="Symbol">}{</a><a id="19245" class="Argument">ρ′</a> <a id="19248" class="Symbol">=</a> <a id="19250" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19254" href="plfa.Substitution.html#19058" class="Bound">ρ′</a><a id="19256" class="Symbol">}</a> <a id="19258" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
        <a id="19268" href="/Untyped/#5969" class="Function">rename</a> <a id="19275" class="Symbol">((</a><a id="19277" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19281" href="/Substitution/#19055" class="Bound">ρ</a><a id="19282" class="Symbol">)</a> <a id="19284" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="19286" class="Symbol">(</a><a id="19287" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19291" href="plfa.Substitution.html#19058" class="Bound">ρ′</a><a id="19293" class="Symbol">))</a> <a id="19296" href="plfa.Substitution.html#19052" class="Bound">N</a>
      <a id="19304" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="19307" href="/Substitution/#10396" class="Function">cong-rename</a> <a id="19319" href="plfa.Substitution.html#18309" class="Function">compose-ext</a> <a id="19331" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="19336" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
        <a id="19346" href="/Untyped/#5969" class="Function">rename</a> <a id="19353" class="Symbol">(</a><a id="19354" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="19358" class="Symbol">(</a><a id="19359" href="/Substitution/#19055" class="Bound">ρ</a> <a id="19361" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="19363" href="plfa.Substitution.html#19058" class="Bound">ρ′</a><a id="19365" class="Symbol">))</a> <a id="19368" href="plfa.Substitution.html#19052" class="Bound">N</a>
      <a id="19376" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
<a id="19378" href="/Substitution/#18870" class="Function">compose-rename</a> <a id="19393" class="Symbol">{</a><a id="19394" class="Argument">M</a> <a id="19396" class="Symbol">=</a> <a id="19398" href="plfa.Substitution.html#19398" class="Bound">L</a> <a id="19400" href="/Untyped/#4176" class="InductiveConstructor Operator">·</a> <a id="19402" href="plfa.Substitution.html#19402" class="Bound">M</a><a id="19403" class="Symbol">}</a> <a id="19405" class="Symbol">=</a> <a id="19407" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1436" class="Function">cong₂</a> <a id="19413" href="plfa.Untyped.html#4176" class="InductiveConstructor Operator">_·_</a> <a id="19417" href="plfa.Substitution.html#18870" class="Function">compose-rename</a> <a id="19432" href="plfa.Substitution.html#18870" class="Function">compose-rename</a>
</pre>
<p>The next lemma states that if a renaming and substitution commute on
variables, then they also commute on terms. We explain the proof in
detail below.</p>

<pre class="Agda"><a id="commute-subst-rename"></a><a id="19608" href="/Substitution/#19608" class="Function">commute-subst-rename</a> <a id="19629" class="Symbol">:</a> <a id="19631" class="Symbol">∀{</a><a id="19633" href="plfa.Substitution.html#19633" class="Bound">Γ</a> <a id="19635" href="plfa.Substitution.html#19635" class="Bound">Δ</a><a id="19636" class="Symbol">}{</a><a id="19638" href="plfa.Substitution.html#19638" class="Bound">M</a> <a id="19640" class="Symbol">:</a> <a id="19642" href="plfa.Substitution.html#19633" class="Bound">Γ</a> <a id="19644" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="19646" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="19647" class="Symbol">}{</a><a id="19649" href="plfa.Substitution.html#19649" class="Bound">σ</a> <a id="19651" class="Symbol">:</a> <a id="19653" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="19659" href="plfa.Substitution.html#19633" class="Bound">Γ</a> <a id="19661" href="plfa.Substitution.html#19635" class="Bound">Δ</a><a id="19662" class="Symbol">}</a>
                        <a id="19688" class="Symbol">{</a><a id="19689" href="/Substitution/#19689" class="Bound">ρ</a> <a id="19691" class="Symbol">:</a> <a id="19693" class="Symbol">∀{</a><a id="19695" href="plfa.Substitution.html#19695" class="Bound">Γ</a><a id="19696" class="Symbol">}</a> <a id="19698" class="Symbol">→</a> <a id="19700" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="19707" href="plfa.Substitution.html#19695" class="Bound">Γ</a> <a id="19709" class="Symbol">(</a><a id="19710" href="plfa.Substitution.html#19695" class="Bound">Γ</a> <a id="19712" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="19714" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="19715" class="Symbol">)}</a>
     <a id="19723" class="Symbol">→</a> <a id="19725" class="Symbol">(∀{</a><a id="19728" href="/Substitution/#19728" class="Bound">x</a> <a id="19730" class="Symbol">:</a> <a id="19732" href="plfa.Substitution.html#19633" class="Bound">Γ</a> <a id="19734" href="/Untyped/#3259" class="Datatype Operator">∋</a> <a id="19736" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="19737" class="Symbol">}</a> <a id="19739" class="Symbol">→</a> <a id="19741" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="19746" href="plfa.Substitution.html#19649" class="Bound">σ</a> <a id="19748" class="Symbol">{</a><a id="19749" class="Argument">B</a> <a id="19751" class="Symbol">=</a> <a id="19753" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="19754" class="Symbol">}</a> <a id="19756" class="Symbol">(</a><a id="19757" href="plfa.Substitution.html#19689" class="Bound">ρ</a> <a id="19759" href="plfa.Substitution.html#19728" class="Bound">x</a><a id="19760" class="Symbol">)</a> <a id="19762" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="19764" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="19771" href="plfa.Substitution.html#19689" class="Bound">ρ</a> <a id="19773" class="Symbol">(</a><a id="19774" href="plfa.Substitution.html#19649" class="Bound">σ</a> <a id="19776" href="plfa.Substitution.html#19728" class="Bound">x</a><a id="19777" class="Symbol">))</a>
     <a id="19785" class="Symbol">→</a> <a id="19787" href="/Untyped/#6697" class="Function">subst</a> <a id="19793" class="Symbol">(</a><a id="19794" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="19799" href="/Substitution/#19649" class="Bound">σ</a> <a id="19801" class="Symbol">{</a><a id="19802" class="Argument">B</a> <a id="19804" class="Symbol">=</a> <a id="19806" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="19807" class="Symbol">})</a> <a id="19810" class="Symbol">(</a><a id="19811" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="19818" href="plfa.Substitution.html#19689" class="Bound">ρ</a> <a id="19820" href="plfa.Substitution.html#19638" class="Bound">M</a><a id="19821" class="Symbol">)</a> <a id="19823" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="19825" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="19832" href="plfa.Substitution.html#19689" class="Bound">ρ</a> <a id="19834" class="Symbol">(</a><a id="19835" href="plfa.Untyped.html#6697" class="Function">subst</a> <a id="19841" href="plfa.Substitution.html#19649" class="Bound">σ</a> <a id="19843" href="plfa.Substitution.html#19638" class="Bound">M</a><a id="19844" class="Symbol">)</a>
<a id="19846" href="/Substitution/#19608" class="Function">commute-subst-rename</a> <a id="19867" class="Symbol">{</a><a id="19868" class="Argument">M</a> <a id="19870" class="Symbol">=</a> <a id="19872" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="19874" href="plfa.Substitution.html#19874" class="Bound">x</a><a id="19875" class="Symbol">}</a> <a id="19877" href="plfa.Substitution.html#19877" class="Bound">r</a> <a id="19879" class="Symbol">=</a> <a id="19881" href="plfa.Substitution.html#19877" class="Bound">r</a>
<a id="19883" href="/Substitution/#19608" class="Function">commute-subst-rename</a><a id="19903" class="Symbol">{</a><a id="19904" href="plfa.Substitution.html#19904" class="Bound">Γ</a><a id="19905" class="Symbol">}{</a><a id="19907" href="plfa.Substitution.html#19907" class="Bound">Δ</a><a id="19908" class="Symbol">}{</a><a id="19910" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="19912" href="plfa.Substitution.html#19912" class="Bound">N</a><a id="19913" class="Symbol">}{</a><a id="19915" href="plfa.Substitution.html#19915" class="Bound">σ</a><a id="19916" class="Symbol">}{</a><a id="19918" href="plfa.Substitution.html#19918" class="Bound">ρ</a><a id="19919" class="Symbol">}</a> <a id="19921" href="plfa.Substitution.html#19921" class="Bound">r</a> <a id="19923" class="Symbol">=</a>
   <a id="19928" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="19933" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="19936" class="Symbol">(</a><a id="19937" href="/Substitution/#19608" class="Function">commute-subst-rename</a><a id="19957" class="Symbol">{</a><a id="19958" href="plfa.Substitution.html#19904" class="Bound">Γ</a> <a id="19960" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="19962" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="19963" class="Symbol">}{</a><a id="19965" href="plfa.Substitution.html#19907" class="Bound">Δ</a> <a id="19967" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="19969" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="19970" class="Symbol">}{</a><a id="19972" href="plfa.Substitution.html#19912" class="Bound">N</a><a id="19973" class="Symbol">}</a>
               <a id="19990" class="Symbol">{</a><a id="19991" href="/Untyped/#6405" class="Function">exts</a> <a id="19996" href="/Substitution/#19915" class="Bound">σ</a><a id="19997" class="Symbol">}{</a><a id="19999" class="Argument">ρ</a> <a id="20001" class="Symbol">=</a> <a id="20003" href="plfa.Substitution.html#20036" class="Function">ρ′</a><a id="20005" class="Symbol">}</a> <a id="20007" class="Symbol">(λ</a> <a id="20010" class="Symbol">{</a><a id="20011" href="plfa.Substitution.html#20011" class="Bound">x</a><a id="20012" class="Symbol">}</a> <a id="20014" class="Symbol">→</a> <a id="20016" href="plfa.Substitution.html#20109" class="Function">H</a> <a id="20018" class="Symbol">{</a><a id="20019" href="plfa.Substitution.html#20011" class="Bound">x</a><a id="20020" class="Symbol">}))</a>
   <a id="20027" class="Keyword">where</a>
   <a id="20036" href="/Substitution/#20036" class="Function">ρ′</a> <a id="20039" class="Symbol">:</a> <a id="20041" class="Symbol">∀</a> <a id="20043" class="Symbol">{</a><a id="20044" href="plfa.Substitution.html#20044" class="Bound">Γ</a><a id="20045" class="Symbol">}</a> <a id="20047" class="Symbol">→</a> <a id="20049" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="20056" href="plfa.Substitution.html#20044" class="Bound">Γ</a> <a id="20058" class="Symbol">(</a><a id="20059" href="plfa.Substitution.html#20044" class="Bound">Γ</a> <a id="20061" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="20063" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="20064" class="Symbol">)</a>
   <a id="20069" href="/Substitution/#20036" class="Function">ρ′</a> <a id="20072" class="Symbol">{</a><a id="20073" href="/Untyped/#2928" class="InductiveConstructor">∅</a><a id="20074" class="Symbol">}</a> <a id="20076" class="Symbol">=</a> <a id="20078" class="Symbol">λ</a> <a id="20080" class="Symbol">()</a>
   <a id="20086" href="/Substitution/#20036" class="Function">ρ′</a> <a id="20089" class="Symbol">{</a><a id="20090" href="plfa.Substitution.html#20090" class="Bound">Γ</a> <a id="20092" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="20094" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="20095" class="Symbol">}</a> <a id="20097" class="Symbol">=</a> <a id="20099" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="20103" href="plfa.Substitution.html#19918" class="Bound">ρ</a>

   <a id="20109" href="/Substitution/#20109" class="Function">H</a> <a id="20111" class="Symbol">:</a> <a id="20113" class="Symbol">{</a><a id="20114" href="plfa.Substitution.html#20114" class="Bound">x</a> <a id="20116" class="Symbol">:</a> <a id="20118" href="plfa.Substitution.html#19904" class="Bound">Γ</a> <a id="20120" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="20122" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a> <a id="20124" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="20126" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="20127" class="Symbol">}</a> <a id="20129" class="Symbol">→</a> <a id="20131" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="20136" class="Symbol">(</a><a id="20137" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="20142" href="plfa.Substitution.html#19915" class="Bound">σ</a><a id="20143" class="Symbol">)</a> <a id="20145" class="Symbol">(</a><a id="20146" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="20150" href="plfa.Substitution.html#19918" class="Bound">ρ</a> <a id="20152" href="plfa.Substitution.html#20114" class="Bound">x</a><a id="20153" class="Symbol">)</a> <a id="20155" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="20157" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="20164" class="Symbol">(</a><a id="20165" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="20169" href="plfa.Substitution.html#19918" class="Bound">ρ</a><a id="20170" class="Symbol">)</a> <a id="20172" class="Symbol">(</a><a id="20173" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="20178" href="plfa.Substitution.html#19915" class="Bound">σ</a> <a id="20180" href="plfa.Substitution.html#20114" class="Bound">x</a><a id="20181" class="Symbol">)</a>
   <a id="20186" href="/Substitution/#20109" class="Function">H</a> <a id="20188" class="Symbol">{</a><a id="20189" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="20190" class="Symbol">}</a> <a id="20192" class="Symbol">=</a> <a id="20194" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
   <a id="20202" href="/Substitution/#20109" class="Function">H</a> <a id="20204" class="Symbol">{</a><a id="20205" href="/Untyped/#3340" class="InductiveConstructor Operator">S</a> <a id="20207" href="plfa.Substitution.html#20207" class="Bound">y</a><a id="20208" class="Symbol">}</a> <a id="20210" class="Symbol">=</a>
     <a id="20217" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
       <a id="20230" href="/Untyped/#6405" class="Function">exts</a> <a id="20235" class="Symbol">(</a><a id="20236" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="20241" href="/Substitution/#19915" class="Bound">σ</a><a id="20242" class="Symbol">)</a> <a id="20244" class="Symbol">(</a><a id="20245" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="20249" href="plfa.Substitution.html#19918" class="Bound">ρ</a> <a id="20251" class="Symbol">(</a><a id="20252" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S</a> <a id="20254" href="plfa.Substitution.html#20207" class="Bound">y</a><a id="20255" class="Symbol">))</a>
     <a id="20263" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
       <a id="20274" href="/Untyped/#5969" class="Function">rename</a> <a id="20281" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="20284" class="Symbol">(</a><a id="20285" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="20290" href="/Substitution/#19915" class="Bound">σ</a> <a id="20292" class="Symbol">(</a><a id="20293" href="plfa.Substitution.html#19918" class="Bound">ρ</a> <a id="20295" href="plfa.Substitution.html#20207" class="Bound">y</a><a id="20296" class="Symbol">))</a>
     <a id="20304" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="20307" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="20312" class="Symbol">(</a><a id="20313" href="/Untyped/#5969" class="Function">rename</a> <a id="20320" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a><a id="20322" class="Symbol">)</a> <a id="20324" href="/Substitution/#19921" class="Bound">r</a> <a id="20326" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="20335" href="/Untyped/#5969" class="Function">rename</a> <a id="20342" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="20345" class="Symbol">(</a><a id="20346" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="20353" href="/Substitution/#19918" class="Bound">ρ</a> <a id="20355" class="Symbol">(</a><a id="20356" href="plfa.Substitution.html#19915" class="Bound">σ</a> <a id="20358" href="plfa.Substitution.html#20207" class="Bound">y</a><a id="20359" class="Symbol">))</a>
     <a id="20367" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="20370" href="/Substitution/#18870" class="Function">compose-rename</a> <a id="20385" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="20394" href="/Untyped/#5969" class="Function">rename</a> <a id="20401" class="Symbol">(</a><a id="20402" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="20405" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="20407" href="/Substitution/#19918" class="Bound">ρ</a><a id="20408" class="Symbol">)</a> <a id="20410" class="Symbol">(</a><a id="20411" href="plfa.Substitution.html#19915" class="Bound">σ</a> <a id="20413" href="plfa.Substitution.html#20207" class="Bound">y</a><a id="20414" class="Symbol">)</a>
     <a id="20421" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="20424" href="/Substitution/#10396" class="Function">cong-rename</a> <a id="20436" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="20441" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="20446" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="20455" href="/Untyped/#5969" class="Function">rename</a> <a id="20462" class="Symbol">((</a><a id="20464" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="20468" href="/Substitution/#19918" class="Bound">ρ</a><a id="20469" class="Symbol">)</a> <a id="20471" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="20473" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a><a id="20475" class="Symbol">)</a> <a id="20477" class="Symbol">(</a><a id="20478" href="plfa.Substitution.html#19915" class="Bound">σ</a> <a id="20480" href="plfa.Substitution.html#20207" class="Bound">y</a><a id="20481" class="Symbol">)</a>
     <a id="20488" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="20491" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="20495" href="/Substitution/#18870" class="Function">compose-rename</a> <a id="20510" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="20519" href="/Untyped/#5969" class="Function">rename</a> <a id="20526" class="Symbol">(</a><a id="20527" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="20531" href="/Substitution/#19918" class="Bound">ρ</a><a id="20532" class="Symbol">)</a> <a id="20534" class="Symbol">(</a><a id="20535" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="20542" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="20545" class="Symbol">(</a><a id="20546" href="plfa.Substitution.html#19915" class="Bound">σ</a> <a id="20548" href="plfa.Substitution.html#20207" class="Bound">y</a><a id="20549" class="Symbol">))</a>
     <a id="20557" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
       <a id="20568" href="/Untyped/#5969" class="Function">rename</a> <a id="20575" class="Symbol">(</a><a id="20576" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="20580" href="/Substitution/#19918" class="Bound">ρ</a><a id="20581" class="Symbol">)</a> <a id="20583" class="Symbol">(</a><a id="20584" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="20589" href="plfa.Substitution.html#19915" class="Bound">σ</a> <a id="20591" class="Symbol">(</a><a id="20592" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S</a> <a id="20594" href="plfa.Substitution.html#20207" class="Bound">y</a><a id="20595" class="Symbol">))</a>
     <a id="20603" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
<a id="20605" href="/Substitution/#19608" class="Function">commute-subst-rename</a> <a id="20626" class="Symbol">{</a><a id="20627" class="Argument">M</a> <a id="20629" class="Symbol">=</a> <a id="20631" href="plfa.Substitution.html#20631" class="Bound">L</a> <a id="20633" href="/Untyped/#4176" class="InductiveConstructor Operator">·</a> <a id="20635" href="plfa.Substitution.html#20635" class="Bound">M</a><a id="20636" class="Symbol">}{</a><a id="20638" class="Argument">ρ</a> <a id="20640" class="Symbol">=</a> <a id="20642" href="plfa.Substitution.html#20642" class="Bound">ρ</a><a id="20643" class="Symbol">}</a> <a id="20645" href="plfa.Substitution.html#20645" class="Bound">r</a> <a id="20647" class="Symbol">=</a>
   <a id="20652" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1436" class="Function">cong₂</a> <a id="20658" href="/Untyped/#4176" class="InductiveConstructor Operator">_·_</a> <a id="20662" class="Symbol">(</a><a id="20663" href="/Substitution/#19608" class="Function">commute-subst-rename</a><a id="20683" class="Symbol">{</a><a id="20684" class="Argument">M</a> <a id="20686" class="Symbol">=</a> <a id="20688" href="plfa.Substitution.html#20631" class="Bound">L</a><a id="20689" class="Symbol">}{</a><a id="20691" class="Argument">ρ</a> <a id="20693" class="Symbol">=</a> <a id="20695" href="plfa.Substitution.html#20642" class="Bound">ρ</a><a id="20696" class="Symbol">}</a> <a id="20698" href="plfa.Substitution.html#20645" class="Bound">r</a><a id="20699" class="Symbol">)</a>
             <a id="20714" class="Symbol">(</a><a id="20715" href="/Substitution/#19608" class="Function">commute-subst-rename</a><a id="20735" class="Symbol">{</a><a id="20736" class="Argument">M</a> <a id="20738" class="Symbol">=</a> <a id="20740" href="plfa.Substitution.html#20635" class="Bound">M</a><a id="20741" class="Symbol">}{</a><a id="20743" class="Argument">ρ</a> <a id="20745" class="Symbol">=</a> <a id="20747" href="plfa.Substitution.html#20642" class="Bound">ρ</a><a id="20748" class="Symbol">}</a> <a id="20750" href="plfa.Substitution.html#20645" class="Bound">r</a><a id="20751" class="Symbol">)</a>
</pre>
<p>The proof is by induction on the term <code class="highlighter-rouge">M</code>.</p>

<ul>
  <li>
    <p>If <code class="highlighter-rouge">M</code> is a variable, then we use the premise to conclude.</p>
  </li>
  <li>
    <p>If <code class="highlighter-rouge">M ≡ ƛ N</code>, we conclude using the induction hypothesis for
<code class="highlighter-rouge">N</code>. However, to use the induction hypothesis, we must show
that</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  exts (exts σ) (ext ρ x) ≡ rename (ext ρ) (exts σ x)
</code></pre></div>    </div>

    <p>We prove this equation by cases on x.</p>

    <ul>
      <li>
        <p>If <code class="highlighter-rouge">x = Z</code>, the two sides are equal by definition.</p>
      </li>
      <li>
        <p>If <code class="highlighter-rouge">x = S y</code>, we obtain the goal by the following equational reasoning.</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exts (exts σ) (ext ρ (S y))   ≡ rename S_ (exts σ (ρ y))   ≡ rename S_ (rename S_ (σ (ρ y)      (by the premise)   ≡ rename (ext ρ) (exts σ (S y))      (by compose-rename)   ≡ rename ((ext ρ) ∘ S_) (σ y)   ≡ rename (ext ρ) (rename S_ (σ y))   (by compose-rename)   ≡ rename (ext ρ) (exts σ (S y))
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>If <code class="highlighter-rouge">M</code> is an application, we obtain the goal using the induction
hypothesis for each subterm.</p>
  </li>
</ul>

<p>The last lemma needed to prove <code class="highlighter-rouge">sub-sub</code> states that the <code class="highlighter-rouge">exts</code>
function distributes with sequencing. It is a corollary of
<code class="highlighter-rouge">commute-subst-rename</code> as described below.  (It would have been nicer
to prove this directly by equational reasoning in the σ algebra, but
that would require the <code class="highlighter-rouge">sub-assoc</code> equation, whose proof depends on
<code class="highlighter-rouge">sub-sub</code>, which in turn depends on this lemma.)</p>

<pre class="Agda"><a id="exts-seq"></a><a id="22064" href="/Substitution/#22064" class="Function">exts-seq</a> <a id="22073" class="Symbol">:</a> <a id="22075" class="Symbol">∀{</a><a id="22077" href="plfa.Substitution.html#22077" class="Bound">Γ</a> <a id="22079" href="plfa.Substitution.html#22079" class="Bound">Δ</a> <a id="22081" href="plfa.Substitution.html#22081" class="Bound">Δ′</a><a id="22083" class="Symbol">}</a> <a id="22085" class="Symbol">{</a><a id="22086" href="plfa.Substitution.html#22086" class="Bound">σ₁</a> <a id="22089" class="Symbol">:</a> <a id="22091" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="22097" href="plfa.Substitution.html#22077" class="Bound">Γ</a> <a id="22099" href="plfa.Substitution.html#22079" class="Bound">Δ</a><a id="22100" class="Symbol">}</a> <a id="22102" class="Symbol">{</a><a id="22103" href="plfa.Substitution.html#22103" class="Bound">σ₂</a> <a id="22106" class="Symbol">:</a> <a id="22108" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="22114" href="plfa.Substitution.html#22079" class="Bound">Δ</a> <a id="22116" href="plfa.Substitution.html#22081" class="Bound">Δ′</a><a id="22118" class="Symbol">}</a>
         <a id="22129" class="Symbol">→</a> <a id="22131" class="Symbol">∀</a> <a id="22133" class="Symbol">{</a><a id="22134" href="/Substitution/#22134" class="Bound">A</a><a id="22135" class="Symbol">}</a> <a id="22137" class="Symbol">→</a> <a id="22139" class="Symbol">(</a><a id="22140" href="/Untyped/#6405" class="Function">exts</a> <a id="22145" href="plfa.Substitution.html#22086" class="Bound">σ₁</a> <a id="22148" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="22150" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="22155" href="plfa.Substitution.html#22103" class="Bound">σ₂</a><a id="22157" class="Symbol">)</a> <a id="22159" class="Symbol">{</a><a id="22160" href="plfa.Substitution.html#22134" class="Bound">A</a><a id="22161" class="Symbol">}</a> <a id="22163" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="22165" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="22170" class="Symbol">(</a><a id="22171" href="plfa.Substitution.html#22086" class="Bound">σ₁</a> <a id="22174" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="22176" href="plfa.Substitution.html#22103" class="Bound">σ₂</a><a id="22178" class="Symbol">)</a>
<a id="22180" href="/Substitution/#22064" class="Function">exts-seq</a> <a id="22189" class="Symbol">=</a> <a id="22191" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="22206" class="Symbol">λ</a> <a id="22208" href="plfa.Substitution.html#22208" class="Bound">x</a> <a id="22210" class="Symbol">→</a> <a id="22212" href="plfa.Substitution.html#22236" class="Function">lemma</a> <a id="22218" class="Symbol">{</a><a id="22219" class="Argument">x</a> <a id="22221" class="Symbol">=</a> <a id="22223" href="plfa.Substitution.html#22208" class="Bound">x</a><a id="22224" class="Symbol">}</a>
  <a id="22228" class="Keyword">where</a>
  <a id="22236" href="/Substitution/#22236" class="Function">lemma</a> <a id="22242" class="Symbol">:</a> <a id="22244" class="Symbol">∀{</a><a id="22246" href="plfa.Substitution.html#22246" class="Bound">Γ</a> <a id="22248" href="plfa.Substitution.html#22248" class="Bound">Δ</a> <a id="22250" href="plfa.Substitution.html#22250" class="Bound">Δ′</a><a id="22252" class="Symbol">}{</a><a id="22254" href="plfa.Substitution.html#22254" class="Bound">A</a><a id="22255" class="Symbol">}{</a><a id="22257" href="plfa.Substitution.html#22257" class="Bound">x</a> <a id="22259" class="Symbol">:</a> <a id="22261" href="plfa.Substitution.html#22246" class="Bound">Γ</a> <a id="22263" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="22265" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a> <a id="22267" href="plfa.Untyped.html#3259" class="Datatype Operator">∋</a> <a id="22269" href="plfa.Substitution.html#22254" class="Bound">A</a><a id="22270" class="Symbol">}</a> <a id="22272" class="Symbol">{</a><a id="22273" href="plfa.Substitution.html#22273" class="Bound">σ₁</a> <a id="22276" class="Symbol">:</a> <a id="22278" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="22284" href="plfa.Substitution.html#22246" class="Bound">Γ</a> <a id="22286" href="plfa.Substitution.html#22248" class="Bound">Δ</a><a id="22287" class="Symbol">}{</a><a id="22289" href="plfa.Substitution.html#22289" class="Bound">σ₂</a> <a id="22292" class="Symbol">:</a> <a id="22294" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="22300" href="plfa.Substitution.html#22248" class="Bound">Δ</a> <a id="22302" href="plfa.Substitution.html#22250" class="Bound">Δ′</a><a id="22304" class="Symbol">}</a>
     <a id="22311" class="Symbol">→</a> <a id="22313" class="Symbol">(</a><a id="22314" href="/Untyped/#6405" class="Function">exts</a> <a id="22319" href="/Substitution/#22273" class="Bound">σ₁</a> <a id="22322" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="22324" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="22329" href="plfa.Substitution.html#22289" class="Bound">σ₂</a><a id="22331" class="Symbol">)</a> <a id="22333" href="plfa.Substitution.html#22257" class="Bound">x</a> <a id="22335" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="22337" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="22342" class="Symbol">(</a><a id="22343" href="plfa.Substitution.html#22273" class="Bound">σ₁</a> <a id="22346" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="22348" href="plfa.Substitution.html#22289" class="Bound">σ₂</a><a id="22350" class="Symbol">)</a> <a id="22352" href="plfa.Substitution.html#22257" class="Bound">x</a>
  <a id="22356" href="/Substitution/#22236" class="Function">lemma</a> <a id="22362" class="Symbol">{</a><a id="22363" class="Argument">x</a> <a id="22365" class="Symbol">=</a> <a id="22367" href="/Untyped/#3295" class="InductiveConstructor">Z</a><a id="22368" class="Symbol">}</a> <a id="22370" class="Symbol">=</a> <a id="22372" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
  <a id="22379" href="/Substitution/#22236" class="Function">lemma</a> <a id="22385" class="Symbol">{</a><a id="22386" class="Argument">A</a> <a id="22388" class="Symbol">=</a> <a id="22390" href="/Untyped/#2652" class="InductiveConstructor">★</a><a id="22391" class="Symbol">}{</a><a id="22393" class="Argument">x</a> <a id="22395" class="Symbol">=</a> <a id="22397" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S</a> <a id="22399" href="plfa.Substitution.html#22399" class="Bound">x</a><a id="22400" class="Symbol">}{</a><a id="22402" href="plfa.Substitution.html#22402" class="Bound">σ₁</a><a id="22404" class="Symbol">}{</a><a id="22406" href="plfa.Substitution.html#22406" class="Bound">σ₂</a><a id="22408" class="Symbol">}</a> <a id="22410" class="Symbol">=</a>
     <a id="22417" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
       <a id="22430" class="Symbol">(</a><a id="22431" href="/Untyped/#6405" class="Function">exts</a> <a id="22436" href="/Substitution/#22402" class="Bound">σ₁</a> <a id="22439" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="22441" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="22446" href="plfa.Substitution.html#22406" class="Bound">σ₂</a><a id="22448" class="Symbol">)</a> <a id="22450" class="Symbol">(</a><a id="22451" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S</a> <a id="22453" href="plfa.Substitution.html#22399" class="Bound">x</a><a id="22454" class="Symbol">)</a>
     <a id="22461" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
       <a id="22472" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="22474" href="/Untyped/#6405" class="Function">exts</a> <a id="22479" href="plfa.Substitution.html#22406" class="Bound">σ₂</a> <a id="22482" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="22484" class="Symbol">(</a><a id="22485" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="22492" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="22495" class="Symbol">(</a><a id="22496" href="plfa.Substitution.html#22402" class="Bound">σ₁</a> <a id="22499" href="plfa.Substitution.html#22399" class="Bound">x</a><a id="22500" class="Symbol">))</a>
     <a id="22508" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="22511" href="/Substitution/#19608" class="Function">commute-subst-rename</a><a id="22531" class="Symbol">{</a><a id="22532" class="Argument">M</a> <a id="22534" class="Symbol">=</a> <a id="22536" href="plfa.Substitution.html#22402" class="Bound">σ₁</a> <a id="22539" href="plfa.Substitution.html#22399" class="Bound">x</a><a id="22540" class="Symbol">}{</a><a id="22542" class="Argument">σ</a> <a id="22544" class="Symbol">=</a> <a id="22546" href="plfa.Substitution.html#22406" class="Bound">σ₂</a><a id="22548" class="Symbol">}{</a><a id="22550" class="Argument">ρ</a> <a id="22552" class="Symbol">=</a> <a id="22554" href="/Untyped/#3340" class="InductiveConstructor Operator">S_</a><a id="22556" class="Symbol">}</a> <a id="22558" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="22563" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="22572" href="/Untyped/#5969" class="Function">rename</a> <a id="22579" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="22582" class="Symbol">(</a><a id="22583" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="22585" href="plfa.Substitution.html#22406" class="Bound">σ₂</a> <a id="22588" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="22590" class="Symbol">(</a><a id="22591" href="plfa.Substitution.html#22402" class="Bound">σ₁</a> <a id="22594" href="plfa.Substitution.html#22399" class="Bound">x</a><a id="22595" class="Symbol">))</a>
     <a id="22603" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
       <a id="22614" href="/Untyped/#5969" class="Function">rename</a> <a id="22621" href="plfa.Untyped.html#3340" class="InductiveConstructor Operator">S_</a> <a id="22624" class="Symbol">((</a><a id="22626" href="/Substitution/#22402" class="Bound">σ₁</a> <a id="22629" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="22631" href="plfa.Substitution.html#22406" class="Bound">σ₂</a><a id="22633" class="Symbol">)</a> <a id="22635" href="plfa.Substitution.html#22399" class="Bound">x</a><a id="22636" class="Symbol">)</a>
     <a id="22643" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>
<p>The proof proceed by cases on <code class="highlighter-rouge">x</code>.</p>

<ul>
  <li>
    <p>If <code class="highlighter-rouge">x = Z</code>, the two sides are equal by the definition of <code class="highlighter-rouge">exts</code>
and sequencing.</p>
  </li>
  <li>
    <p>If <code class="highlighter-rouge">x = S x</code>, we unfold the first use of <code class="highlighter-rouge">exts</code> and sequencing, then
apply the lemma <code class="highlighter-rouge">commute-subst-rename</code>. We conclude by the
definition of sequencing.</p>
  </li>
</ul>

<p>Now we come to the proof of <code class="highlighter-rouge">sub-sub</code>, which we explain below.</p>

<pre class="Agda"><a id="sub-sub"></a><a id="23001" href="/Substitution/#23001" class="Function">sub-sub</a> <a id="23009" class="Symbol">:</a> <a id="23011" class="Symbol">∀{</a><a id="23013" href="plfa.Substitution.html#23013" class="Bound">Γ</a> <a id="23015" href="plfa.Substitution.html#23015" class="Bound">Δ</a> <a id="23017" href="plfa.Substitution.html#23017" class="Bound">Σ</a><a id="23018" class="Symbol">}{</a><a id="23020" href="plfa.Substitution.html#23020" class="Bound">A</a><a id="23021" class="Symbol">}{</a><a id="23023" href="plfa.Substitution.html#23023" class="Bound">M</a> <a id="23025" class="Symbol">:</a> <a id="23027" href="plfa.Substitution.html#23013" class="Bound">Γ</a> <a id="23029" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="23031" href="plfa.Substitution.html#23020" class="Bound">A</a><a id="23032" class="Symbol">}</a> <a id="23034" class="Symbol">{</a><a id="23035" href="plfa.Substitution.html#23035" class="Bound">σ₁</a> <a id="23038" class="Symbol">:</a> <a id="23040" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="23046" href="plfa.Substitution.html#23013" class="Bound">Γ</a> <a id="23048" href="plfa.Substitution.html#23015" class="Bound">Δ</a><a id="23049" class="Symbol">}{</a><a id="23051" href="plfa.Substitution.html#23051" class="Bound">σ₂</a> <a id="23054" class="Symbol">:</a> <a id="23056" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="23062" href="plfa.Substitution.html#23015" class="Bound">Δ</a> <a id="23064" href="plfa.Substitution.html#23017" class="Bound">Σ</a><a id="23065" class="Symbol">}</a>
            <a id="23079" class="Symbol">→</a> <a id="23081" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="23083" href="plfa.Substitution.html#23051" class="Bound">σ₂</a> <a id="23086" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23088" class="Symbol">(</a><a id="23089" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="23091" href="plfa.Substitution.html#23035" class="Bound">σ₁</a> <a id="23094" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23096" href="plfa.Substitution.html#23023" class="Bound">M</a><a id="23097" class="Symbol">)</a> <a id="23099" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="23101" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="23103" href="plfa.Substitution.html#23035" class="Bound">σ₁</a> <a id="23106" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="23108" href="plfa.Substitution.html#23051" class="Bound">σ₂</a> <a id="23111" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23113" href="plfa.Substitution.html#23023" class="Bound">M</a>
<a id="23115" href="/Substitution/#23001" class="Function">sub-sub</a> <a id="23123" class="Symbol">{</a><a id="23124" class="Argument">M</a> <a id="23126" class="Symbol">=</a> <a id="23128" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="23130" href="plfa.Substitution.html#23130" class="Bound">x</a><a id="23131" class="Symbol">}</a> <a id="23133" class="Symbol">=</a> <a id="23135" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="23140" href="/Substitution/#23001" class="Function">sub-sub</a> <a id="23148" class="Symbol">{</a><a id="23149" href="plfa.Substitution.html#23149" class="Bound">Γ</a><a id="23150" class="Symbol">}{</a><a id="23152" href="plfa.Substitution.html#23152" class="Bound">Δ</a><a id="23153" class="Symbol">}{</a><a id="23155" href="plfa.Substitution.html#23155" class="Bound">Σ</a><a id="23156" class="Symbol">}{</a><a id="23158" href="plfa.Substitution.html#23158" class="Bound">A</a><a id="23159" class="Symbol">}{</a><a id="23161" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="23163" href="plfa.Substitution.html#23163" class="Bound">N</a><a id="23164" class="Symbol">}{</a><a id="23166" href="plfa.Substitution.html#23166" class="Bound">σ₁</a><a id="23168" class="Symbol">}{</a><a id="23170" href="plfa.Substitution.html#23170" class="Bound">σ₂</a><a id="23172" class="Symbol">}</a> <a id="23174" class="Symbol">=</a>
   <a id="23179" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
     <a id="23190" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="23192" href="plfa.Substitution.html#23170" class="Bound">σ₂</a> <a id="23195" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23197" class="Symbol">(</a><a id="23198" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="23200" href="plfa.Substitution.html#23166" class="Bound">σ₁</a> <a id="23203" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23205" class="Symbol">(</a><a id="23206" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="23208" href="plfa.Substitution.html#23163" class="Bound">N</a><a id="23209" class="Symbol">))</a>
   <a id="23215" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
     <a id="23224" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="23226" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="23228" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="23233" href="plfa.Substitution.html#23170" class="Bound">σ₂</a> <a id="23236" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23238" class="Symbol">(</a><a id="23239" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="23241" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="23246" href="plfa.Substitution.html#23166" class="Bound">σ₁</a> <a id="23249" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23251" href="plfa.Substitution.html#23163" class="Bound">N</a><a id="23252" class="Symbol">)</a>
   <a id="23257" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="23260" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="23265" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="23268" class="Symbol">(</a><a id="23269" href="/Substitution/#23001" class="Function">sub-sub</a><a id="23276" class="Symbol">{</a><a id="23277" class="Argument">M</a> <a id="23279" class="Symbol">=</a> <a id="23281" href="plfa.Substitution.html#23163" class="Bound">N</a><a id="23282" class="Symbol">}{</a><a id="23284" class="Argument">σ₁</a> <a id="23287" class="Symbol">=</a> <a id="23289" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="23294" href="plfa.Substitution.html#23166" class="Bound">σ₁</a><a id="23296" class="Symbol">}{</a><a id="23298" class="Argument">σ₂</a> <a id="23301" class="Symbol">=</a> <a id="23303" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="23308" href="plfa.Substitution.html#23170" class="Bound">σ₂</a><a id="23310" class="Symbol">})</a> <a id="23313" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="23320" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="23322" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="23324" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="23329" href="plfa.Substitution.html#23166" class="Bound">σ₁</a> <a id="23332" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="23334" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="23339" href="plfa.Substitution.html#23170" class="Bound">σ₂</a> <a id="23342" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23344" href="plfa.Substitution.html#23163" class="Bound">N</a>
   <a id="23349" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="23352" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="23357" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ_</a> <a id="23360" class="Symbol">(</a><a id="23361" href="/Substitution/#11198" class="Function">cong-sub</a><a id="23369" class="Symbol">{</a><a id="23370" class="Argument">M</a> <a id="23372" class="Symbol">=</a> <a id="23374" href="plfa.Substitution.html#23163" class="Bound">N</a><a id="23375" class="Symbol">}</a> <a id="23377" class="Symbol">(λ</a> <a id="23380" class="Symbol">{</a><a id="23381" href="plfa.Substitution.html#23381" class="Bound">A</a><a id="23382" class="Symbol">}</a> <a id="23384" class="Symbol">→</a> <a id="23386" href="plfa.Substitution.html#22064" class="Function">exts-seq</a><a id="23394" class="Symbol">)</a> <a id="23396" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="23400" class="Symbol">)</a> <a id="23402" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="23409" href="/Untyped/#4116" class="InductiveConstructor Operator">ƛ</a> <a id="23411" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="23413" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="23418" class="Symbol">(</a> <a id="23420" href="plfa.Substitution.html#23166" class="Bound">σ₁</a> <a id="23423" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="23425" href="plfa.Substitution.html#23170" class="Bound">σ₂</a><a id="23427" class="Symbol">)</a> <a id="23429" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="23431" href="plfa.Substitution.html#23163" class="Bound">N</a>
   <a id="23436" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
<a id="23438" href="/Substitution/#23001" class="Function">sub-sub</a> <a id="23446" class="Symbol">{</a><a id="23447" class="Argument">M</a> <a id="23449" class="Symbol">=</a> <a id="23451" href="plfa.Substitution.html#23451" class="Bound">L</a> <a id="23453" href="/Untyped/#4176" class="InductiveConstructor Operator">·</a> <a id="23455" href="plfa.Substitution.html#23455" class="Bound">M</a><a id="23456" class="Symbol">}</a> <a id="23458" class="Symbol">=</a> <a id="23460" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1436" class="Function">cong₂</a> <a id="23466" href="plfa.Untyped.html#4176" class="InductiveConstructor Operator">_·_</a> <a id="23470" class="Symbol">(</a><a id="23471" href="plfa.Substitution.html#23001" class="Function">sub-sub</a><a id="23478" class="Symbol">{</a><a id="23479" class="Argument">M</a> <a id="23481" class="Symbol">=</a> <a id="23483" href="plfa.Substitution.html#23451" class="Bound">L</a><a id="23484" class="Symbol">})</a> <a id="23487" class="Symbol">(</a><a id="23488" href="plfa.Substitution.html#23001" class="Function">sub-sub</a><a id="23495" class="Symbol">{</a><a id="23496" class="Argument">M</a> <a id="23498" class="Symbol">=</a> <a id="23500" href="plfa.Substitution.html#23455" class="Bound">M</a><a id="23501" class="Symbol">})</a>
</pre>
<p>We proceed by induction on the term <code class="highlighter-rouge">M</code>.</p>

<ul>
  <li>
    <p>If <code class="highlighter-rouge">M = x</code>, then both sides are equal to <code class="highlighter-rouge">σ₂ (σ₁ x)</code>.</p>
  </li>
  <li>
    <p>If <code class="highlighter-rouge">M = ƛ N</code>, we first use the induction hypothesis to show that</p>

    <p>ƛ ⟪ exts σ₂ ⟫ (⟪ exts σ₁ ⟫ N) ≡ ƛ ⟪ exts σ₁ ⨟ exts σ₂ ⟫ N</p>

    <p>and then use the lemma <code class="highlighter-rouge">exts-seq</code> to show</p>

    <p>ƛ ⟪ exts σ₁ ⨟ exts σ₂ ⟫ N ≡ ƛ ⟪ exts ( σ₁ ⨟ σ₂) ⟫ N</p>
  </li>
  <li>
    <p>If <code class="highlighter-rouge">M</code> is an application, we use the induction hypothesis
for both subterms.</p>
  </li>
</ul>

<p>The following corollary of <code class="highlighter-rouge">sub-sub</code> specializes the first
substitution to a renaming.</p>

<pre class="Agda"><a id="rename-subst"></a><a id="24017" href="/Substitution/#24017" class="Function">rename-subst</a> <a id="24030" class="Symbol">:</a> <a id="24032" class="Symbol">∀{</a><a id="24034" href="plfa.Substitution.html#24034" class="Bound">Γ</a> <a id="24036" href="plfa.Substitution.html#24036" class="Bound">Δ</a> <a id="24038" href="plfa.Substitution.html#24038" class="Bound">Δ′</a><a id="24040" class="Symbol">}{</a><a id="24042" href="plfa.Substitution.html#24042" class="Bound">M</a> <a id="24044" class="Symbol">:</a> <a id="24046" href="plfa.Substitution.html#24034" class="Bound">Γ</a> <a id="24048" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="24050" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="24051" class="Symbol">}{</a><a id="24053" href="plfa.Substitution.html#24053" class="Bound">ρ</a> <a id="24055" class="Symbol">:</a> <a id="24057" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="24064" href="plfa.Substitution.html#24034" class="Bound">Γ</a> <a id="24066" href="plfa.Substitution.html#24036" class="Bound">Δ</a><a id="24067" class="Symbol">}{</a><a id="24069" href="plfa.Substitution.html#24069" class="Bound">σ</a> <a id="24071" class="Symbol">:</a> <a id="24073" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="24079" href="plfa.Substitution.html#24036" class="Bound">Δ</a> <a id="24081" href="plfa.Substitution.html#24038" class="Bound">Δ′</a><a id="24083" class="Symbol">}</a>
             <a id="24098" class="Symbol">→</a> <a id="24100" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="24102" href="plfa.Substitution.html#24069" class="Bound">σ</a> <a id="24104" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24106" class="Symbol">(</a><a id="24107" href="/Untyped/#5969" class="Function">rename</a> <a id="24114" href="plfa.Substitution.html#24053" class="Bound">ρ</a> <a id="24116" href="plfa.Substitution.html#24042" class="Bound">M</a><a id="24117" class="Symbol">)</a> <a id="24119" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24121" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="24123" href="plfa.Substitution.html#24069" class="Bound">σ</a> <a id="24125" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="24127" href="plfa.Substitution.html#24053" class="Bound">ρ</a> <a id="24129" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24131" href="plfa.Substitution.html#24042" class="Bound">M</a>
<a id="24133" href="/Substitution/#24017" class="Function">rename-subst</a> <a id="24146" class="Symbol">{</a><a id="24147" href="plfa.Substitution.html#24147" class="Bound">Γ</a><a id="24148" class="Symbol">}{</a><a id="24150" href="plfa.Substitution.html#24150" class="Bound">Δ</a><a id="24151" class="Symbol">}{</a><a id="24153" href="plfa.Substitution.html#24153" class="Bound">Δ′</a><a id="24155" class="Symbol">}{</a><a id="24157" href="plfa.Substitution.html#24157" class="Bound">M</a><a id="24158" class="Symbol">}{</a><a id="24160" href="plfa.Substitution.html#24160" class="Bound">ρ</a><a id="24161" class="Symbol">}{</a><a id="24163" href="plfa.Substitution.html#24163" class="Bound">σ</a><a id="24164" class="Symbol">}</a> <a id="24166" class="Symbol">=</a>
   <a id="24171" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
     <a id="24182" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="24184" href="plfa.Substitution.html#24163" class="Bound">σ</a> <a id="24186" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24188" class="Symbol">(</a><a id="24189" href="/Untyped/#5969" class="Function">rename</a> <a id="24196" href="plfa.Substitution.html#24160" class="Bound">ρ</a> <a id="24198" href="plfa.Substitution.html#24157" class="Bound">M</a><a id="24199" class="Symbol">)</a>
   <a id="24204" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="24207" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="24212" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="24214" href="plfa.Substitution.html#24163" class="Bound">σ</a> <a id="24216" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24218" class="Symbol">(</a><a id="24219" href="plfa.Substitution.html#13680" class="Function">rename-subst-ren</a><a id="24235" class="Symbol">{</a><a id="24236" class="Argument">M</a> <a id="24238" class="Symbol">=</a> <a id="24240" href="plfa.Substitution.html#24157" class="Bound">M</a><a id="24241" class="Symbol">})</a> <a id="24244" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="24251" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="24253" href="plfa.Substitution.html#24163" class="Bound">σ</a> <a id="24255" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24257" class="Symbol">(</a><a id="24258" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="24260" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="24264" href="plfa.Substitution.html#24160" class="Bound">ρ</a> <a id="24266" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24268" href="plfa.Substitution.html#24157" class="Bound">M</a><a id="24269" class="Symbol">)</a>
   <a id="24274" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="24277" href="/Substitution/#23001" class="Function">sub-sub</a><a id="24284" class="Symbol">{</a><a id="24285" class="Argument">M</a> <a id="24287" class="Symbol">=</a> <a id="24289" href="plfa.Substitution.html#24157" class="Bound">M</a><a id="24290" class="Symbol">}</a> <a id="24292" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
     <a id="24299" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="24301" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="24305" href="plfa.Substitution.html#24160" class="Bound">ρ</a> <a id="24307" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24309" href="plfa.Substitution.html#24163" class="Bound">σ</a> <a id="24311" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24313" href="plfa.Substitution.html#24157" class="Bound">M</a>
   <a id="24318" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
     <a id="24327" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="24329" href="plfa.Substitution.html#24163" class="Bound">σ</a> <a id="24331" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="24333" href="plfa.Substitution.html#24160" class="Bound">ρ</a> <a id="24335" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24337" href="plfa.Substitution.html#24157" class="Bound">M</a>
   <a id="24342" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>

<h2 id="proof-of-sub-assoc">Proof of sub-assoc</h2>

<p>The proof of <code class="highlighter-rouge">sub-assoc</code> follows directly from <code class="highlighter-rouge">sub-sub</code> and the
definition of sequencing.</p>

<pre class="Agda"><a id="sub-assoc"></a><a id="24469" href="/Substitution/#24469" class="Function">sub-assoc</a> <a id="24479" class="Symbol">:</a> <a id="24481" class="Symbol">∀{</a><a id="24483" href="plfa.Substitution.html#24483" class="Bound">Γ</a> <a id="24485" href="plfa.Substitution.html#24485" class="Bound">Δ</a> <a id="24487" href="plfa.Substitution.html#24487" class="Bound">Σ</a> <a id="24489" href="plfa.Substitution.html#24489" class="Bound">Ψ</a> <a id="24491" class="Symbol">:</a> <a id="24493" href="/Untyped/#2906" class="Datatype">Context</a><a id="24500" class="Symbol">}</a> <a id="24502" class="Symbol">{</a><a id="24503" href="plfa.Substitution.html#24503" class="Bound">σ</a> <a id="24505" class="Symbol">:</a> <a id="24507" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="24513" href="plfa.Substitution.html#24483" class="Bound">Γ</a> <a id="24515" href="plfa.Substitution.html#24485" class="Bound">Δ</a><a id="24516" class="Symbol">}</a> <a id="24518" class="Symbol">{</a><a id="24519" href="plfa.Substitution.html#24519" class="Bound">τ</a> <a id="24521" class="Symbol">:</a> <a id="24523" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="24529" href="plfa.Substitution.html#24485" class="Bound">Δ</a> <a id="24531" href="plfa.Substitution.html#24487" class="Bound">Σ</a><a id="24532" class="Symbol">}</a>
             <a id="24547" class="Symbol">{</a><a id="24548" href="/Substitution/#24548" class="Bound">θ</a> <a id="24550" class="Symbol">:</a> <a id="24552" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="24558" href="plfa.Substitution.html#24487" class="Bound">Σ</a> <a id="24560" href="plfa.Substitution.html#24489" class="Bound">Ψ</a><a id="24561" class="Symbol">}</a>
          <a id="24573" class="Symbol">→</a> <a id="24575" class="Symbol">∀{</a><a id="24577" href="/Substitution/#24577" class="Bound">A</a><a id="24578" class="Symbol">}</a> <a id="24580" class="Symbol">→</a> <a id="24582" class="Symbol">(</a><a id="24583" href="plfa.Substitution.html#24503" class="Bound">σ</a> <a id="24585" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24587" href="plfa.Substitution.html#24519" class="Bound">τ</a><a id="24588" class="Symbol">)</a> <a id="24590" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24592" href="plfa.Substitution.html#24548" class="Bound">θ</a> <a id="24594" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24596" class="Symbol">(</a><a id="24597" href="plfa.Substitution.html#24503" class="Bound">σ</a> <a id="24599" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24601" href="plfa.Substitution.html#24519" class="Bound">τ</a> <a id="24603" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24605" href="plfa.Substitution.html#24548" class="Bound">θ</a><a id="24606" class="Symbol">)</a> <a id="24608" class="Symbol">{</a><a id="24609" href="plfa.Substitution.html#24577" class="Bound">A</a><a id="24610" class="Symbol">}</a>
<a id="24612" href="/Substitution/#24469" class="Function">sub-assoc</a> <a id="24622" class="Symbol">{</a><a id="24623" href="plfa.Substitution.html#24623" class="Bound">Γ</a><a id="24624" class="Symbol">}{</a><a id="24626" href="plfa.Substitution.html#24626" class="Bound">Δ</a><a id="24627" class="Symbol">}{</a><a id="24629" href="plfa.Substitution.html#24629" class="Bound">Σ</a><a id="24630" class="Symbol">}{</a><a id="24632" href="plfa.Substitution.html#24632" class="Bound">Ψ</a><a id="24633" class="Symbol">}{</a><a id="24635" href="plfa.Substitution.html#24635" class="Bound">σ</a><a id="24636" class="Symbol">}{</a><a id="24638" href="plfa.Substitution.html#24638" class="Bound">τ</a><a id="24639" class="Symbol">}{</a><a id="24641" href="plfa.Substitution.html#24641" class="Bound">θ</a><a id="24642" class="Symbol">}{</a><a id="24644" href="plfa.Substitution.html#24644" class="Bound">A</a><a id="24645" class="Symbol">}</a> <a id="24647" class="Symbol">=</a> <a id="24649" href="plfa.Substitution.html#1953" class="Postulate">extensionality</a> <a id="24664" class="Symbol">λ</a> <a id="24666" href="plfa.Substitution.html#24666" class="Bound">x</a> <a id="24668" class="Symbol">→</a> <a id="24670" href="plfa.Substitution.html#24693" class="Function">lemma</a><a id="24675" class="Symbol">{</a><a id="24676" class="Argument">x</a> <a id="24678" class="Symbol">=</a> <a id="24680" href="plfa.Substitution.html#24666" class="Bound">x</a><a id="24681" class="Symbol">}</a>
  <a id="24685" class="Keyword">where</a>
  <a id="24693" href="/Substitution/#24693" class="Function">lemma</a> <a id="24699" class="Symbol">:</a> <a id="24701" class="Symbol">∀</a> <a id="24703" class="Symbol">{</a><a id="24704" href="plfa.Substitution.html#24704" class="Bound">x</a> <a id="24706" class="Symbol">:</a> <a id="24708" href="plfa.Substitution.html#24623" class="Bound">Γ</a> <a id="24710" href="/Untyped/#3259" class="Datatype Operator">∋</a> <a id="24712" href="plfa.Substitution.html#24644" class="Bound">A</a><a id="24713" class="Symbol">}</a> <a id="24715" class="Symbol">→</a> <a id="24717" class="Symbol">((</a><a id="24719" href="plfa.Substitution.html#24635" class="Bound">σ</a> <a id="24721" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24723" href="plfa.Substitution.html#24638" class="Bound">τ</a><a id="24724" class="Symbol">)</a> <a id="24726" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24728" href="plfa.Substitution.html#24641" class="Bound">θ</a><a id="24729" class="Symbol">)</a> <a id="24731" href="plfa.Substitution.html#24704" class="Bound">x</a> <a id="24733" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24735" class="Symbol">(</a><a id="24736" href="plfa.Substitution.html#24635" class="Bound">σ</a> <a id="24738" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24740" href="plfa.Substitution.html#24638" class="Bound">τ</a> <a id="24742" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24744" href="plfa.Substitution.html#24641" class="Bound">θ</a><a id="24745" class="Symbol">)</a> <a id="24747" href="plfa.Substitution.html#24704" class="Bound">x</a>
  <a id="24751" href="/Substitution/#24693" class="Function">lemma</a> <a id="24757" class="Symbol">{</a><a id="24758" href="plfa.Substitution.html#24758" class="Bound">x</a><a id="24759" class="Symbol">}</a> <a id="24761" class="Symbol">=</a>
      <a id="24769" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
        <a id="24783" class="Symbol">((</a><a id="24785" href="/Substitution/#24635" class="Bound">σ</a> <a id="24787" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24789" href="plfa.Substitution.html#24638" class="Bound">τ</a><a id="24790" class="Symbol">)</a> <a id="24792" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24794" href="plfa.Substitution.html#24641" class="Bound">θ</a><a id="24795" class="Symbol">)</a> <a id="24797" href="plfa.Substitution.html#24758" class="Bound">x</a>
      <a id="24805" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
        <a id="24817" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="24819" href="plfa.Substitution.html#24641" class="Bound">θ</a> <a id="24821" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24823" class="Symbol">(</a><a id="24824" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="24826" href="plfa.Substitution.html#24638" class="Bound">τ</a> <a id="24828" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24830" class="Symbol">(</a><a id="24831" href="plfa.Substitution.html#24635" class="Bound">σ</a> <a id="24833" href="plfa.Substitution.html#24758" class="Bound">x</a><a id="24834" class="Symbol">))</a>
      <a id="24843" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="24846" href="/Substitution/#23001" class="Function">sub-sub</a><a id="24853" class="Symbol">{</a><a id="24854" class="Argument">M</a> <a id="24856" class="Symbol">=</a> <a id="24858" href="plfa.Substitution.html#24635" class="Bound">σ</a> <a id="24860" href="plfa.Substitution.html#24758" class="Bound">x</a><a id="24861" class="Symbol">}</a> <a id="24863" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
        <a id="24873" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="24875" href="plfa.Substitution.html#24638" class="Bound">τ</a> <a id="24877" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24879" href="plfa.Substitution.html#24641" class="Bound">θ</a> <a id="24881" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="24883" class="Symbol">(</a><a id="24884" href="plfa.Substitution.html#24635" class="Bound">σ</a> <a id="24886" href="plfa.Substitution.html#24758" class="Bound">x</a><a id="24887" class="Symbol">)</a>
      <a id="24895" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
        <a id="24907" class="Symbol">(</a><a id="24908" href="/Substitution/#24635" class="Bound">σ</a> <a id="24910" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24912" href="plfa.Substitution.html#24638" class="Bound">τ</a> <a id="24914" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="24916" href="plfa.Substitution.html#24641" class="Bound">θ</a><a id="24917" class="Symbol">)</a> <a id="24919" href="plfa.Substitution.html#24758" class="Bound">x</a>
      <a id="24927" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>
<h2 id="proof-of-subst-zero-exts-cons">Proof of subst-zero-exts-cons</h2>

<p>The last equation we needed to prove <code class="highlighter-rouge">subst-zero-exts-cons</code> was
<code class="highlighter-rouge">sub-assoc</code>, so we can now go ahead with its proof.  We simply apply
the equations for <code class="highlighter-rouge">exts</code> and <code class="highlighter-rouge">subst-zero</code> and then apply the σ algebra
equation to arrive at the normal form <code class="highlighter-rouge">M • σ</code>.</p>

<pre class="Agda"><a id="subst-zero-exts-cons"></a><a id="25224" href="/Substitution/#25224" class="Function">subst-zero-exts-cons</a> <a id="25245" class="Symbol">:</a> <a id="25247" class="Symbol">∀{</a><a id="25249" href="plfa.Substitution.html#25249" class="Bound">Γ</a> <a id="25251" href="plfa.Substitution.html#25251" class="Bound">Δ</a><a id="25252" class="Symbol">}{</a><a id="25254" href="plfa.Substitution.html#25254" class="Bound">σ</a> <a id="25256" class="Symbol">:</a> <a id="25258" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="25264" href="plfa.Substitution.html#25249" class="Bound">Γ</a> <a id="25266" href="plfa.Substitution.html#25251" class="Bound">Δ</a><a id="25267" class="Symbol">}{</a><a id="25269" href="plfa.Substitution.html#25269" class="Bound">B</a><a id="25270" class="Symbol">}{</a><a id="25272" href="plfa.Substitution.html#25272" class="Bound">M</a> <a id="25274" class="Symbol">:</a> <a id="25276" href="plfa.Substitution.html#25251" class="Bound">Δ</a> <a id="25278" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="25280" href="plfa.Substitution.html#25269" class="Bound">B</a><a id="25281" class="Symbol">}{</a><a id="25283" href="plfa.Substitution.html#25283" class="Bound">A</a><a id="25284" class="Symbol">}</a>
                     <a id="25307" class="Symbol">→</a> <a id="25309" href="/Untyped/#6405" class="Function">exts</a> <a id="25314" href="/Substitution/#25254" class="Bound">σ</a> <a id="25316" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25318" href="plfa.Untyped.html#7109" class="Function">subst-zero</a> <a id="25329" href="plfa.Substitution.html#25272" class="Bound">M</a> <a id="25331" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="25333" class="Symbol">(</a><a id="25334" href="plfa.Substitution.html#25272" class="Bound">M</a> <a id="25336" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25338" href="plfa.Substitution.html#25254" class="Bound">σ</a><a id="25339" class="Symbol">)</a> <a id="25341" class="Symbol">{</a><a id="25342" href="plfa.Substitution.html#25283" class="Bound">A</a><a id="25343" class="Symbol">}</a>
<a id="25345" href="/Substitution/#25224" class="Function">subst-zero-exts-cons</a> <a id="25366" class="Symbol">{</a><a id="25367" href="plfa.Substitution.html#25367" class="Bound">Γ</a><a id="25368" class="Symbol">}{</a><a id="25370" href="plfa.Substitution.html#25370" class="Bound">Δ</a><a id="25371" class="Symbol">}{</a><a id="25373" href="plfa.Substitution.html#25373" class="Bound">σ</a><a id="25374" class="Symbol">}{</a><a id="25376" href="plfa.Substitution.html#25376" class="Bound">B</a><a id="25377" class="Symbol">}{</a><a id="25379" href="plfa.Substitution.html#25379" class="Bound">M</a><a id="25380" class="Symbol">}{</a><a id="25382" href="plfa.Substitution.html#25382" class="Bound">A</a><a id="25383" class="Symbol">}</a> <a id="25385" class="Symbol">=</a>
    <a id="25391" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
      <a id="25403" href="/Untyped/#6405" class="Function">exts</a> <a id="25408" href="/Substitution/#25373" class="Bound">σ</a> <a id="25410" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25412" href="plfa.Untyped.html#7109" class="Function">subst-zero</a> <a id="25423" href="plfa.Substitution.html#25379" class="Bound">M</a>
    <a id="25429" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="25432" href="/Substitution/#12282" class="Function">cong-seq</a> <a id="25441" href="plfa.Substitution.html#15044" class="Function">exts-cons-shift</a> <a id="25457" href="plfa.Substitution.html#15825" class="Function">subst-Z-cons-ids</a> <a id="25474" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
      <a id="25482" class="Symbol">(</a><a id="25483" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="25485" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a> <a id="25487" href="/Substitution/#3453" class="Function Operator">•</a> <a id="25489" class="Symbol">(</a><a id="25490" href="plfa.Substitution.html#25373" class="Bound">σ</a> <a id="25492" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25494" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="25495" class="Symbol">))</a> <a id="25498" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25500" class="Symbol">(</a><a id="25501" href="plfa.Substitution.html#25379" class="Bound">M</a> <a id="25503" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25505" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="25508" class="Symbol">)</a>
    <a id="25514" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="25517" href="/Substitution/#9100" class="Function">sub-dist</a> <a id="25526" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
      <a id="25534" class="Symbol">(</a><a id="25535" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="25537" href="plfa.Substitution.html#25379" class="Bound">M</a> <a id="25539" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25541" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="25545" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="25547" class="Symbol">(</a><a id="25548" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="25550" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="25551" class="Symbol">))</a> <a id="25554" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25556" class="Symbol">((</a><a id="25558" href="plfa.Substitution.html#25373" class="Bound">σ</a> <a id="25560" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25562" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="25563" class="Symbol">)</a> <a id="25565" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25567" class="Symbol">(</a><a id="25568" href="plfa.Substitution.html#25379" class="Bound">M</a> <a id="25570" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25572" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="25575" class="Symbol">))</a>
    <a id="25582" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="25585" href="/Substitution/#11937" class="Function">cong-cons</a> <a id="25595" class="Symbol">(</a><a id="25596" href="plfa.Substitution.html#8285" class="Function">sub-head</a><a id="25604" class="Symbol">{</a><a id="25605" class="Argument">σ</a> <a id="25607" class="Symbol">=</a> <a id="25609" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="25612" class="Symbol">})</a> <a id="25615" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="25620" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
      <a id="25628" href="/Substitution/#25379" class="Bound">M</a> <a id="25630" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25632" class="Symbol">((</a><a id="25634" href="plfa.Substitution.html#25373" class="Bound">σ</a> <a id="25636" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25638" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="25639" class="Symbol">)</a> <a id="25641" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25643" class="Symbol">(</a><a id="25644" href="plfa.Substitution.html#25379" class="Bound">M</a> <a id="25646" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25648" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="25651" class="Symbol">))</a>
    <a id="25658" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="25661" href="/Substitution/#11937" class="Function">cong-cons</a> <a id="25671" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="25676" class="Symbol">(</a><a id="25677" href="plfa.Substitution.html#24469" class="Function">sub-assoc</a><a id="25686" class="Symbol">{</a><a id="25687" class="Argument">σ</a> <a id="25689" class="Symbol">=</a> <a id="25691" href="plfa.Substitution.html#25373" class="Bound">σ</a><a id="25692" class="Symbol">})</a> <a id="25695" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
      <a id="25703" href="/Substitution/#25379" class="Bound">M</a> <a id="25705" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25707" class="Symbol">(</a><a id="25708" href="plfa.Substitution.html#25373" class="Bound">σ</a> <a id="25710" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25712" class="Symbol">(</a><a id="25713" href="plfa.Substitution.html#3211" class="Function">↑</a> <a id="25715" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25717" class="Symbol">(</a><a id="25718" href="plfa.Substitution.html#25379" class="Bound">M</a> <a id="25720" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25722" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="25725" class="Symbol">)))</a>
    <a id="25733" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="25736" href="/Substitution/#11937" class="Function">cong-cons</a> <a id="25746" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="25751" class="Symbol">(</a><a id="25752" href="plfa.Substitution.html#12282" class="Function">cong-seq</a><a id="25760" class="Symbol">{</a><a id="25761" class="Argument">σ</a> <a id="25763" class="Symbol">=</a> <a id="25765" href="plfa.Substitution.html#25373" class="Bound">σ</a><a id="25766" class="Symbol">}</a> <a id="25768" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="25773" class="Symbol">(</a><a id="25774" href="plfa.Substitution.html#8391" class="Function">sub-tail</a><a id="25782" class="Symbol">{</a><a id="25783" class="Argument">M</a> <a id="25785" class="Symbol">=</a> <a id="25787" href="plfa.Substitution.html#25379" class="Bound">M</a><a id="25788" class="Symbol">}{</a><a id="25790" class="Argument">σ</a> <a id="25792" class="Symbol">=</a> <a id="25794" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="25797" class="Symbol">}))</a> <a id="25801" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
      <a id="25809" href="/Substitution/#25379" class="Bound">M</a> <a id="25811" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25813" class="Symbol">(</a><a id="25814" href="plfa.Substitution.html#25373" class="Bound">σ</a> <a id="25816" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="25818" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="25821" class="Symbol">)</a>
    <a id="25827" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="25830" href="/Substitution/#11937" class="Function">cong-cons</a> <a id="25840" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="25845" class="Symbol">(</a><a id="25846" href="plfa.Substitution.html#17690" class="Function">sub-idR</a><a id="25853" class="Symbol">{</a><a id="25854" class="Argument">σ</a> <a id="25856" class="Symbol">=</a> <a id="25858" href="plfa.Substitution.html#25373" class="Bound">σ</a><a id="25859" class="Symbol">})</a> <a id="25862" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
      <a id="25870" href="/Substitution/#25379" class="Bound">M</a> <a id="25872" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="25874" href="plfa.Substitution.html#25373" class="Bound">σ</a>
    <a id="25880" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>

<h2 id="proof-of-the-substitution-lemma">Proof of the substitution lemma</h2>

<p>We first prove the generalized form of the substitution lemma, showing
that a substitution <code class="highlighter-rouge">σ</code> commutes with the substitution of <code class="highlighter-rouge">M</code> into
<code class="highlighter-rouge">N</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟪ exts σ ⟫ N [ ⟪ σ ⟫ M ] ≡ ⟪ σ ⟫ (N [ M ])
</code></pre></div></div>

<p>This proof is where the σ algebra pays off.  The proof is by direct
equational reasoning. Starting with the left-hand side, we apply σ
algebra equations, oriented left-to-right, until we arrive at the
normal form</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟪ ⟪ σ ⟫ M • σ ⟫ N
</code></pre></div></div>

<p>We then do the same with the right-hand side, arriving at the same
normal form.</p>

<pre class="Agda"><a id="subst-commute"></a><a id="26438" href="/Substitution/#26438" class="Function">subst-commute</a> <a id="26452" class="Symbol">:</a> <a id="26454" class="Symbol">∀{</a><a id="26456" href="plfa.Substitution.html#26456" class="Bound">Γ</a> <a id="26458" href="plfa.Substitution.html#26458" class="Bound">Δ</a><a id="26459" class="Symbol">}{</a><a id="26461" href="plfa.Substitution.html#26461" class="Bound">N</a> <a id="26463" class="Symbol">:</a> <a id="26465" href="plfa.Substitution.html#26456" class="Bound">Γ</a> <a id="26467" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="26469" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a> <a id="26471" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="26473" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="26474" class="Symbol">}{</a><a id="26476" href="plfa.Substitution.html#26476" class="Bound">M</a> <a id="26478" class="Symbol">:</a> <a id="26480" href="plfa.Substitution.html#26456" class="Bound">Γ</a> <a id="26482" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="26484" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="26485" class="Symbol">}{</a><a id="26487" href="plfa.Substitution.html#26487" class="Bound">σ</a> <a id="26489" class="Symbol">:</a> <a id="26491" href="plfa.Substitution.html#2431" class="Function">Subst</a> <a id="26497" href="plfa.Substitution.html#26456" class="Bound">Γ</a> <a id="26499" href="plfa.Substitution.html#26458" class="Bound">Δ</a> <a id="26501" class="Symbol">}</a>
    <a id="26507" class="Symbol">→</a> <a id="26509" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="26511" href="/Untyped/#6405" class="Function">exts</a> <a id="26516" href="plfa.Substitution.html#26487" class="Bound">σ</a> <a id="26518" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26520" href="plfa.Substitution.html#26461" class="Bound">N</a> <a id="26522" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="26524" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26526" href="plfa.Substitution.html#26487" class="Bound">σ</a> <a id="26528" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26530" href="plfa.Substitution.html#26476" class="Bound">M</a> <a id="26532" href="plfa.Untyped.html#7225" class="Function Operator">]</a> <a id="26534" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="26536" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26538" href="plfa.Substitution.html#26487" class="Bound">σ</a> <a id="26540" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26542" class="Symbol">(</a><a id="26543" href="plfa.Substitution.html#26461" class="Bound">N</a> <a id="26545" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="26547" href="plfa.Substitution.html#26476" class="Bound">M</a> <a id="26549" href="plfa.Untyped.html#7225" class="Function Operator">]</a><a id="26550" class="Symbol">)</a>
<a id="26552" href="/Substitution/#26438" class="Function">subst-commute</a> <a id="26566" class="Symbol">{</a><a id="26567" href="plfa.Substitution.html#26567" class="Bound">Γ</a><a id="26568" class="Symbol">}{</a><a id="26570" href="plfa.Substitution.html#26570" class="Bound">Δ</a><a id="26571" class="Symbol">}{</a><a id="26573" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="26574" class="Symbol">}{</a><a id="26576" href="plfa.Substitution.html#26576" class="Bound">M</a><a id="26577" class="Symbol">}{</a><a id="26579" href="plfa.Substitution.html#26579" class="Bound">σ</a><a id="26580" class="Symbol">}</a> <a id="26582" class="Symbol">=</a>
     <a id="26589" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
       <a id="26602" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="26604" href="/Untyped/#6405" class="Function">exts</a> <a id="26609" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26611" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26613" href="plfa.Substitution.html#26573" class="Bound">N</a> <a id="26615" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="26617" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26619" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26621" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26623" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="26625" href="plfa.Untyped.html#7225" class="Function Operator">]</a>
     <a id="26632" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
       <a id="26643" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="26645" href="/Untyped/#7109" class="Function">subst-zero</a> <a id="26656" class="Symbol">(</a><a id="26657" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26659" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26661" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26663" href="plfa.Substitution.html#26576" class="Bound">M</a><a id="26664" class="Symbol">)</a> <a id="26666" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26668" class="Symbol">(</a><a id="26669" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26671" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="26676" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26678" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26680" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="26681" class="Symbol">)</a>
     <a id="26688" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="26691" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="26700" class="Symbol">{</a><a id="26701" class="Argument">M</a> <a id="26703" class="Symbol">=</a> <a id="26705" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26707" href="/Untyped/#6405" class="Function">exts</a> <a id="26712" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26714" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26716" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="26717" class="Symbol">}</a> <a id="26719" href="plfa.Substitution.html#15825" class="Function">subst-Z-cons-ids</a> <a id="26736" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="26741" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="26750" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="26752" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26754" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26756" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26758" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="26760" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="26762" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="26766" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26768" class="Symbol">(</a><a id="26769" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26771" href="/Untyped/#6405" class="Function">exts</a> <a id="26776" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26778" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26780" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="26781" class="Symbol">)</a>
     <a id="26788" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="26791" href="/Substitution/#23001" class="Function">sub-sub</a> <a id="26799" class="Symbol">{</a><a id="26800" class="Argument">M</a> <a id="26802" class="Symbol">=</a> <a id="26804" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="26805" class="Symbol">}</a> <a id="26807" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="26816" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="26818" class="Symbol">(</a><a id="26819" href="/Untyped/#6405" class="Function">exts</a> <a id="26824" href="plfa.Substitution.html#26579" class="Bound">σ</a><a id="26825" class="Symbol">)</a> <a id="26827" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="26829" class="Symbol">((</a><a id="26831" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26833" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26835" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26837" href="plfa.Substitution.html#26576" class="Bound">M</a><a id="26838" class="Symbol">)</a> <a id="26840" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="26842" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="26845" class="Symbol">)</a> <a id="26847" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26849" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="26856" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="26859" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="26868" class="Symbol">{</a><a id="26869" class="Argument">M</a> <a id="26871" class="Symbol">=</a> <a id="26873" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="26874" class="Symbol">}</a> <a id="26876" class="Symbol">(</a><a id="26877" href="plfa.Substitution.html#12282" class="Function">cong-seq</a> <a id="26886" href="plfa.Substitution.html#15044" class="Function">exts-cons-shift</a> <a id="26902" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="26906" class="Symbol">)</a> <a id="26908" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="26913" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="26922" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="26924" class="Symbol">(</a><a id="26925" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="26927" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a> <a id="26929" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="26931" class="Symbol">(</a><a id="26932" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26934" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="26936" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="26937" class="Symbol">))</a> <a id="26940" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="26942" class="Symbol">(</a><a id="26943" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="26945" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="26947" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26949" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="26951" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="26953" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="26956" class="Symbol">)</a> <a id="26958" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="26960" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="26967" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="26970" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="26979" class="Symbol">{</a><a id="26980" class="Argument">M</a> <a id="26982" class="Symbol">=</a> <a id="26984" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="26985" class="Symbol">}</a> <a id="26987" class="Symbol">(</a><a id="26988" href="plfa.Substitution.html#9100" class="Function">sub-dist</a> <a id="26997" class="Symbol">{</a><a id="26998" class="Argument">M</a> <a id="27000" class="Symbol">=</a> <a id="27002" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="27004" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="27005" class="Symbol">})</a> <a id="27008" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27013" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="27022" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27024" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27026" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27028" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27030" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27032" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27034" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27036" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="27040" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27042" class="Symbol">(</a><a id="27043" href="/Untyped/#4064" class="InductiveConstructor Operator">`</a> <a id="27045" href="plfa.Untyped.html#3295" class="InductiveConstructor">Z</a><a id="27046" class="Symbol">)</a> <a id="27048" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27050" class="Symbol">((</a><a id="27052" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27054" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27056" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="27057" class="Symbol">)</a> <a id="27059" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27061" class="Symbol">(</a><a id="27062" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27064" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27066" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27068" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27070" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27072" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="27075" class="Symbol">))</a> <a id="27078" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27080" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="27087" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
       <a id="27098" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27100" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27102" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27104" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27106" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27108" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27110" class="Symbol">((</a><a id="27112" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27114" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27116" href="plfa.Substitution.html#3211" class="Function">↑</a><a id="27117" class="Symbol">)</a> <a id="27119" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27121" class="Symbol">(</a><a id="27122" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27124" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27126" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27128" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27130" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27132" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="27135" class="Symbol">))</a> <a id="27138" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27140" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="27147" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="27150" href="/Substitution/#11198" class="Function">cong-sub</a><a id="27158" class="Symbol">{</a><a id="27159" class="Argument">M</a> <a id="27161" class="Symbol">=</a> <a id="27163" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="27164" class="Symbol">}</a> <a id="27166" class="Symbol">(</a><a id="27167" href="plfa.Substitution.html#11937" class="Function">cong-cons</a> <a id="27177" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27182" class="Symbol">(</a><a id="27183" href="plfa.Substitution.html#24469" class="Function">sub-assoc</a><a id="27192" class="Symbol">{</a><a id="27193" class="Argument">σ</a> <a id="27195" class="Symbol">=</a> <a id="27197" href="plfa.Substitution.html#26579" class="Bound">σ</a><a id="27198" class="Symbol">}))</a> <a id="27202" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27207" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="27216" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27218" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27220" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27222" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27224" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27226" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27228" class="Symbol">(</a><a id="27229" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27231" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27233" href="plfa.Substitution.html#3211" class="Function">↑</a> <a id="27235" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27237" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27239" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27241" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27243" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27245" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27247" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="27250" class="Symbol">)</a> <a id="27252" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27254" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="27261" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="27264" href="/Substitution/#11198" class="Function">cong-sub</a><a id="27272" class="Symbol">{</a><a id="27273" class="Argument">M</a> <a id="27275" class="Symbol">=</a> <a id="27277" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="27278" class="Symbol">}</a> <a id="27280" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27285" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27290" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="27299" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27301" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27303" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27305" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27307" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27309" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27311" class="Symbol">(</a><a id="27312" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27314" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27316" href="plfa.Substitution.html#3072" class="Function">ids</a><a id="27319" class="Symbol">)</a> <a id="27321" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27323" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="27330" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="27333" href="/Substitution/#11198" class="Function">cong-sub</a><a id="27341" class="Symbol">{</a><a id="27342" class="Argument">M</a> <a id="27344" class="Symbol">=</a> <a id="27346" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="27347" class="Symbol">}</a> <a id="27349" class="Symbol">(</a><a id="27350" href="plfa.Substitution.html#11937" class="Function">cong-cons</a> <a id="27360" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27365" class="Symbol">(</a><a id="27366" href="plfa.Substitution.html#17690" class="Function">sub-idR</a><a id="27373" class="Symbol">{</a><a id="27374" class="Argument">σ</a> <a id="27376" class="Symbol">=</a> <a id="27378" href="plfa.Substitution.html#26579" class="Bound">σ</a><a id="27379" class="Symbol">}))</a> <a id="27383" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27388" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="27397" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27399" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27401" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27403" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27405" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27407" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27409" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27411" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27413" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="27420" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="27423" href="/Substitution/#11198" class="Function">cong-sub</a><a id="27431" class="Symbol">{</a><a id="27432" class="Argument">M</a> <a id="27434" class="Symbol">=</a> <a id="27436" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="27437" class="Symbol">}</a> <a id="27439" class="Symbol">(</a><a id="27440" href="plfa.Substitution.html#11937" class="Function">cong-cons</a> <a id="27450" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27455" class="Symbol">(</a><a id="27456" href="plfa.Substitution.html#8993" class="Function">sub-idL</a><a id="27463" class="Symbol">{</a><a id="27464" class="Argument">σ</a> <a id="27466" class="Symbol">=</a> <a id="27468" href="plfa.Substitution.html#26579" class="Bound">σ</a><a id="27469" class="Symbol">}))</a> <a id="27473" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27478" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="27487" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27489" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27491" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27493" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27495" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27497" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27499" class="Symbol">(</a><a id="27500" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="27504" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27506" href="plfa.Substitution.html#26579" class="Bound">σ</a><a id="27507" class="Symbol">)</a> <a id="27509" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27511" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="27518" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="27521" href="/Substitution/#11198" class="Function">cong-sub</a><a id="27529" class="Symbol">{</a><a id="27530" class="Argument">M</a> <a id="27532" class="Symbol">=</a> <a id="27534" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="27535" class="Symbol">}</a> <a id="27537" class="Symbol">(</a><a id="27538" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="27542" href="plfa.Substitution.html#9100" class="Function">sub-dist</a><a id="27550" class="Symbol">)</a> <a id="27552" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27557" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="27566" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27568" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27570" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27572" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="27576" href="plfa.Substitution.html#3786" class="Function Operator">⨟</a> <a id="27578" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27580" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27582" href="plfa.Substitution.html#26573" class="Bound">N</a>
     <a id="27589" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="27592" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="27596" class="Symbol">(</a><a id="27597" href="/Substitution/#23001" class="Function">sub-sub</a><a id="27604" class="Symbol">{</a><a id="27605" class="Argument">M</a> <a id="27607" class="Symbol">=</a> <a id="27609" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="27610" class="Symbol">})</a> <a id="27613" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="27622" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27624" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27626" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27628" class="Symbol">(</a><a id="27629" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="27631" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27633" href="plfa.Substitution.html#3453" class="Function Operator">•</a> <a id="27635" href="plfa.Substitution.html#3072" class="Function">ids</a> <a id="27639" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27641" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="27642" class="Symbol">)</a>
     <a id="27649" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="27652" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="27657" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27659" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27661" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27663" class="Symbol">(</a><a id="27664" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="27668" class="Symbol">(</a><a id="27669" href="plfa.Substitution.html#11198" class="Function">cong-sub</a><a id="27677" class="Symbol">{</a><a id="27678" class="Argument">M</a> <a id="27680" class="Symbol">=</a> <a id="27682" href="plfa.Substitution.html#26573" class="Bound">N</a><a id="27683" class="Symbol">}</a> <a id="27685" href="plfa.Substitution.html#15825" class="Function">subst-Z-cons-ids</a> <a id="27702" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="27706" class="Symbol">))</a> <a id="27709" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="27718" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="27720" href="plfa.Substitution.html#26579" class="Bound">σ</a> <a id="27722" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="27724" class="Symbol">(</a><a id="27725" href="plfa.Substitution.html#26573" class="Bound">N</a> <a id="27727" href="/Untyped/#7225" class="Function Operator">[</a> <a id="27729" href="plfa.Substitution.html#26576" class="Bound">M</a> <a id="27731" href="plfa.Untyped.html#7225" class="Function Operator">]</a><a id="27732" class="Symbol">)</a>
     <a id="27739" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>
<p>A corollary of <code class="highlighter-rouge">subst-commute</code> is that <code class="highlighter-rouge">rename</code> also commutes with
substitution. In the proof below, we first exchange <code class="highlighter-rouge">rename ρ</code> for
the substitution <code class="highlighter-rouge">⟪ ren ρ ⟫</code>, and apply <code class="highlighter-rouge">subst-commute</code>, and
then convert back to <code class="highlighter-rouge">rename ρ</code>.</p>

<pre class="Agda"><a id="rename-subst-commute"></a><a id="27979" href="/Substitution/#27979" class="Function">rename-subst-commute</a> <a id="28000" class="Symbol">:</a> <a id="28002" class="Symbol">∀{</a><a id="28004" href="plfa.Substitution.html#28004" class="Bound">Γ</a> <a id="28006" href="plfa.Substitution.html#28006" class="Bound">Δ</a><a id="28007" class="Symbol">}{</a><a id="28009" href="plfa.Substitution.html#28009" class="Bound">N</a> <a id="28011" class="Symbol">:</a> <a id="28013" href="plfa.Substitution.html#28004" class="Bound">Γ</a> <a id="28015" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="28017" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a> <a id="28019" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="28021" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="28022" class="Symbol">}{</a><a id="28024" href="plfa.Substitution.html#28024" class="Bound">M</a> <a id="28026" class="Symbol">:</a> <a id="28028" href="plfa.Substitution.html#28004" class="Bound">Γ</a> <a id="28030" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="28032" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="28033" class="Symbol">}{</a><a id="28035" href="plfa.Substitution.html#28035" class="Bound">ρ</a> <a id="28037" class="Symbol">:</a> <a id="28039" href="plfa.Substitution.html#2218" class="Function">Rename</a> <a id="28046" href="plfa.Substitution.html#28004" class="Bound">Γ</a> <a id="28048" href="plfa.Substitution.html#28006" class="Bound">Δ</a> <a id="28050" class="Symbol">}</a>
    <a id="28056" class="Symbol">→</a> <a id="28058" class="Symbol">(</a><a id="28059" href="/Untyped/#5969" class="Function">rename</a> <a id="28066" class="Symbol">(</a><a id="28067" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="28071" href="/Substitution/#28035" class="Bound">ρ</a><a id="28072" class="Symbol">)</a> <a id="28074" href="plfa.Substitution.html#28009" class="Bound">N</a><a id="28075" class="Symbol">)</a> <a id="28077" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="28079" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="28086" href="plfa.Substitution.html#28035" class="Bound">ρ</a> <a id="28088" href="plfa.Substitution.html#28024" class="Bound">M</a> <a id="28090" href="plfa.Untyped.html#7225" class="Function Operator">]</a> <a id="28092" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="28094" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="28101" href="plfa.Substitution.html#28035" class="Bound">ρ</a> <a id="28103" class="Symbol">(</a><a id="28104" href="plfa.Substitution.html#28009" class="Bound">N</a> <a id="28106" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="28108" href="plfa.Substitution.html#28024" class="Bound">M</a> <a id="28110" href="plfa.Untyped.html#7225" class="Function Operator">]</a><a id="28111" class="Symbol">)</a>
<a id="28113" href="/Substitution/#27979" class="Function">rename-subst-commute</a> <a id="28134" class="Symbol">{</a><a id="28135" href="plfa.Substitution.html#28135" class="Bound">Γ</a><a id="28136" class="Symbol">}{</a><a id="28138" href="plfa.Substitution.html#28138" class="Bound">Δ</a><a id="28139" class="Symbol">}{</a><a id="28141" href="plfa.Substitution.html#28141" class="Bound">N</a><a id="28142" class="Symbol">}{</a><a id="28144" href="plfa.Substitution.html#28144" class="Bound">M</a><a id="28145" class="Symbol">}{</a><a id="28147" href="plfa.Substitution.html#28147" class="Bound">ρ</a><a id="28148" class="Symbol">}</a> <a id="28150" class="Symbol">=</a>
     <a id="28157" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
       <a id="28170" class="Symbol">(</a><a id="28171" href="/Untyped/#5969" class="Function">rename</a> <a id="28178" class="Symbol">(</a><a id="28179" href="plfa.Untyped.html#5659" class="Function">ext</a> <a id="28183" href="/Substitution/#28147" class="Bound">ρ</a><a id="28184" class="Symbol">)</a> <a id="28186" href="plfa.Substitution.html#28141" class="Bound">N</a><a id="28187" class="Symbol">)</a> <a id="28189" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="28191" href="plfa.Untyped.html#5969" class="Function">rename</a> <a id="28198" href="plfa.Substitution.html#28147" class="Bound">ρ</a> <a id="28200" href="plfa.Substitution.html#28144" class="Bound">M</a> <a id="28202" href="plfa.Untyped.html#7225" class="Function Operator">]</a>
     <a id="28209" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="28212" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="28221" class="Symbol">(</a><a id="28222" href="plfa.Substitution.html#11686" class="Function">cong-sub-zero</a> <a id="28236" class="Symbol">(</a><a id="28237" href="plfa.Substitution.html#13680" class="Function">rename-subst-ren</a><a id="28253" class="Symbol">{</a><a id="28254" class="Argument">M</a> <a id="28256" class="Symbol">=</a> <a id="28258" href="plfa.Substitution.html#28144" class="Bound">M</a><a id="28259" class="Symbol">}))</a>
                 <a id="28280" class="Symbol">(</a><a id="28281" href="/Substitution/#13680" class="Function">rename-subst-ren</a><a id="28297" class="Symbol">{</a><a id="28298" class="Argument">M</a> <a id="28300" class="Symbol">=</a> <a id="28302" href="plfa.Substitution.html#28141" class="Bound">N</a><a id="28303" class="Symbol">})</a> <a id="28306" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="28315" class="Symbol">(</a><a id="28316" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="28318" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="28322" class="Symbol">(</a><a id="28323" href="/Untyped/#5659" class="Function">ext</a> <a id="28327" href="plfa.Substitution.html#28147" class="Bound">ρ</a><a id="28328" class="Symbol">)</a> <a id="28330" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="28332" href="plfa.Substitution.html#28141" class="Bound">N</a><a id="28333" class="Symbol">)</a> <a id="28335" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="28337" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="28339" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="28343" href="plfa.Substitution.html#28147" class="Bound">ρ</a> <a id="28345" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="28347" href="plfa.Substitution.html#28144" class="Bound">M</a> <a id="28349" href="plfa.Untyped.html#7225" class="Function Operator">]</a>
     <a id="28356" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="28359" href="/Substitution/#11198" class="Function">cong-sub</a> <a id="28368" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="28373" class="Symbol">(</a><a id="28374" href="plfa.Substitution.html#11198" class="Function">cong-sub</a><a id="28382" class="Symbol">{</a><a id="28383" class="Argument">M</a> <a id="28385" class="Symbol">=</a> <a id="28387" href="plfa.Substitution.html#28141" class="Bound">N</a><a id="28388" class="Symbol">}</a> <a id="28390" href="plfa.Substitution.html#13311" class="Function">ren-ext</a> <a id="28398" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="28402" class="Symbol">)</a> <a id="28404" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="28413" class="Symbol">(</a><a id="28414" href="/Substitution/#2572" class="Function Operator">⟪</a> <a id="28416" href="/Untyped/#6405" class="Function">exts</a> <a id="28421" class="Symbol">(</a><a id="28422" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="28426" href="plfa.Substitution.html#28147" class="Bound">ρ</a><a id="28427" class="Symbol">)</a> <a id="28429" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="28431" href="plfa.Substitution.html#28141" class="Bound">N</a><a id="28432" class="Symbol">)</a> <a id="28434" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="28436" href="plfa.Substitution.html#2572" class="Function Operator">⟪</a> <a id="28438" href="plfa.Substitution.html#6524" class="Function">ren</a> <a id="28442" href="plfa.Substitution.html#28147" class="Bound">ρ</a> <a id="28444" href="plfa.Substitution.html#2572" class="Function Operator">⟫</a> <a id="28446" href="plfa.Substitution.html#28144" class="Bound">M</a> <a id="28448" href="plfa.Untyped.html#7225" class="Function Operator">]</a>
     <a id="28455" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="28458" href="/Substitution/#26438" class="Function">subst-commute</a><a id="28471" class="Symbol">{</a><a id="28472" class="Argument">N</a> <a id="28474" class="Symbol">=</a> <a id="28476" href="plfa.Substitution.html#28141" class="Bound">N</a><a id="28477" class="Symbol">}</a> <a id="28479" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="28488" href="/Untyped/#6697" class="Function">subst</a> <a id="28494" class="Symbol">(</a><a id="28495" href="/Substitution/#6524" class="Function">ren</a> <a id="28499" href="plfa.Substitution.html#28147" class="Bound">ρ</a><a id="28500" class="Symbol">)</a> <a id="28502" class="Symbol">(</a><a id="28503" href="plfa.Substitution.html#28141" class="Bound">N</a> <a id="28505" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="28507" href="plfa.Substitution.html#28144" class="Bound">M</a> <a id="28509" href="plfa.Untyped.html#7225" class="Function Operator">]</a><a id="28510" class="Symbol">)</a>
     <a id="28517" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="28520" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="28524" class="Symbol">(</a><a id="28525" href="/Substitution/#13680" class="Function">rename-subst-ren</a><a id="28541" class="Symbol">)</a> <a id="28543" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
       <a id="28552" href="/Untyped/#5969" class="Function">rename</a> <a id="28559" href="/Substitution/#28147" class="Bound">ρ</a> <a id="28561" class="Symbol">(</a><a id="28562" href="plfa.Substitution.html#28141" class="Bound">N</a> <a id="28564" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="28566" href="plfa.Substitution.html#28144" class="Bound">M</a> <a id="28568" href="plfa.Untyped.html#7225" class="Function Operator">]</a><a id="28569" class="Symbol">)</a>
     <a id="28576" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>
<p>To present the substitution lemma, we introduce the following notation
for substituting a term <code class="highlighter-rouge">M</code> for index 1 within term <code class="highlighter-rouge">N</code>.</p>

<pre class="Agda"><a id="_〔_〕"></a><a id="28716" href="/Substitution/#28716" class="Function Operator">_〔_〕</a> <a id="28721" class="Symbol">:</a> <a id="28723" class="Symbol">∀</a> <a id="28725" class="Symbol">{</a><a id="28726" href="plfa.Substitution.html#28726" class="Bound">Γ</a> <a id="28728" href="plfa.Substitution.html#28728" class="Bound">A</a> <a id="28730" href="plfa.Substitution.html#28730" class="Bound">B</a> <a id="28732" href="plfa.Substitution.html#28732" class="Bound">C</a><a id="28733" class="Symbol">}</a>
        <a id="28743" class="Symbol">→</a> <a id="28745" href="/Substitution/#28726" class="Bound">Γ</a> <a id="28747" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="28749" href="plfa.Substitution.html#28730" class="Bound">B</a> <a id="28751" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="28753" href="plfa.Substitution.html#28732" class="Bound">C</a> <a id="28755" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="28757" href="plfa.Substitution.html#28728" class="Bound">A</a>
        <a id="28767" class="Symbol">→</a> <a id="28769" href="/Substitution/#28726" class="Bound">Γ</a> <a id="28771" href="/Untyped/#4028" class="Datatype Operator">⊢</a> <a id="28773" href="plfa.Substitution.html#28730" class="Bound">B</a>
          <a id="28785" class="Comment">---------</a>
        <a id="28803" class="Symbol">→</a> <a id="28805" href="/Substitution/#28726" class="Bound">Γ</a> <a id="28807" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="28809" href="plfa.Substitution.html#28732" class="Bound">C</a> <a id="28811" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="28813" href="plfa.Substitution.html#28728" class="Bound">A</a>
<a id="28815" href="/Substitution/#28716" class="Function Operator">_〔_〕</a> <a id="28820" class="Symbol">{</a><a id="28821" href="plfa.Substitution.html#28821" class="Bound">Γ</a><a id="28822" class="Symbol">}</a> <a id="28824" class="Symbol">{</a><a id="28825" href="plfa.Substitution.html#28825" class="Bound">A</a><a id="28826" class="Symbol">}</a> <a id="28828" class="Symbol">{</a><a id="28829" href="plfa.Substitution.html#28829" class="Bound">B</a><a id="28830" class="Symbol">}</a> <a id="28832" class="Symbol">{</a><a id="28833" href="plfa.Substitution.html#28833" class="Bound">C</a><a id="28834" class="Symbol">}</a> <a id="28836" href="plfa.Substitution.html#28836" class="Bound">N</a> <a id="28838" href="plfa.Substitution.html#28838" class="Bound">M</a> <a id="28840" class="Symbol">=</a>
   <a id="28845" href="/Untyped/#6697" class="Function">subst</a> <a id="28851" class="Symbol">{</a><a id="28852" href="/Substitution/#28821" class="Bound">Γ</a> <a id="28854" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="28856" href="plfa.Substitution.html#28829" class="Bound">B</a> <a id="28858" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="28860" href="plfa.Substitution.html#28833" class="Bound">C</a><a id="28861" class="Symbol">}</a> <a id="28863" class="Symbol">{</a><a id="28864" href="plfa.Substitution.html#28821" class="Bound">Γ</a> <a id="28866" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="28868" href="plfa.Substitution.html#28833" class="Bound">C</a><a id="28869" class="Symbol">}</a> <a id="28871" class="Symbol">(</a><a id="28872" href="plfa.Untyped.html#6405" class="Function">exts</a> <a id="28877" class="Symbol">(</a><a id="28878" href="plfa.Untyped.html#7109" class="Function">subst-zero</a> <a id="28889" href="plfa.Substitution.html#28838" class="Bound">M</a><a id="28890" class="Symbol">))</a> <a id="28893" class="Symbol">{</a><a id="28894" href="plfa.Substitution.html#28825" class="Bound">A</a><a id="28895" class="Symbol">}</a> <a id="28897" href="plfa.Substitution.html#28836" class="Bound">N</a>
</pre>
<p>The substitution lemma is stated as follows and proved as a corollary
of the <code class="highlighter-rouge">subst-commute</code> lemma.</p>

<pre class="Agda"><a id="substitution"></a><a id="29009" href="/Substitution/#29009" class="Function">substitution</a> <a id="29022" class="Symbol">:</a> <a id="29024" class="Symbol">∀{</a><a id="29026" href="plfa.Substitution.html#29026" class="Bound">Γ</a><a id="29027" class="Symbol">}{</a><a id="29029" href="plfa.Substitution.html#29029" class="Bound">M</a> <a id="29031" class="Symbol">:</a> <a id="29033" href="plfa.Substitution.html#29026" class="Bound">Γ</a> <a id="29035" href="/Untyped/#2944" class="InductiveConstructor Operator">,</a> <a id="29037" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a> <a id="29039" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="29041" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a> <a id="29043" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="29045" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="29046" class="Symbol">}{</a><a id="29048" href="plfa.Substitution.html#29048" class="Bound">N</a> <a id="29050" class="Symbol">:</a> <a id="29052" href="plfa.Substitution.html#29026" class="Bound">Γ</a> <a id="29054" href="plfa.Untyped.html#2944" class="InductiveConstructor Operator">,</a> <a id="29056" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a> <a id="29058" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="29060" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="29061" class="Symbol">}{</a><a id="29063" href="plfa.Substitution.html#29063" class="Bound">L</a> <a id="29065" class="Symbol">:</a> <a id="29067" href="plfa.Substitution.html#29026" class="Bound">Γ</a> <a id="29069" href="plfa.Untyped.html#4028" class="Datatype Operator">⊢</a> <a id="29071" href="plfa.Untyped.html#2652" class="InductiveConstructor">★</a><a id="29072" class="Symbol">}</a>
    <a id="29078" class="Symbol">→</a> <a id="29080" class="Symbol">(</a><a id="29081" href="/Substitution/#29029" class="Bound">M</a> <a id="29083" href="/Untyped/#7225" class="Function Operator">[</a> <a id="29085" href="plfa.Substitution.html#29048" class="Bound">N</a> <a id="29087" href="plfa.Untyped.html#7225" class="Function Operator">]</a><a id="29088" class="Symbol">)</a> <a id="29090" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="29092" href="plfa.Substitution.html#29063" class="Bound">L</a> <a id="29094" href="plfa.Untyped.html#7225" class="Function Operator">]</a> <a id="29096" href="https://agda.github.io/agda-stdlib/v1.1/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="29098" class="Symbol">(</a><a id="29099" href="plfa.Substitution.html#29029" class="Bound">M</a> <a id="29101" href="plfa.Substitution.html#28716" class="Function Operator">〔</a> <a id="29103" href="plfa.Substitution.html#29063" class="Bound">L</a> <a id="29105" href="plfa.Substitution.html#28716" class="Function Operator">〕</a><a id="29106" class="Symbol">)</a> <a id="29108" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="29110" class="Symbol">(</a><a id="29111" href="plfa.Substitution.html#29048" class="Bound">N</a> <a id="29113" href="plfa.Untyped.html#7225" class="Function Operator">[</a> <a id="29115" href="plfa.Substitution.html#29063" class="Bound">L</a> <a id="29117" href="plfa.Untyped.html#7225" class="Function Operator">]</a><a id="29118" class="Symbol">)</a> <a id="29120" href="plfa.Untyped.html#7225" class="Function Operator">]</a>
<a id="29122" href="/Substitution/#29009" class="Function">substitution</a><a id="29134" class="Symbol">{</a><a id="29135" class="Argument">M</a> <a id="29137" class="Symbol">=</a> <a id="29139" href="plfa.Substitution.html#29139" class="Bound">M</a><a id="29140" class="Symbol">}{</a><a id="29142" class="Argument">N</a> <a id="29144" class="Symbol">=</a> <a id="29146" href="plfa.Substitution.html#29146" class="Bound">N</a><a id="29147" class="Symbol">}{</a><a id="29149" class="Argument">L</a> <a id="29151" class="Symbol">=</a> <a id="29153" href="plfa.Substitution.html#29153" class="Bound">L</a><a id="29154" class="Symbol">}</a> <a id="29156" class="Symbol">=</a>
   <a id="29161" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="29165" class="Symbol">(</a><a id="29166" href="/Substitution/#26438" class="Function">subst-commute</a><a id="29179" class="Symbol">{</a><a id="29180" class="Argument">N</a> <a id="29182" class="Symbol">=</a> <a id="29184" href="plfa.Substitution.html#29139" class="Bound">M</a><a id="29185" class="Symbol">}{</a><a id="29187" class="Argument">M</a> <a id="29189" class="Symbol">=</a> <a id="29191" href="plfa.Substitution.html#29146" class="Bound">N</a><a id="29192" class="Symbol">}{</a><a id="29194" class="Argument">σ</a> <a id="29196" class="Symbol">=</a> <a id="29198" href="/Untyped/#7109" class="Function">subst-zero</a> <a id="29209" href="plfa.Substitution.html#29153" class="Bound">L</a><a id="29210" class="Symbol">})</a>
</pre>

<h2 id="notes">Notes</h2>

<p>Most of the properties and proofs in this file are based on the paper
<em>Autosubst: Reasoning with de Bruijn Terms and Parallel Substitution</em>
by Schafer, Tebbi, and Smolka (ITP 2015). That paper, in turn, is
based on the paper of Abadi, Cardelli, Curien, and Levy (1991) that
defines the σ algebra.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:
    ⟪  U+27EA  MATHEMATICAL LEFT DOUBLE ANGLE BRACKET (&lt;&lt;)
    ⟫  U+27EA  MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET (&gt;&gt;)
    ↑  U+2191  UPWARDS ARROW (\u)
    •  U+2022  BULLET (\bub)
    ⨟  U+2A1F  Z NOTATION SCHEMA COMPOSITION (C-x 8 RET Z NOTATION SCHEMA COMPOSITION)
    〔  U+3014  LEFT TORTOISE SHELL BRACKET (( option 9 on page 2)
    〕  U+3015  RIGHT TORTOISE SHELL BRACKET () option 9 on page 2)</p>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/Untyped/">Prev</a>
    
    
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/Substitution.lagda.md">Source</a>
    
    
    &bullet;
    
    
    <a alt="Next chapter" href="/LambdaReduction/">Next</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programming Language Foundations in Agda
</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/assets/jquery.js"></script>

<script type="text/javascript">

 // Makes sandwhich menu works
 $('.menu-icon').click(function(){
   $('.trigger').toggle();
 });

 // Script which allows for foldable code blocks
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
